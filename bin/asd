#!/usr/bin/env node

const { Command } = require('commander');
const path = require('path');
const chalk = require('chalk');
const ASDClient = require('../lib/index');
const ConfigManager = require('../lib/config-manager');
const ContextInjector = require('../lib/context-injector');
const ContextManager = require('../lib/context-manager');
const ContextValidator = require('../lib/context-validator');
const ContextTriggerSystem = require('../lib/context-triggers');
const { TaskRecommendationAPI } = require('../lib/task-router');
const WorkflowStateManager = require('../lib/workflow-state-manager');

const program = new Command();

program
  .name('asd')
  .description('Agentic Spec Development (ASD) - AI-first terminal tool for specification development and project management')
  .version('0.1.0-alpha')
  .addHelpText('before', chalk.yellow('⚠️  Pre-Production Software: Features may change before stable release\n'))
  .option('-c, --config <path>', 'Path to configuration file')
  .option('-p, --path <path>', 'Path to specs directory (overrides config)')
  .option('--no-auto-refresh', 'Disable automatic file watching and refresh')
  .option('--app-name <name>', 'Custom application name')
  .option('--app-icon <icon>', 'Custom application icon')
  .option('--debug', 'Enable debug output');

// Context management commands
const contextCommand = program
  .command('context')
  .description('Manage context files and injection system');

contextCommand
  .command('add')
  .description('Add content to context files')
  .option('--project', 'Add to project-level context')
  .option('--spec <spec-id>', 'Add to spec context')
  .option('--task <task-id>', 'Add to task context')
  .option('--constraint <text>', 'Add constraint')
  .option('--research <text>', 'Add research finding')
  .option('--decision <text>', 'Add implementation decision')
  .option('--content <text>', 'Add markdown content')
  .action(async (options) => {
    await handleContextAdd(options);
  });

contextCommand
  .command('update')
  .description('Update existing context files')
  .option('--spec <spec-id>', 'Update spec context')
  .option('--task <task-id>', 'Update task context')
  .option('--status <status>', 'Update status')
  .option('--progress <progress>', 'Update progress information')
  .option('--assign <agent-type>', 'Assign agent to task')
  .action(async (options) => {
    await handleContextUpdate(options);
  });

contextCommand
  .command('show')
  .description('Display context information')
  .option('--spec <spec-id>', 'Show spec context')
  .option('--task <task-id>', 'Show task context')
  .option('--agent <agent-type>', 'Show agent-specific context')
  .option('--inject', 'Show full injected context for agent')
  .option('--layers', 'Show all context layers')
  .action(async (options) => {
    await handleContextShow(options);
  });

contextCommand
  .command('validate')
  .description('Validate context files and system consistency')
  .option('--fix-issues', 'Attempt to fix validation issues')
  .option('--files <pattern>', 'Validate specific files (glob pattern)')
  .option('--verbose', 'Show detailed validation results')
  .action(async (options) => {
    await handleContextValidate(options);
  });

contextCommand
  .command('export')
  .description('Export context data for backup or sharing')
  .option('--output <path>', 'Output file path', './context-export.json')
  .option('--spec <spec-id>', 'Export specific spec context')
  .option('--include-state', 'Include dynamic state data')
  .action(async (options) => {
    await handleContextExport(options);
  });

contextCommand
  .command('import')
  .description('Import context data from backup')
  .argument('<file>', 'Context export file to import')
  .option('--merge', 'Merge with existing context (default: replace)')
  .option('--dry-run', 'Show what would be imported without making changes')
  .action(async (file, options) => {
    await handleContextImport(file, options);
  });

// Agent customization commands
const agentCommand = program
  .command('agent')
  .description('Manage agent definitions and customization');

agentCommand
  .command('customize')
  .description('Customize agent workflows and requirements')
  .argument('<agent-type>', 'Agent type to customize')
  .option('--add-step <step>', 'Add workflow step')
  .option('--add-requirement <req>', 'Add context requirement')
  .option('--add-capability <cap>', 'Add agent capability')
  .option('--remove-step <step>', 'Remove workflow step')
  .option('--edit', 'Open agent definition in editor')
  .action(async (agentType, options) => {
    await handleAgentCustomize(agentType, options);
  });

agentCommand
  .command('list')
  .description('List available agents and their capabilities')
  .option('--details', 'Show detailed agent information')
  .action(async (options) => {
    await handleAgentList(options);
  });

// Process management commands
const processCommand = program
  .command('process')
  .description('Manage process templates and workflows');

processCommand
  .command('update')
  .description('Update process templates')
  .argument('<template-name>', 'Process template to update')
  .option('--add-requirement <req>', 'Add validation requirement')
  .option('--add-step <step>', 'Add process step')
  .option('--edit', 'Open template in editor')
  .action(async (templateName, options) => {
    await handleProcessUpdate(templateName, options);
  });

processCommand
  .command('list')
  .description('List available process templates')
  .action(async () => {
    await handleProcessList();
  });

// Task routing and recommendation commands
program
  .command('next')
  .description('Get next recommended task for an agent')
  .requiredOption('--agent <agent-type>', 'Agent type (required)')
  .option('--priority <priorities>', 'Filter by priority (P0,P1,P2,P3)', 'P0,P1,P2,P3')
  .option('--phase <phases>', 'Filter by phase (PHASE-1A,PHASE-1B)', 'PHASE-1A,PHASE-1B')
  .option('--spec-status <status>', 'Filter by spec status (active,ready,backlog)', 'active,ready')
  .option('--show-alternatives', 'Show alternative task recommendations', false)
  .option('--show-reasoning', 'Show detailed recommendation reasoning', false)
  .option('--transparent', 'Show full scoring and constraint details', false)
  .option('--limit <number>', 'Maximum number of tasks to return', '5')
  .action(async (options) => {
    await handleNextTask(options);
  });

program
  .command('tasks')
  .description('List available tasks with filtering')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--priority <priorities>', 'Filter by priority (P0,P1,P2,P3)')
  .option('--phase <phases>', 'Filter by phase')
  .option('--spec-status <status>', 'Filter by spec status')
  .option('--status <status>', 'Filter by task status (ready,blocked,complete)')
  .option('--include-blocked', 'Include blocked tasks', false)
  .option('--limit <number>', 'Maximum number of tasks to return', '10')
  .action(async (options) => {
    await handleTasksList(options);
  });

program
  .command('validate-assignment')
  .description('Validate if a task can be assigned to an agent')
  .requiredOption('--task <task-id>', 'Task ID to validate')
  .requiredOption('--agent <agent-type>', 'Agent type for assignment')
  .option('--show-details', 'Show detailed validation information', false)
  .action(async (options) => {
    await handleValidateAssignment(options);
  });

// Task lifecycle commands with context updates
program
  .command('assign')
  .description('Assign task to agent with context update and routing validation')
  .argument('<spec-id>', 'Specification ID')
  .argument('<task-id>', 'Task ID')
  .option('--agent <agent-type>', 'Agent type to assign')
  .option('--priority <priority>', 'Task priority (P0, P1, P2, P3)')
  .option('--validate', 'Validate assignment before applying', true)
  .action(async (specId, taskId, options) => {
    await handleTaskAssign(specId, taskId, options);
  });

program
  .command('complete')
  .description('Mark task as complete and update context')
  .argument('<spec-id>', 'Specification ID')
  .argument('<task-id>', 'Task ID')
  .option('--notes <notes>', 'Completion notes')
  .option('--handoff <next-task>', 'Next task to hand off to')
  .action(async (specId, taskId, options) => {
    await handleTaskComplete(specId, taskId, options);
  });

program
  .command('research')
  .description('Capture research findings and update context')
  .argument('<spec-id>', 'Specification ID')
  .option('--task <task-id>', 'Specific task ID')
  .option('--finding <text>', 'Research finding to record')
  .option('--source <source>', 'Source of research')
  .action(async (specId, options) => {
    await handleResearchCapture(specId, options);
  });

// Workflow state management commands
const workflowCommand = program
  .command('workflow')
  .description('Manage workflow state and progress tracking');

workflowCommand
  .command('status')
  .description('Show current workflow status and assignments')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--verbose', 'Show detailed status information')
  .action(async (options) => {
    await handleWorkflowStatus(options);
  });

workflowCommand
  .command('progress')
  .description('Show project progress breakdown')
  .option('--spec <spec-id>', 'Show progress for specific spec')
  .option('--phase <phase>', 'Filter by phase')
  .option('--detailed', 'Show detailed progress breakdown')
  .action(async (options) => {
    await handleWorkflowProgress(options);
  });

workflowCommand
  .command('handoffs')
  .description('Show ready handoffs and handoff history')
  .option('--ready-only', 'Show only ready handoffs')
  .option('--history', 'Show handoff history')
  .action(async (options) => {
    await handleWorkflowHandoffs(options);
  });

workflowCommand
  .command('validate')
  .description('Validate workflow state consistency')
  .option('--fix', 'Attempt to fix consistency issues')
  .action(async (options) => {
    await handleWorkflowValidate(options);
  });

program
  .command('init')
  .description('Initialize ASD in the current directory')
  .option('-t, --type <type>', 'Project type (spec, feature, mixed)', 'mixed')
  .action(async (_options) => {
    console.log(chalk.cyan('🤖 Initializing Agentic Spec Development...'));

    const configManager = new ConfigManager(process.cwd());
    const configPath = path.join(process.cwd(), 'asd.config.js');

    try {
      configManager.createExampleConfig(configPath);
      console.log(chalk.green(`✅ Created configuration file: ${configPath}`));

      // Create default directory structure
      const fs = require('fs').promises;
      const specsPath = path.join(process.cwd(), 'docs/specs');

      await fs.mkdir(path.join(specsPath, 'active'), { recursive: true });
      await fs.mkdir(path.join(specsPath, 'backlog'), { recursive: true });
      await fs.mkdir(path.join(specsPath, 'done'), { recursive: true });
      await fs.mkdir(path.join(specsPath, 'template'), { recursive: true });

      console.log(chalk.green('✅ Created directory structure:'));
      console.log(chalk.gray('   docs/specs/active/'));
      console.log(chalk.gray('   docs/specs/backlog/'));
      console.log(chalk.gray('   docs/specs/done/'));
      console.log(chalk.gray('   docs/specs/template/'));

      console.log(chalk.cyan('\n🚀 ASD initialization complete!'));
      console.log(chalk.white('Run "asd" to start the terminal interface.'));

    } catch (error) {
      console.error(chalk.red('❌ Initialization failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('config')
  .description('Show current configuration')
  .action(() => {
    const configManager = new ConfigManager(process.cwd());
    const configInfo = configManager.getConfigInfo();

    console.log(chalk.cyan('🤖 ASD Configuration'));
    console.log(chalk.gray('='.repeat(50)));

    if (configInfo.configPath) {
      console.log(chalk.white('Config file:'), chalk.yellow(configInfo.configPath));
    } else {
      console.log(chalk.white('Config file:'), chalk.gray('Using defaults (no config file found)'));
    }

    console.log(chalk.white('Project root:'), chalk.yellow(configInfo.projectRoot));
    console.log(chalk.white('Specs path:'), chalk.yellow(configInfo.config.dataPath));
    console.log(chalk.white('Auto refresh:'), configInfo.config.autoRefresh ? chalk.green('enabled') : chalk.red('disabled'));
    console.log(chalk.white('Supported types:'), chalk.cyan(configInfo.config.supportedTypes.join(', ')));
    console.log(chalk.white('Status folders:'), chalk.cyan(configInfo.config.statusFolders.join(', ')));
  });

program
  .command('doctor')
  .description('Check ASD setup and configuration')
  .action(async () => {
    console.log(chalk.cyan('🔍 ASD Health Check'));
    console.log(chalk.gray('='.repeat(50)));

    const configManager = new ConfigManager(process.cwd());
    const config = configManager.loadConfig();
    const fs = require('fs').promises;

    let allGood = true;

    // Check if specs directory exists
    try {
      await fs.access(config.dataPath);
      console.log(chalk.green('✅ Specs directory exists:'), chalk.yellow(config.dataPath));
    } catch (error) {
      console.log(chalk.red('❌ Specs directory missing:'), chalk.yellow(config.dataPath));
      allGood = false;
    }

    // Check if status folders exist
    for (const folder of config.statusFolders) {
      const folderPath = path.join(config.dataPath, folder);
      try {
        await fs.access(folderPath);
        console.log(chalk.green('✅ Status folder exists:'), chalk.gray(folder));
      } catch (error) {
        console.log(chalk.red('❌ Status folder missing:'), chalk.gray(folder));
        allGood = false;
      }
    }

    // Check for spec files
    let totalSpecs = 0;
    for (const folder of config.statusFolders) {
      const folderPath = path.join(config.dataPath, folder);
      try {
        const files = await fs.readdir(folderPath);
        const mdFiles = files.filter(file => file.endsWith('.md'));
        totalSpecs += mdFiles.length;
      } catch (error) {
        // Folder doesn't exist, already reported above
      }
    }

    if (totalSpecs > 0) {
      console.log(chalk.green(`✅ Found ${totalSpecs} specification files`));
    } else {
      console.log(chalk.yellow('⚠️  No specification files found'));
    }

    // Check dependencies
    try {
      require('terminal-kit');
      console.log(chalk.green('✅ terminal-kit dependency available'));
    } catch (error) {
      console.log(chalk.red('❌ terminal-kit dependency missing'));
      allGood = false;
    }

    console.log(chalk.gray('='.repeat(50)));
    if (allGood) {
      console.log(chalk.green('🎉 All checks passed! ASD is ready to use.'));
    } else {
      console.log(chalk.red('❌ Some issues found. Run "asd init" to set up missing directories.'));
      process.exit(1);
    }
  });

// Default command - start the interactive terminal
program
  .command('start')
  .description('Start the interactive ASD terminal interface (default)')
  .action(async () => {
    const options = program.opts();
    await startASD(options);
  });

// Handle when no command is specified (default to start)
program.action(async () => {
  const options = program.opts();
  await startASD(options);
});

// Handler functions for context commands
async function handleContextAdd(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Determine context type and ID
    let contextType, contextId;
    if (options.project) {
      contextType = 'project';
      contextId = null;
    } else if (options.spec) {
      contextType = 'spec';
      contextId = options.spec;
    } else if (options.task) {
      contextType = 'task';
      contextId = options.task;
    } else {
      console.error(chalk.red('❌ Must specify --project, --spec <id>, or --task <id>'));
      process.exit(1);
    }

    // Build updates object
    const updates = { frontmatter: {} };

    if (options.constraint) {
      updates.frontmatter.constraints = updates.frontmatter.constraints || [];
      updates.frontmatter.constraints.push(options.constraint);
    }

    if (options.research) {
      updates.frontmatter.research_findings = updates.frontmatter.research_findings || [];
      updates.frontmatter.research_findings.push({
        finding: options.research,
        timestamp: new Date().toISOString(),
        source: 'manual'
      });
    }

    if (options.decision) {
      updates.frontmatter.implementation_decisions = updates.frontmatter.implementation_decisions || [];
      updates.frontmatter.implementation_decisions.push({
        decision: options.decision,
        timestamp: new Date().toISOString(),
        rationale: 'user input'
      });
    }

    if (options.content) {
      updates.content = options.content;
    }

    if (Object.keys(updates.frontmatter).length === 0 && !updates.content) {
      console.error(chalk.red('❌ Must provide --constraint, --research, --decision, or --content'));
      process.exit(1);
    }

    // Update context and trigger system
    const success = await contextManager.updateContext(contextType, contextId, updates);

    if (success) {
      // Fire trigger for context addition
      await triggerSystem.fireTrigger('context_add', {
        contextType,
        contextId,
        updates,
        source: 'cli_command'
      });

      console.log(chalk.green(`✅ Updated ${contextType} context${contextId ? ` for ${contextId}` : ''}`));
    } else {
      console.error(chalk.red('❌ Failed to update context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Context add failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextUpdate(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);

    // Determine what to update
    if (!options.spec && !options.task) {
      console.error(chalk.red('❌ Must specify --spec <id> or --task <id>'));
      process.exit(1);
    }

    const contextType = options.spec ? 'spec' : 'task';
    const contextId = options.spec || options.task;

    const updates = { frontmatter: {} };

    if (options.status) {
      updates.frontmatter.status = options.status;
    }

    if (options.progress) {
      updates.frontmatter.progress = JSON.parse(options.progress);
    }

    if (options.assign) {
      updates.frontmatter.assigned_agent = options.assign;
      updates.frontmatter.assigned_at = new Date().toISOString();
    }

    // Update context
    const success = await contextManager.updateContext(contextType, contextId, updates);

    if (success) {
      console.log(chalk.green(`✅ Updated ${contextType} context for ${contextId}`));
    } else {
      console.error(chalk.red('❌ Failed to update context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Context update failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextShow(options) {
  try {
    const configManager = new ConfigManager(process.cwd());

    if (options.inject && options.agent) {
      // Show full injected context for agent
      const contextInjector = new ContextInjector(configManager);
      const injectedContext = await contextInjector.injectContext({
        agentType: options.agent,
        specId: options.spec,
        taskId: options.task
      });

      console.log(chalk.cyan('🔄 Injected Context Preview'));
      console.log(chalk.gray('='.repeat(50)));

      if (options.layers) {
        console.log(JSON.stringify(injectedContext, null, 2));
      } else {
        // Show condensed view
        console.log(chalk.white('Agent:'), chalk.yellow(injectedContext.metadata.agentType));
        console.log(chalk.white('Layers:'), chalk.cyan(Object.keys(injectedContext.layers).join(', ')));
        console.log(chalk.white('Performance:'), chalk.green(`${injectedContext.metadata.performance.total}ms`));

        if (injectedContext.inheritance) {
          console.log(chalk.white('Inheritance:'), chalk.blue(injectedContext.inheritance.hierarchy.join(' → ')));
        }

        if (injectedContext.relevanceScore) {
          console.log(chalk.white('Relevance:'), chalk.magenta(`${Math.round(injectedContext.relevanceScore * 100)}%`));
        }
      }
    } else if (options.spec || options.task) {
      // Show specific context
      const contextManager = new ContextManager(configManager);
      const contextType = options.spec ? 'spec' : 'task';
      const contextId = options.spec || options.task;

      const contextPath = contextType === 'spec'
        ? path.join(configManager.getProjectRoot(), '.asd', 'context', 'specs', `${contextId}-context.md`)
        : path.join(configManager.getProjectRoot(), '.asd', 'context', 'tasks', `${contextId}-context.md`);

      if (await contextManager.fileExists(contextPath)) {
        const fs = require('fs').promises;
        const content = await fs.readFile(contextPath, 'utf-8');
        console.log(chalk.cyan(`📄 ${contextType.charAt(0).toUpperCase() + contextType.slice(1)} Context: ${contextId}`));
        console.log(chalk.gray('='.repeat(50)));
        console.log(content);
      } else {
        console.log(chalk.yellow(`⚠️  No ${contextType} context found for ${contextId}`));
      }
    } else {
      // Show general context info
      const contextManager = new ContextManager(configManager);
      const paths = contextManager.getContextPaths();

      console.log(chalk.cyan('📋 Context System Overview'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Base Directory:'), chalk.yellow(paths.base));
      console.log(chalk.white('Context Path:'), chalk.yellow(paths.context));
      console.log(chalk.white('Agents Path:'), chalk.yellow(paths.agents));
      console.log(chalk.white('Processes Path:'), chalk.yellow(paths.processes));
    }

  } catch (error) {
    console.error(chalk.red('❌ Context show failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextValidate(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextValidator = new ContextValidator(configManager);

    if (options.files) {
      // Validate specific files using glob pattern
      const glob = require('glob');
      const filePaths = glob.sync(options.files);

      if (filePaths.length === 0) {
        console.log(chalk.yellow(`⚠️  No files found matching pattern: ${options.files}`));
        return;
      }

      const summary = await contextValidator.validateContextFiles(filePaths);

      console.log(chalk.cyan('🔍 Context Validation Results'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Total Files:'), chalk.blue(summary.totalFiles));
      console.log(chalk.white('Valid Files:'), chalk.green(summary.validFiles));
      console.log(chalk.white('Invalid Files:'), summary.invalidFiles > 0 ? chalk.red(summary.invalidFiles) : chalk.green(summary.invalidFiles));
      console.log(chalk.white('Warnings:'), summary.warnings > 0 ? chalk.yellow(summary.warnings) : chalk.green(summary.warnings));

      if (options.verbose) {
        summary.results.forEach(result => {
          console.log(chalk.gray('\n---'));
          console.log(chalk.white('File:'), result.filePath);
          console.log(chalk.white('Valid:'), result.isValid ? chalk.green('✓') : chalk.red('✗'));

          if (result.errors.length > 0) {
            console.log(chalk.red('Errors:'));
            result.errors.forEach(error => console.log(chalk.red(`  • ${error}`)));
          }

          if (result.warnings.length > 0) {
            console.log(chalk.yellow('Warnings:'));
            result.warnings.forEach(warning => console.log(chalk.yellow(`  • ${warning}`)));
          }
        });
      }
    } else {
      // Validate entire context system
      const glob = require('glob');
      const contextPaths = contextValidator.configManager.getProjectRoot();
      const allContextFiles = glob.sync(path.join(contextPaths, '.asd/**/*.md'));

      const summary = await contextValidator.validateContextFiles(allContextFiles);

      console.log(chalk.cyan('🔍 Full Context System Validation'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Total Files:'), chalk.blue(summary.totalFiles));
      console.log(chalk.white('Valid Files:'), chalk.green(summary.validFiles));
      console.log(chalk.white('Invalid Files:'), summary.invalidFiles > 0 ? chalk.red(summary.invalidFiles) : chalk.green(summary.invalidFiles));
      console.log(chalk.white('Warnings:'), summary.warnings > 0 ? chalk.yellow(summary.warnings) : chalk.green(summary.warnings));

      if (summary.invalidFiles === 0 && summary.warnings === 0) {
        console.log(chalk.green('\n✅ Context system validation passed!'));
      } else if (summary.invalidFiles === 0) {
        console.log(chalk.yellow('\n⚠️  Context system validation passed with warnings'));
      } else {
        console.log(chalk.red('\n❌ Context system validation failed'));
        process.exit(1);
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Context validation failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextExport(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const paths = contextManager.getContextPaths();

    const exportData = {
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      context: {},
      agents: {},
      processes: {}
    };

    // Export context files
    const glob = require('glob');
    const fs = require('fs').promises;

    const contextFiles = glob.sync(path.join(paths.context, '**/*.md'));
    for (const filePath of contextFiles) {
      const relativePath = path.relative(paths.context, filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      exportData.context[relativePath] = parsed;
    }

    // Export agent definitions
    const agentFiles = glob.sync(path.join(paths.agents, '*.md'));
    for (const filePath of agentFiles) {
      const filename = path.basename(filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      exportData.agents[filename] = parsed;
    }

    // Export process templates
    const processFiles = glob.sync(path.join(paths.processes, '*.md'));
    for (const filePath of processFiles) {
      const filename = path.basename(filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      exportData.processes[filename] = parsed;
    }

    // Include state if requested
    if (options.includeState) {
      const dynamicContext = await contextManager.loadDynamicContext();
      exportData.state = dynamicContext;
    }

    // Filter by spec if requested
    if (options.spec) {
      const specContext = exportData.context[`specs/${options.spec}-context.md`];
      exportData.context = specContext ? { [`specs/${options.spec}-context.md`]: specContext } : {};
    }

    // Write export file
    await fs.writeFile(options.output, JSON.stringify(exportData, null, 2), 'utf-8');

    console.log(chalk.green(`✅ Context exported to ${options.output}`));
    console.log(chalk.gray(`   Context files: ${Object.keys(exportData.context).length}`));
    console.log(chalk.gray(`   Agent files: ${Object.keys(exportData.agents).length}`));
    console.log(chalk.gray(`   Process files: ${Object.keys(exportData.processes).length}`));

  } catch (error) {
    console.error(chalk.red('❌ Context export failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextImport(file, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const paths = contextManager.getContextPaths();

    const fs = require('fs').promises;

    // Read import file
    const importData = JSON.parse(await fs.readFile(file, 'utf-8'));

    if (options.dryRun) {
      console.log(chalk.cyan('🔍 Import Preview (Dry Run)'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Context files to import:'), chalk.blue(Object.keys(importData.context || {}).length));
      console.log(chalk.white('Agent files to import:'), chalk.blue(Object.keys(importData.agents || {}).length));
      console.log(chalk.white('Process files to import:'), chalk.blue(Object.keys(importData.processes || {}).length));

      if (importData.state) {
        console.log(chalk.white('State data:'), chalk.yellow('included'));
      }

      console.log(chalk.yellow('\nNo changes made (dry run)'));
      return;
    }

    // Ensure directories exist
    await contextManager.initializeContextStructure();

    let importedCount = 0;

    // Import context files
    for (const [relativePath, parsed] of Object.entries(importData.context || {})) {
      const fullPath = path.join(paths.context, relativePath);
      await fs.mkdir(path.dirname(fullPath), { recursive: true });

      const content = contextManager.serializeMarkdownWithFrontmatter(
        parsed.frontmatter || {},
        parsed.content || ''
      );

      await fs.writeFile(fullPath, content, 'utf-8');
      importedCount++;
    }

    // Import agent definitions
    for (const [filename, parsed] of Object.entries(importData.agents || {})) {
      const fullPath = path.join(paths.agents, filename);

      const content = contextManager.serializeMarkdownWithFrontmatter(
        parsed.frontmatter || {},
        parsed.content || ''
      );

      await fs.writeFile(fullPath, content, 'utf-8');
      importedCount++;
    }

    // Import process templates
    for (const [filename, parsed] of Object.entries(importData.processes || {})) {
      const fullPath = path.join(paths.processes, filename);

      const content = contextManager.serializeMarkdownWithFrontmatter(
        parsed.frontmatter || {},
        parsed.content || ''
      );

      await fs.writeFile(fullPath, content, 'utf-8');
      importedCount++;
    }

    // Import state if present
    if (importData.state) {
      const assignmentsPath = path.join(paths.state, 'assignments.json');
      const progressPath = path.join(paths.state, 'progress.json');

      if (importData.state.assignments) {
        await fs.writeFile(assignmentsPath, JSON.stringify(importData.state.assignments, null, 2), 'utf-8');
      }

      if (importData.state.progress) {
        await fs.writeFile(progressPath, JSON.stringify(importData.state.progress, null, 2), 'utf-8');
      }
    }

    console.log(chalk.green('✅ Context import completed'));
    console.log(chalk.gray(`   Files imported: ${importedCount}`));
    console.log(chalk.gray(`   Source: ${file}`));

  } catch (error) {
    console.error(chalk.red('❌ Context import failed:'), error.message);
    process.exit(1);
  }
}

async function handleAgentCustomize(agentType, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const agentPath = path.join(configManager.getProjectRoot(), '.asd', 'agents', `${agentType}.md`);

    const fs = require('fs').promises;

    // Check if agent exists
    if (!(await fs.access(agentPath).then(() => true).catch(() => false))) {
      console.error(chalk.red(`❌ Agent definition not found: ${agentType}`));
      console.log(chalk.gray(`   Expected path: ${agentPath}`));
      process.exit(1);
    }

    if (options.edit) {
      // Open in editor
      const { spawn } = require('child_process');
      const editor = process.env.EDITOR || 'nano';

      const child = spawn(editor, [agentPath], {
        stdio: 'inherit'
      });

      child.on('exit', (code) => {
        if (code === 0) {
          console.log(chalk.green(`✅ Agent definition updated: ${agentType}`));
        } else {
          console.error(chalk.red('❌ Editor exited with error'));
          process.exit(1);
        }
      });
    } else {
      // Programmatic updates
      const content = await fs.readFile(agentPath, 'utf-8');
      const contextManager = new ContextManager(configManager);
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);

      let updated = false;
      const frontmatter = parsed.frontmatter || {};

      if (options.addStep) {
        frontmatter.workflow_steps = frontmatter.workflow_steps || [];
        frontmatter.workflow_steps.push(options.addStep);
        updated = true;
      }

      if (options.removeStep) {
        if (frontmatter.workflow_steps) {
          const index = frontmatter.workflow_steps.indexOf(options.removeStep);
          if (index > -1) {
            frontmatter.workflow_steps.splice(index, 1);
            updated = true;
          }
        }
      }

      if (options.addRequirement) {
        frontmatter.context_requirements = frontmatter.context_requirements || [];
        frontmatter.context_requirements.push(options.addRequirement);
        updated = true;
      }

      if (options.addCapability) {
        frontmatter.capabilities = frontmatter.capabilities || [];
        frontmatter.capabilities.push(options.addCapability);
        updated = true;
      }

      if (updated) {
        const newContent = contextManager.serializeMarkdownWithFrontmatter(frontmatter, parsed.content);
        await fs.writeFile(agentPath, newContent, 'utf-8');
        console.log(chalk.green(`✅ Agent definition updated: ${agentType}`));
      } else {
        console.log(chalk.yellow('⚠️  No updates specified'));
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Agent customize failed:'), error.message);
    process.exit(1);
  }
}

async function handleAgentList(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const agentsPath = path.join(configManager.getProjectRoot(), '.asd', 'agents');

    const fs = require('fs').promises;
    const glob = require('glob');

    const agentFiles = glob.sync(path.join(agentsPath, '*.md'));

    console.log(chalk.cyan('👥 Available Agents'));
    console.log(chalk.gray('='.repeat(50)));

    if (agentFiles.length === 0) {
      console.log(chalk.yellow('⚠️  No agent definitions found'));
      return;
    }

    const contextManager = new ContextManager(configManager);

    for (const filePath of agentFiles) {
      const agentType = path.basename(filePath, '.md');
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      const frontmatter = parsed.frontmatter || {};

      console.log(chalk.white('\n• Agent:'), chalk.yellow(agentType));

      if (options.details) {
        if (frontmatter.capabilities) {
          console.log(chalk.gray('  Capabilities:'), frontmatter.capabilities.slice(0, 3).join(', '));
        }
        if (frontmatter.specialization_areas) {
          console.log(chalk.gray('  Specializations:'), frontmatter.specialization_areas.slice(0, 3).join(', '));
        }
        if (frontmatter.context_requirements) {
          console.log(chalk.gray('  Context Needs:'), frontmatter.context_requirements.slice(0, 2).join(', '));
        }
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Agent list failed:'), error.message);
    process.exit(1);
  }
}

async function handleProcessUpdate(templateName, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const processPath = path.join(configManager.getProjectRoot(), '.asd', 'processes', `${templateName}.md`);

    const fs = require('fs').promises;

    if (options.edit) {
      // Open in editor
      const { spawn } = require('child_process');
      const editor = process.env.EDITOR || 'nano';

      const child = spawn(editor, [processPath], {
        stdio: 'inherit'
      });

      child.on('exit', (code) => {
        if (code === 0) {
          console.log(chalk.green(`✅ Process template updated: ${templateName}`));
        } else {
          console.error(chalk.red('❌ Editor exited with error'));
          process.exit(1);
        }
      });
    } else {
      // Programmatic updates
      let content, parsed;

      try {
        content = await fs.readFile(processPath, 'utf-8');
        const contextManager = new ContextManager(configManager);
        parsed = contextManager.parseMarkdownWithFrontmatter(content);
      } catch (error) {
        // File doesn't exist, create new
        parsed = { frontmatter: {}, content: '' };
      }

      let updated = false;
      const frontmatter = parsed.frontmatter || {};

      if (options.addRequirement) {
        frontmatter.validation_requirements = frontmatter.validation_requirements || [];
        frontmatter.validation_requirements.push(options.addRequirement);
        updated = true;
      }

      if (options.addStep) {
        frontmatter.process_steps = frontmatter.process_steps || [];
        frontmatter.process_steps.push(options.addStep);
        updated = true;
      }

      if (updated) {
        const contextManager = new ContextManager(configManager);
        const newContent = contextManager.serializeMarkdownWithFrontmatter(frontmatter, parsed.content);
        await fs.writeFile(processPath, newContent, 'utf-8');
        console.log(chalk.green(`✅ Process template updated: ${templateName}`));
      } else {
        console.log(chalk.yellow('⚠️  No updates specified'));
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Process update failed:'), error.message);
    process.exit(1);
  }
}

async function handleProcessList() {
  try {
    const configManager = new ConfigManager(process.cwd());
    const processesPath = path.join(configManager.getProjectRoot(), '.asd', 'processes');

    const fs = require('fs').promises;
    const glob = require('glob');

    const processFiles = glob.sync(path.join(processesPath, '*.md'));

    console.log(chalk.cyan('📋 Available Process Templates'));
    console.log(chalk.gray('='.repeat(50)));

    if (processFiles.length === 0) {
      console.log(chalk.yellow('⚠️  No process templates found'));
      return;
    }

    const contextManager = new ContextManager(configManager);

    for (const filePath of processFiles) {
      const templateName = path.basename(filePath, '.md');
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      const frontmatter = parsed.frontmatter || {};

      console.log(chalk.white('• Template:'), chalk.yellow(templateName));

      if (frontmatter.process_type) {
        console.log(chalk.gray('  Type:'), frontmatter.process_type);
      }

      if (frontmatter.validation_requirements && frontmatter.validation_requirements.length > 0) {
        console.log(chalk.gray('  Requirements:'), frontmatter.validation_requirements.length);
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Process list failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskAssign(specId, taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    if (!options.agent) {
      console.error(chalk.red('❌ Must specify --agent <agent-type>'));
      process.exit(1);
    }

    // Validate assignment using routing system if requested
    if (options.validate !== false) {
      console.log(chalk.blue('🔍 Validating assignment...'));

      const taskAPI = new TaskRecommendationAPI(configManager);
      const initialized = await taskAPI.initialize();

      if (initialized) {
        const validation = await taskAPI.validateAssignment({
          taskId: taskId,
          agentType: options.agent
        });

        if (validation.success && !validation.valid) {
          console.error(chalk.red('❌ Assignment validation failed:'));
          validation.issues.forEach(issue => {
            console.error(chalk.red(`  • ${issue}`));
          });

          if (validation.warnings && validation.warnings.length > 0) {
            console.warn(chalk.yellow('⚠️  Warnings:'));
            validation.warnings.forEach(warning => {
              console.warn(chalk.yellow(`  • ${warning}`));
            });
          }

          console.log(chalk.gray('\n💡 Use --no-validate to skip validation'));
          process.exit(1);
        } else if (validation.success) {
          console.log(chalk.green('✅ Assignment validation passed'));

          if (validation.warnings && validation.warnings.length > 0) {
            console.warn(chalk.yellow('⚠️  Validation warnings:'));
            validation.warnings.forEach(warning => {
              console.warn(chalk.yellow(`  • ${warning}`));
            });
          }
        } else {
          console.warn(chalk.yellow('⚠️  Could not validate assignment, proceeding anyway'));
        }
      } else {
        console.warn(chalk.yellow('⚠️  Task routing system unavailable, skipping validation'));
      }
    }

    // Update task context with assignment
    const updates = {
      frontmatter: {
        assigned_agent: options.agent,
        assigned_at: new Date().toISOString(),
        status: 'in_progress'
      }
    };

    if (options.priority) {
      updates.frontmatter.priority = options.priority;
    }

    // Update task context
    const taskSuccess = await contextManager.updateContext('task', taskId, updates);

    // Update dynamic state (assignments.json)
    const paths = contextManager.getContextPaths();
    const assignmentsPath = path.join(paths.state, 'assignments.json');

    const fs = require('fs').promises;
    let assignments = {};

    try {
      if (await contextManager.fileExists(assignmentsPath)) {
        const assignmentsContent = await fs.readFile(assignmentsPath, 'utf-8');
        assignments = JSON.parse(assignmentsContent);
      }
    } catch (error) {
      // Start fresh if file is corrupted
    }

    // Update assignments
    assignments[specId] = assignments[specId] || {};
    assignments[specId][taskId] = {
      agent: options.agent,
      assigned_at: new Date().toISOString(),
      priority: options.priority || 'P2',
      status: 'in_progress'
    };

    // Ensure state directory exists
    await fs.mkdir(paths.state, { recursive: true });
    await fs.writeFile(assignmentsPath, JSON.stringify(assignments, null, 2), 'utf-8');

    if (taskSuccess) {
      // Fire trigger for task assignment
      await triggerSystem.fireTrigger('assign', {
        specId,
        taskId,
        agentType: options.agent,
        priority: options.priority || 'P2',
        source: 'cli_command'
      });

      console.log(chalk.green(`✅ Assigned ${taskId} to ${options.agent}`));
      console.log(chalk.gray(`   Spec: ${specId}`));
      console.log(chalk.gray(`   Priority: ${options.priority || 'P2'}`));
    } else {
      console.error(chalk.red('❌ Failed to update task context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Task assignment failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskComplete(specId, taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Update task context with completion
    const updates = {
      frontmatter: {
        status: 'completed',
        completed_at: new Date().toISOString()
      }
    };

    if (options.notes) {
      updates.frontmatter.completion_notes = options.notes;
    }

    if (options.handoff) {
      updates.frontmatter.handoff_to = options.handoff;
    }

    // Update task context
    const taskSuccess = await contextManager.updateContext('task', taskId, updates);

    // Update progress tracking
    const paths = contextManager.getContextPaths();
    const progressPath = path.join(paths.state, 'progress.json');

    const fs = require('fs').promises;
    let progress = {};

    try {
      if (await contextManager.fileExists(progressPath)) {
        const progressContent = await fs.readFile(progressPath, 'utf-8');
        progress = JSON.parse(progressContent);
      }
    } catch (error) {
      // Start fresh if file is corrupted
    }

    // Update progress
    progress[specId] = progress[specId] || {};
    progress[specId][taskId] = {
      status: 'completed',
      completed_at: new Date().toISOString(),
      completion_notes: options.notes || null
    };

    // Ensure state directory exists
    await fs.mkdir(paths.state, { recursive: true });
    await fs.writeFile(progressPath, JSON.stringify(progress, null, 2), 'utf-8');

    if (taskSuccess) {
      // Fire trigger for task completion
      await triggerSystem.fireTrigger('complete', {
        specId,
        taskId,
        completionNotes: options.notes,
        handoffTo: options.handoff,
        source: 'cli_command'
      });

      console.log(chalk.green(`✅ Marked ${taskId} as complete`));
      console.log(chalk.gray(`   Spec: ${specId}`));
      if (options.notes) {
        console.log(chalk.gray(`   Notes: ${options.notes}`));
      }
      if (options.handoff) {
        console.log(chalk.yellow(`   🔄 Handoff to: ${options.handoff}`));
      }
    } else {
      console.error(chalk.red('❌ Failed to update task context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Task completion failed:'), error.message);
    process.exit(1);
  }
}

async function handleResearchCapture(specId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    if (!options.finding) {
      console.error(chalk.red('❌ Must specify --finding <text>'));
      process.exit(1);
    }

    const contextType = options.task ? 'task' : 'spec';
    const contextId = options.task || specId;

    // Create research finding object
    const researchFinding = {
      finding: options.finding,
      timestamp: new Date().toISOString(),
      source: options.source || 'manual',
      context: contextType === 'task' ? `${specId}:${options.task}` : specId
    };

    // Update context with research finding
    const updates = {
      frontmatter: {
        research_findings: [researchFinding]
      }
    };

    const success = await contextManager.updateContext(contextType, contextId, updates);

    if (success) {
      // Fire trigger for research capture
      await triggerSystem.fireTrigger('research', {
        specId,
        taskId: options.task,
        finding: options.finding,
        source: options.source,
        contextType,
        contextId
      });

      console.log(chalk.green(`✅ Research finding captured for ${contextType} ${contextId}`));
      console.log(chalk.gray(`   Finding: ${options.finding.slice(0, 80)}${options.finding.length > 80 ? '...' : ''}`));
      if (options.source) {
        console.log(chalk.gray(`   Source: ${options.source}`));
      }
    } else {
      console.error(chalk.red('❌ Failed to capture research finding'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Research capture failed:'), error.message);
    process.exit(1);
  }
}

async function startASD(options) {
  try {
    // Prepare configuration
    const configOptions = {
      cwd: process.cwd(),
      configPath: options.config,
      appName: options.appName,
      appIcon: options.appIcon,
    };

    if (options.path) {
      configOptions.featuresPath = options.path;
    }

    if (options.noAutoRefresh) {
      configOptions.autoRefresh = false;
    }

    if (options.debug) {
      process.env.DEBUG_STARTUP = 'true';
      process.env.DEBUG_LAYOUT = 'true';
    }

    // Create and start ASD client
    const asd = new ASDClient(configOptions);
    await asd.init();

  } catch (error) {
    console.error(chalk.red('❌ Failed to start ASD:'), error.message);

    if (options.debug) {
      console.error(chalk.gray('Stack trace:'), error.stack);
    }

    process.exit(1);
  }
}

// Handler functions for task routing commands
async function handleNextTask(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const taskAPI = new TaskRecommendationAPI(configManager);

    // Initialize the API
    const initialized = await taskAPI.initialize();
    if (!initialized) {
      console.error(chalk.red('❌ Failed to initialize task routing system'));
      process.exit(1);
    }

    // Parse filter options
    const priority = options.priority ? options.priority.split(',') : undefined;
    const phase = options.phase ? options.phase.split(',') : undefined;
    const specStatus = options.specStatus ? options.specStatus.split(',') : undefined;
    const limit = parseInt(options.limit) || 5;

    // Use transparent API if requested
    if (options.transparent) {
      const result = await taskAPI.getTransparentRecommendation({
        agentType: options.agent,
        filters: { priority, phase, specStatus }
      });

      if (!result.success) {
        console.error(chalk.red('❌ Task recommendation failed:'), result.error);
        process.exit(1);
      }

      displayTransparentRecommendation(result);
      return;
    }

    // Get task recommendation
    const result = await taskAPI.getNextTask({
      agentType: options.agent,
      priority,
      phase,
      specStatus,
      includeReasoning: options.showReasoning,
      includeAlternatives: options.showAlternatives
    });

    if (!result.success) {
      console.error(chalk.red('❌ Task recommendation failed:'), result.error);
      process.exit(1);
    }

    displayTaskRecommendation(result, options);

  } catch (error) {
    console.error(chalk.red('❌ Next task command failed:'), error.message);
    process.exit(1);
  }
}

async function handleTasksList(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const taskAPI = new TaskRecommendationAPI(configManager);

    const initialized = await taskAPI.initialize();
    if (!initialized) {
      console.error(chalk.red('❌ Failed to initialize task routing system'));
      process.exit(1);
    }

    // Parse filter options
    const priority = options.priority ? options.priority.split(',') : undefined;
    const phase = options.phase ? options.phase.split(',') : undefined;
    const specStatus = options.specStatus ? options.specStatus.split(',') : undefined;
    const limit = parseInt(options.limit) || 10;

    const result = await taskAPI.getAvailableTasks({
      agentType: options.agent,
      priority,
      phase,
      specStatus,
      limit,
      includeBlocked: options.includeBlocked
    });

    if (!result.success) {
      console.error(chalk.red('❌ Failed to list tasks:'), result.error);
      process.exit(1);
    }

    displayTasksList(result);

  } catch (error) {
    console.error(chalk.red('❌ Tasks list command failed:'), error.message);
    process.exit(1);
  }
}

async function handleValidateAssignment(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const taskAPI = new TaskRecommendationAPI(configManager);

    const initialized = await taskAPI.initialize();
    if (!initialized) {
      console.error(chalk.red('❌ Failed to initialize task routing system'));
      process.exit(1);
    }

    const result = await taskAPI.validateAssignment({
      taskId: options.task,
      agentType: options.agent
    });

    if (!result.success) {
      console.error(chalk.red('❌ Assignment validation failed:'), result.error);
      process.exit(1);
    }

    displayValidationResult(result, options);

  } catch (error) {
    console.error(chalk.red('❌ Validate assignment command failed:'), error.message);
    process.exit(1);
  }
}

function displayTaskRecommendation(result, options) {
  console.log(chalk.cyan('🎯 Task Recommendation'));
  console.log(chalk.gray('='.repeat(50)));

  if (!result.task) {
    console.log(chalk.yellow('⚠️  No task found matching criteria'));

    if (result.reasoning) {
      console.log(chalk.gray('\nReason:'), result.reasoning.summary);

      if (result.reasoning.suggestion) {
        console.log(chalk.blue('💡 Suggestion:'), result.reasoning.suggestion);
      }

      if (result.reasoning.availableAlternatives > 0) {
        console.log(chalk.gray(`Available alternatives: ${result.reasoning.availableAlternatives}`));
      }
    }

    console.log(chalk.gray('\nFilters applied:'));
    console.log(chalk.gray(`  Agent: ${result.metadata.filters.agentType}`));
    if (result.metadata.filters.priority) {
      console.log(chalk.gray(`  Priority: ${Array.isArray(result.metadata.filters.priority) ? result.metadata.filters.priority.join(', ') : result.metadata.filters.priority}`));
    }
    if (result.metadata.filters.phase) {
      console.log(chalk.gray(`  Phase: ${Array.isArray(result.metadata.filters.phase) ? result.metadata.filters.phase.join(', ') : result.metadata.filters.phase}`));
    }

    return;
  }

  // Main recommendation
  console.log(chalk.green('✅ Recommended Task:'), chalk.yellow(result.task.id));
  console.log(chalk.white('Title:'), result.task.title);
  console.log(chalk.white('Spec:'), result.task.specId || 'N/A');
  console.log(chalk.white('Priority:'), getPriorityDisplay(result.task.specPriority || result.task.priority));
  console.log(chalk.white('Phase:'), result.task.phase || 'N/A');
  console.log(chalk.white('Estimated Hours:'), result.task.estimated_hours || 'N/A');

  if (result.task.agent_type) {
    console.log(chalk.white('Required Agent:'), result.task.agent_type);
  }

  if (result.task.context_requirements && result.task.context_requirements.length > 0) {
    console.log(chalk.white('Context Requirements:'), result.task.context_requirements.join(', '));
  }

  // Show score if available
  if (result.task.score !== undefined) {
    console.log(chalk.white('Recommendation Score:'), chalk.cyan(result.task.score));
  }

  // Show reasoning if requested
  if (options.showReasoning && result.reasoning) {
    console.log(chalk.blue('\n📋 Recommendation Reasoning:'));
    console.log(chalk.gray(result.reasoning.summary));

    if (result.reasoning.factors && result.reasoning.factors.length > 0) {
      console.log(chalk.blue('\nScoring Factors:'));
      result.reasoning.factors.forEach(factor => {
        const impactColor = factor.impact === 'High' ? 'green' :
                           factor.impact === 'Positive' ? 'cyan' :
                           factor.impact === 'Negative' ? 'red' : 'gray';
        console.log(chalk.gray(`  • ${factor.factor}: ${factor.value}`), chalk[impactColor](`(${factor.impact})`));
      });
    }

    console.log(chalk.white('Confidence:'), getConfidenceDisplay(result.reasoning.confidence));
    console.log(chalk.white('Recommendation:'), chalk.cyan(result.reasoning.recommendation));
  }

  // Show constraint validation if available
  if (result.task.constraintValidation) {
    const validation = result.task.constraintValidation;
    console.log(chalk.blue('\n🔍 Constraint Validation:'));
    console.log(chalk.white('Valid:'), validation.isValid ? chalk.green('✓') : chalk.red('✗'));

    if (validation.violations && validation.violations.length > 0) {
      console.log(chalk.red('Violations:'));
      validation.violations.forEach(violation => {
        console.log(chalk.red(`  • ${violation}`));
      });
    }

    if (validation.warnings && validation.warnings.length > 0) {
      console.log(chalk.yellow('Warnings:'));
      validation.warnings.forEach(warning => {
        console.log(chalk.yellow(`  • ${warning}`));
      });
    }
  }

  // Show alternatives if requested
  if (options.showAlternatives && result.alternatives && result.alternatives.length > 0) {
    console.log(chalk.blue('\n🔄 Alternative Tasks:'));
    result.alternatives.slice(0, 3).forEach((alt, index) => {
      console.log(chalk.gray(`${index + 1}. ${alt.id} - ${alt.title}`));
      console.log(chalk.gray(`   Score: ${alt.score}, Priority: ${getPriorityDisplay(alt.specPriority || alt.priority)}`));
    });
  }

  // Show performance and metadata
  console.log(chalk.gray(`\nPerformance: ${result.metadata.performance.total}ms`));
  console.log(chalk.gray(`Available tasks: ${result.metadata.totalAvailable}, Agent matches: ${result.metadata.agentMatches}`));
}

function displayTransparentRecommendation(result) {
  console.log(chalk.cyan('🔍 Transparent Task Recommendation'));
  console.log(chalk.gray('='.repeat(50)));

  if (!result.recommendation.task) {
    console.log(chalk.yellow('⚠️  No task found matching criteria'));
    if (result.recommendation.transparency.reasoning) {
      console.log(chalk.gray('\nReason:'), result.recommendation.transparency.reasoning.summary);
    }
    return;
  }

  const task = result.recommendation.task;
  const transparency = result.recommendation.transparency;

  // Basic task info
  console.log(chalk.green('✅ Recommended Task:'), chalk.yellow(task.id));
  console.log(chalk.white('Title:'), task.title);
  console.log(chalk.white('Score:'), chalk.cyan(task.score));

  // Scoring breakdown
  if (transparency.scoring) {
    console.log(chalk.blue('\n📊 Scoring Breakdown:'));
    const breakdown = transparency.scoring.breakdown;
    Object.entries(breakdown).forEach(([factor, data]) => {
      if (data && typeof data === 'object' && data.multiplier !== undefined) {
        console.log(chalk.gray(`  ${factor}:`), `${data.multiplier}x`, chalk.gray(`(${data.details})`));
      }
    });
  }

  // Constraint details
  if (transparency.constraints) {
    console.log(chalk.blue('\n🔒 Constraint Analysis:'));
    console.log(chalk.white('Valid:'), transparency.constraints.isValid ? chalk.green('✓') : chalk.red('✗'));
    console.log(chalk.white('Score Multiplier:'), chalk.cyan(transparency.constraints.score));

    Object.entries(transparency.constraints.details).forEach(([constraint, details]) => {
      console.log(chalk.gray(`  ${constraint}:`), details.isValid ? chalk.green('✓') : chalk.red('✗'));
      if (details.details && typeof details.details === 'string') {
        console.log(chalk.gray(`    ${details.details}`));
      }
    });
  }

  // Agent matching analysis
  if (transparency.agentMatch) {
    console.log(chalk.blue('\n👤 Agent Match Analysis:'));
    console.log(chalk.white('Agent Type Match:'), transparency.agentMatch.agentTypeMatch ? chalk.green('✓') : chalk.gray('–'));
    console.log(chalk.white('Match Quality:'), getMatchQualityDisplay(transparency.agentMatch.matchQuality));

    if (transparency.agentMatch.requiredContexts && transparency.agentMatch.requiredContexts.length > 0) {
      console.log(chalk.white('Required Contexts:'), transparency.agentMatch.requiredContexts.join(', '));
    }

    if (transparency.agentMatch.matchingContexts && transparency.agentMatch.matchingContexts.length > 0) {
      console.log(chalk.white('Matching Contexts:'), chalk.green(transparency.agentMatch.matchingContexts.join(', ')));
    }
  }

  // Algorithmic details
  if (transparency.reasoning && transparency.reasoning.algorithmic) {
    console.log(chalk.blue('\n⚙️  Algorithm Details:'));
    const algo = transparency.reasoning.algorithmic;
    console.log(chalk.gray('Scoring Method:'), algo.scoringMethod);
    console.log(chalk.gray('Constraint Engine:'), algo.constraintEngine);
    console.log(chalk.gray('Agent Matching:'), algo.agentMatching);
  }

  console.log(chalk.gray(`\nPerformance: ${result.metadata.performance.total}ms`));
}

function displayTasksList(result) {
  console.log(chalk.cyan('📋 Available Tasks'));
  console.log(chalk.gray('='.repeat(50)));

  if (result.tasks.length === 0) {
    console.log(chalk.yellow('⚠️  No tasks found matching criteria'));
    return;
  }

  console.log(chalk.white(`Found ${result.tasks.length} tasks:`));
  console.log();

  result.tasks.forEach((task, index) => {
    const status = task.blocked ? chalk.red('[BLOCKED]') :
                   task.status === 'complete' ? chalk.green('[COMPLETE]') :
                   task.status === 'in_progress' ? chalk.blue('[IN PROGRESS]') :
                   chalk.green('[READY]');

    console.log(chalk.white(`${index + 1}. ${task.id}`), status);
    console.log(chalk.gray(`   Title: ${task.title}`));
    console.log(chalk.gray(`   Spec: ${task.specId || 'N/A'}, Priority: ${getPriorityDisplay(task.specPriority || task.priority)}`));

    if (task.agent_type) {
      console.log(chalk.gray(`   Required Agent: ${task.agent_type}`));
    }

    if (task.estimated_hours) {
      console.log(chalk.gray(`   Estimated Hours: ${task.estimated_hours}`));
    }

    if (task.blocked && task.blockedReason) {
      console.log(chalk.red(`   Blocked: ${task.blockedReason}`));
    }

    console.log();
  });

  console.log(chalk.gray(`Performance: ${result.metadata.performance.total}ms`));
  console.log(chalk.gray(`Total available: ${result.metadata.total}, Filters: ${JSON.stringify(result.metadata.filters)}`));
}

function displayValidationResult(result, _options) {
  console.log(chalk.cyan('🔍 Assignment Validation'));
  console.log(chalk.gray('='.repeat(50)));

  console.log(chalk.white('Task:'), result.taskId || _options.task);
  console.log(chalk.white('Agent:'), _options.agent);
  console.log(chalk.white('Valid:'), result.valid ? chalk.green('✓ Valid') : chalk.red('✗ Invalid'));

  if (result.issues && result.issues.length > 0) {
    console.log(chalk.red('\nIssues:'));
    result.issues.forEach(issue => {
      console.log(chalk.red(`  • ${issue}`));
    });
  }

  if (result.warnings && result.warnings.length > 0) {
    console.log(chalk.yellow('\nWarnings:'));
    result.warnings.forEach(warning => {
      console.log(chalk.yellow(`  • ${warning}`));
    });
  }

  if (_options.showDetails && result.details) {
    console.log(chalk.blue('\n📊 Validation Details:'));
    console.log(chalk.gray('Task Available:'), result.details.taskAvailable ? chalk.green('✓') : chalk.red('✗'));
    console.log(chalk.gray('Agent Capable:'), result.details.agentCapable ? chalk.green('✓') : chalk.red('✗'));
    console.log(chalk.gray('Constraints Passed:'), result.details.constraintsPassed ? chalk.green('✓') : chalk.red('✗'));
  }

  if (result.constraintDetails) {
    console.log(chalk.blue('\n🔒 Constraint Details:'));
    console.log(chalk.gray('Constraint Score:'), chalk.cyan(result.constraintDetails.score));

    if (result.constraintDetails.details) {
      Object.entries(result.constraintDetails.details).forEach(([constraint, details]) => {
        console.log(chalk.gray(`  ${constraint}:`), details.isValid ? chalk.green('✓') : chalk.red('✗'));
      });
    }
  }

  console.log(chalk.gray(`\nValidation time: ${result.performance.total}ms`));
}

// Utility display functions
function getPriorityDisplay(priority) {
  switch (priority) {
    case 'P0': return chalk.red('P0 (Critical)');
    case 'P1': return chalk.yellow('P1 (High)');
    case 'P2': return chalk.blue('P2 (Medium)');
    case 'P3': return chalk.gray('P3 (Low)');
    default: return chalk.gray(priority || 'N/A');
  }
}

function getConfidenceDisplay(confidence) {
  const percent = Math.round(confidence * 100);
  const color = confidence >= 0.8 ? 'green' : confidence >= 0.6 ? 'yellow' : 'red';
  return chalk[color](`${percent}%`);
}

function getMatchQualityDisplay(quality) {
  switch (quality) {
    case 'Excellent match': return chalk.green(quality);
    case 'Good match': return chalk.cyan(quality);
    case 'Partial match': return chalk.yellow(quality);
    case 'Poor match': return chalk.red(quality);
    default: return chalk.gray(quality);
  }
}

// Workflow state management handler functions
async function handleWorkflowStatus(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();

    const assignments = await stateManager.getCurrentAssignments();
    
    console.log(chalk.cyan('📊 Current Workflow Status'));
    console.log(chalk.gray('='.repeat(50)));
    
    if (assignments.current_assignments.length === 0) {
      console.log(chalk.yellow('⚠️  No active assignments'));
      return;
    }

    console.log(chalk.white(`Active Assignments: ${assignments.total_active_assignments}`));
    console.log();

    for (const assignment of assignments.current_assignments) {
      if (!options.agent || assignment.assigned_agent === options.agent) {
        console.log(chalk.white(`• ${assignment.spec_id}:${assignment.task_id}`));
        console.log(chalk.gray(`  Agent: ${assignment.assigned_agent}`));
        console.log(chalk.gray(`  Started: ${new Date(assignment.started_at).toLocaleString()}`));
        console.log(chalk.gray(`  Priority: ${getPriorityDisplay(assignment.priority)}`));
        
        if (options.verbose) {
          console.log(chalk.gray(`  Estimated Hours: ${assignment.estimated_hours || 'N/A'}`));
          const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 100) / 100;
          console.log(chalk.gray(`  Duration: ${duration}h`));
        }
        console.log();
      }
    }

    // Show agent workloads
    if (Object.keys(assignments.agent_workloads).length > 0) {
      console.log(chalk.blue('👥 Agent Workloads:'));
      for (const [agent, workload] of Object.entries(assignments.agent_workloads)) {
        if (!options.agent || agent === options.agent) {
          console.log(chalk.gray(`  ${agent}: ${workload.current_tasks} tasks, ${workload.total_hours}h total`));
        }
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow status failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowProgress(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();

    if (options.spec) {
      const specProgress = await stateManager.getSpecProgress(options.spec);
      
      console.log(chalk.cyan(`📈 Progress for ${options.spec}`));
      console.log(chalk.gray('='.repeat(50)));
      
      console.log(chalk.white(`Total Tasks: ${specProgress.total_tasks || 0}`));
      console.log(chalk.white(`Completed Tasks: ${specProgress.completed_tasks || 0}`));
      console.log(chalk.white(`Completion: ${Math.round(specProgress.completion_percentage || 0)}%`));
      console.log(chalk.white(`Active Assignments: ${specProgress.active_assignments?.length || 0}`));
      
      if (options.detailed && specProgress.active_assignments && specProgress.active_assignments.length > 0) {
        console.log(chalk.blue('\nActive Assignments:'));
        for (const assignment of specProgress.active_assignments) {
          console.log(chalk.gray(`  • ${assignment.task_id} → ${assignment.assigned_agent}`));
        }
      }
    } else {
      const progress = await stateManager.getProjectProgress();
      
      console.log(chalk.cyan('📈 Project Progress Overview'));
      console.log(chalk.gray('='.repeat(50)));
      
      console.log(chalk.white(`Total Specs: ${progress.overall.total_specs}`));
      console.log(chalk.white(`Active Specs: ${progress.overall.active_specs}`));
      console.log(chalk.white(`Completed Specs: ${progress.overall.completed_specs}`));
      console.log(chalk.white(`Total Tasks: ${progress.overall.total_tasks}`));
      console.log(chalk.white(`Completed Tasks: ${progress.overall.completed_tasks}`));
      console.log(chalk.white(`Overall Completion: ${Math.round(progress.overall.completion_percentage)}%`));
      console.log(chalk.white(`Active Assignments: ${progress.active_assignments || 0}`));
      
      if (options.detailed && progress.by_phase && Object.keys(progress.by_phase).length > 0) {
        console.log(chalk.blue('\nProgress by Phase:'));
        for (const [phase, phaseData] of Object.entries(progress.by_phase)) {
          if (!options.phase || phase === options.phase) {
            console.log(chalk.gray(`  ${phase}: ${phaseData.completed_specs}/${phaseData.specs} specs (${Math.round(phaseData.completion_percentage)}%)`));
          }
        }
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow progress failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowHandoffs(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();

    const handoffStatus = await stateManager.getHandoffStatus();
    
    console.log(chalk.cyan('🔄 Workflow Handoffs'));
    console.log(chalk.gray('='.repeat(50)));
    
    if (!options.history) {
      console.log(chalk.white(`Ready Handoffs: ${handoffStatus.ready_handoffs.length}`));
      
      if (handoffStatus.ready_handoffs.length > 0) {
        console.log(chalk.blue('\nReady for Handoff:'));
        for (const handoff of handoffStatus.ready_handoffs) {
          console.log(chalk.white(`• ${handoff.spec_id}: ${handoff.from_task} → ${handoff.to_task}`));
          console.log(chalk.gray(`  Next Agent: ${handoff.next_agent}`));
          console.log(chalk.gray(`  Ready Since: ${new Date(handoff.ready_at).toLocaleString()}`));
          console.log(chalk.gray(`  Reason: ${handoff.handoff_reason || handoff.reason}`));
          console.log();
        }
      } else {
        console.log(chalk.gray('\nNo handoffs ready at this time'));
      }
    }
    
    if (options.history && handoffStatus.handoff_history.length > 0) {
      console.log(chalk.blue('\nRecent Handoff History:'));
      for (const historyItem of handoffStatus.handoff_history) {
        console.log(chalk.gray(`• ${historyItem.spec_id}: ${historyItem.from_task} → ${historyItem.to_task}`));
        console.log(chalk.gray(`  Completed: ${new Date(historyItem.completed_at).toLocaleString()}`));
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow handoffs failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowValidate(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();

    console.log(chalk.cyan('🔍 Validating Workflow State'));
    console.log(chalk.gray('='.repeat(50)));
    
    const validation = await stateManager.validateState();
    
    console.log(chalk.white('Valid:'), validation.isValid ? chalk.green('✓') : chalk.red('✗'));
    console.log(chalk.white('Validation Time:'), chalk.cyan(`${validation.performance.total}ms`));
    
    if (validation.statistics) {
      console.log(chalk.blue('\nStatistics:'));
      console.log(chalk.gray(`  Total Assignments: ${validation.statistics.total_assignments}`));
      console.log(chalk.gray(`  Total Specs: ${validation.statistics.total_specs}`));
      console.log(chalk.gray(`  Ready Handoffs: ${validation.statistics.ready_handoffs}`));
    }
    
    if (validation.errors && validation.errors.length > 0) {
      console.log(chalk.red('\nErrors:'));
      validation.errors.forEach(error => {
        console.log(chalk.red(`  • ${error}`));
      });
    }
    
    if (validation.warnings && validation.warnings.length > 0) {
      console.log(chalk.yellow('\nWarnings:'));
      validation.warnings.forEach(warning => {
        console.log(chalk.yellow(`  • ${warning}`));
      });
    }
    
    if (validation.isValid) {
      console.log(chalk.green('\n✅ Workflow state validation passed!'));
    } else {
      console.log(chalk.red('\n❌ Workflow state validation failed'));
      if (options.fix) {
        console.log(chalk.yellow('🔧 Automatic fixing not yet implemented'));
      }
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow validation failed:'), error.message);
    process.exit(1);
  }
}

// Handle CLI parsing
program.parse();

// If no command was specified and no arguments, show help
if (!process.argv.slice(2).length) {
  const options = program.opts();
  startASD(options);
}