#!/usr/bin/env node

const { Command } = require('commander');
const path = require('path');
const chalk = require('chalk');
const ASDClient = require('../lib/index');
const ConfigManager = require('../lib/config-manager');
const ContextInjector = require('../lib/context-injector');
const ContextManager = require('../lib/context-manager');
const ContextValidator = require('../lib/context-validator');
const ContextTriggerSystem = require('../lib/context-triggers');
const { TaskRecommendationAPI } = require('../lib/task-router');
const WorkflowStateManager = require('../lib/workflow-state-manager');
const UIComponents = require('../lib/ui-components');

const program = new Command();

program
  .name('asd')
  .description('Agentic Spec Development (ASD) - AI-first terminal tool for specification development and project management')
  .version('0.1.0-alpha')
  .addHelpText('before', chalk.yellow('⚠️  Pre-Production Software: Features may change before stable release\n'))
  .option('-c, --config <path>', 'Path to configuration file')
  .option('-p, --path <path>', 'Path to specs directory (overrides config)')
  .option('--no-auto-refresh', 'Disable automatic file watching and refresh')
  .option('--app-name <name>', 'Custom application name')
  .option('--app-icon <icon>', 'Custom application icon')
  .option('--debug', 'Enable debug output');

// Context management commands
const contextCommand = program
  .command('context')
  .description('Manage context files and injection system');

contextCommand
  .command('add')
  .description('Add content to context files')
  .option('--project', 'Add to project-level context')
  .option('--spec <spec-id>', 'Add to spec context')
  .option('--task <task-id>', 'Add to task context')
  .option('--constraint <text>', 'Add constraint')
  .option('--research <text>', 'Add research finding')
  .option('--decision <text>', 'Add implementation decision')
  .option('--content <text>', 'Add markdown content')
  .action(async (options) => {
    await handleContextAdd(options);
  });

contextCommand
  .command('update')
  .description('Update existing context files')
  .option('--spec <spec-id>', 'Update spec context')
  .option('--task <task-id>', 'Update task context')
  .option('--status <status>', 'Update status')
  .option('--progress <progress>', 'Update progress information')
  .option('--assign <agent-type>', 'Assign agent to task')
  .action(async (options) => {
    await handleContextUpdate(options);
  });

contextCommand
  .command('show')
  .description('Display context information')
  .option('--spec <spec-id>', 'Show spec context')
  .option('--task <task-id>', 'Show task context')
  .option('--agent <agent-type>', 'Show agent-specific context')
  .option('--inject', 'Show full injected context for agent')
  .option('--layers', 'Show all context layers')
  .action(async (options) => {
    await handleContextShow(options);
  });

contextCommand
  .command('validate')
  .description('Validate context files and system consistency')
  .option('--fix-issues', 'Attempt to fix validation issues')
  .option('--files <pattern>', 'Validate specific files (glob pattern)')
  .option('--verbose', 'Show detailed validation results')
  .action(async (options) => {
    await handleContextValidate(options);
  });

contextCommand
  .command('export')
  .description('Export context data for backup or sharing')
  .option('--output <path>', 'Output file path', './context-export.json')
  .option('--spec <spec-id>', 'Export specific spec context')
  .option('--include-state', 'Include dynamic state data')
  .action(async (options) => {
    await handleContextExport(options);
  });

contextCommand
  .command('import')
  .description('Import context data from backup')
  .argument('<file>', 'Context export file to import')
  .option('--merge', 'Merge with existing context (default: replace)')
  .option('--dry-run', 'Show what would be imported without making changes')
  .action(async (file, options) => {
    await handleContextImport(file, options);
  });

// Agent customization commands
const agentCommand = program
  .command('agent')
  .description('Manage agent definitions and customization');

agentCommand
  .command('customize')
  .description('Customize agent workflows and requirements')
  .argument('<agent-type>', 'Agent type to customize')
  .option('--add-step <step>', 'Add workflow step')
  .option('--add-requirement <req>', 'Add context requirement')
  .option('--add-capability <cap>', 'Add agent capability')
  .option('--remove-step <step>', 'Remove workflow step')
  .option('--edit', 'Open agent definition in editor')
  .action(async (agentType, options) => {
    await handleAgentCustomize(agentType, options);
  });

agentCommand
  .command('list')
  .description('List available agents and their capabilities')
  .option('--details', 'Show detailed agent information')
  .action(async (options) => {
    await handleAgentList(options);
  });

// Process management commands
const processCommand = program
  .command('process')
  .description('Manage process templates and workflows');

processCommand
  .command('update')
  .description('Update process templates')
  .argument('<template-name>', 'Process template to update')
  .option('--add-requirement <req>', 'Add validation requirement')
  .option('--add-step <step>', 'Add process step')
  .option('--edit', 'Open template in editor')
  .action(async (templateName, options) => {
    await handleProcessUpdate(templateName, options);
  });

processCommand
  .command('list')
  .description('List available process templates')
  .action(async () => {
    await handleProcessList();
  });

// Task routing and recommendation commands
program
  .command('next')
  .description('Get next recommended task for an agent')
  .requiredOption('--agent <agent-type>', 'Agent type (required)')
  .option('--priority <priorities>', 'Filter by priority (P0,P1,P2,P3)', 'P0,P1,P2,P3')
  .option('--phase <phases>', 'Filter by phase (PHASE-1A,PHASE-1B)', 'PHASE-1A,PHASE-1B')
  .option('--spec-status <status>', 'Filter by spec status (active,ready,backlog)', 'active,ready')
  .option('--show-alternatives', 'Show alternative task recommendations', false)
  .option('--show-reasoning', 'Show detailed recommendation reasoning', false)
  .option('--transparent', 'Show full scoring and constraint details', false)
  .option('--limit <number>', 'Maximum number of tasks to return', '5')
  .action(async (options) => {
    await handleNextTask(options);
  });

program
  .command('tasks')
  .description('List available tasks with filtering')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--priority <priorities>', 'Filter by priority (P0,P1,P2,P3)')
  .option('--phase <phases>', 'Filter by phase')
  .option('--spec-status <status>', 'Filter by spec status')
  .option('--status <status>', 'Filter by task status (ready,blocked,complete)')
  .option('--include-blocked', 'Include blocked tasks', false)
  .option('--limit <number>', 'Maximum number of tasks to return', '10')
  .action(async (options) => {
    await handleTasksList(options);
  });

program
  .command('validate-assignment')
  .description('Validate if a task can be assigned to an agent')
  .requiredOption('--task <task-id>', 'Task ID to validate')
  .requiredOption('--agent <agent-type>', 'Agent type for assignment')
  .option('--show-details', 'Show detailed validation information', false)
  .action(async (options) => {
    await handleValidateAssignment(options);
  });

// Task lifecycle commands with context updates
program
  .command('assign')
  .description('Assign task to agent with context update and routing validation')
  .argument('<spec-id>', 'Specification ID')
  .argument('<task-id>', 'Task ID')
  .option('--agent <agent-type>', 'Agent type to assign')
  .option('--priority <priority>', 'Task priority (P0, P1, P2, P3)')
  .option('--validate', 'Validate assignment before applying', true)
  .action(async (specId, taskId, options) => {
    await handleTaskAssign(specId, taskId, options);
  });

program
  .command('complete')
  .description('Mark task as complete and update context')
  .argument('<spec-id>', 'Specification ID')
  .argument('<task-id>', 'Task ID')
  .option('--notes <notes>', 'Completion notes')
  .option('--handoff <next-task>', 'Next task to hand off to')
  .action(async (specId, taskId, options) => {
    await handleTaskComplete(specId, taskId, options);
  });

program
  .command('research')
  .description('Capture research findings and update context')
  .argument('<spec-id>', 'Specification ID')
  .option('--task <task-id>', 'Specific task ID')
  .option('--finding <text>', 'Research finding to record')
  .option('--source <source>', 'Source of research')
  .action(async (specId, options) => {
    await handleResearchCapture(specId, options);
  });

// Workflow state management commands
const workflowCommand = program
  .command('workflow')
  .description('Manage workflow state and progress tracking');

workflowCommand
  .command('status')
  .description('Show current workflow status and assignments with rich visualizations')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--verbose', 'Show detailed status information')
  .option('--visual', 'Show rich status visualizations')
  .option('--workload', 'Display agent workload summary')
  .option('--timeline', 'Show task timeline view')
  .action(async (options) => {
    await handleWorkflowStatus(options);
  });

workflowCommand
  .command('progress')
  .description('Show project progress breakdown with visualizations')
  .option('--spec <spec-id>', 'Show progress for specific spec')
  .option('--phase <phase>', 'Filter by phase')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--detailed', 'Show detailed progress breakdown')
  .option('--visual', 'Show rich progress visualizations')
  .option('--bars', 'Display progress bars')
  .option('--sort <sort>', 'Sort by: completion, priority, phase, recent', 'completion')
  .action(async (options) => {
    await handleWorkflowProgress(options);
  });

workflowCommand
  .command('handoffs')
  .description('Show ready handoffs and handoff history with visualizations')
  .option('--ready-only', 'Show only ready handoffs')
  .option('--history', 'Show handoff history')
  .option('--visual', 'Show rich handoff visualizations')
  .option('--timeline', 'Show handoff timeline')
  .action(async (options) => {
    await handleWorkflowHandoffs(options);
  });

workflowCommand
  .command('validate')
  .description('Validate workflow state consistency')
  .option('--fix', 'Attempt to fix consistency issues')
  .action(async (options) => {
    await handleWorkflowValidate(options);
  });

workflowCommand
  .command('dashboard')
  .description('Show comprehensive progress dashboard')
  .option('--compact', 'Show compact dashboard view')
  .option('--velocity', 'Include velocity metrics')
  .option('--agents', 'Show agent performance breakdown')
  .action(async (options) => {
    await handleWorkflowDashboard(options);
  });

workflowCommand
  .command('metrics')
  .description('Show detailed workflow metrics and analytics')
  .option('--period <period>', 'Time period: day, week, month', 'week')
  .option('--export <format>', 'Export format: json, csv')
  .option('--velocity', 'Show velocity trends')
  .action(async (options) => {
    await handleWorkflowMetrics(options);
  });

workflowCommand
  .command('assignments')
  .description('Show current assignments with rich details')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--priority <priority>', 'Filter by priority (P0,P1,P2,P3)')
  .option('--status <status>', 'Filter by status (in_progress,completed)')
  .option('--sort <sort>', 'Sort by: priority, started, agent, spec', 'priority')
  .option('--timeline', 'Show assignment timeline')
  .action(async (options) => {
    await handleWorkflowAssignments(options);
  });

program
  .command('init')
  .description('Initialize ASD in the current directory')
  .option('-t, --type <type>', 'Project type (spec, feature, mixed)', 'mixed')
  .action(async (_options) => {
    console.log(chalk.cyan('🤖 Initializing Agentic Spec Development...'));

    const configManager = new ConfigManager(process.cwd());
    const configPath = path.join(process.cwd(), 'asd.config.js');

    try {
      configManager.createExampleConfig(configPath);
      console.log(chalk.green(`✅ Created configuration file: ${configPath}`));

      // Create default directory structure
      const fs = require('fs').promises;
      const specsPath = path.join(process.cwd(), 'docs/specs');

      await fs.mkdir(path.join(specsPath, 'active'), { recursive: true });
      await fs.mkdir(path.join(specsPath, 'backlog'), { recursive: true });
      await fs.mkdir(path.join(specsPath, 'done'), { recursive: true });
      await fs.mkdir(path.join(specsPath, 'template'), { recursive: true });

      console.log(chalk.green('✅ Created directory structure:'));
      console.log(chalk.gray('   docs/specs/active/'));
      console.log(chalk.gray('   docs/specs/backlog/'));
      console.log(chalk.gray('   docs/specs/done/'));
      console.log(chalk.gray('   docs/specs/template/'));

      console.log(chalk.cyan('\n🚀 ASD initialization complete!'));
      console.log(chalk.white('Run "asd" to start the terminal interface.'));

    } catch (error) {
      console.error(chalk.red('❌ Initialization failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('config')
  .description('Show current configuration')
  .action(() => {
    const configManager = new ConfigManager(process.cwd());
    const configInfo = configManager.getConfigInfo();

    console.log(chalk.cyan('🤖 ASD Configuration'));
    console.log(chalk.gray('='.repeat(50)));

    if (configInfo.configPath) {
      console.log(chalk.white('Config file:'), chalk.yellow(configInfo.configPath));
    } else {
      console.log(chalk.white('Config file:'), chalk.gray('Using defaults (no config file found)'));
    }

    console.log(chalk.white('Project root:'), chalk.yellow(configInfo.projectRoot));
    console.log(chalk.white('Specs path:'), chalk.yellow(configInfo.config.dataPath));
    console.log(chalk.white('Auto refresh:'), configInfo.config.autoRefresh ? chalk.green('enabled') : chalk.red('disabled'));
    console.log(chalk.white('Supported types:'), chalk.cyan(configInfo.config.supportedTypes.join(', ')));
    console.log(chalk.white('Status folders:'), chalk.cyan(configInfo.config.statusFolders.join(', ')));
  });

program
  .command('doctor')
  .description('Check ASD setup and configuration')
  .action(async () => {
    console.log(chalk.cyan('🔍 ASD Health Check'));
    console.log(chalk.gray('='.repeat(50)));

    const configManager = new ConfigManager(process.cwd());
    const config = configManager.loadConfig();
    const fs = require('fs').promises;

    let allGood = true;

    // Check if specs directory exists
    try {
      await fs.access(config.dataPath);
      console.log(chalk.green('✅ Specs directory exists:'), chalk.yellow(config.dataPath));
    } catch (error) {
      console.log(chalk.red('❌ Specs directory missing:'), chalk.yellow(config.dataPath));
      allGood = false;
    }

    // Check if status folders exist
    for (const folder of config.statusFolders) {
      const folderPath = path.join(config.dataPath, folder);
      try {
        await fs.access(folderPath);
        console.log(chalk.green('✅ Status folder exists:'), chalk.gray(folder));
      } catch (error) {
        console.log(chalk.red('❌ Status folder missing:'), chalk.gray(folder));
        allGood = false;
      }
    }

    // Check for spec files
    let totalSpecs = 0;
    for (const folder of config.statusFolders) {
      const folderPath = path.join(config.dataPath, folder);
      try {
        const files = await fs.readdir(folderPath);
        const mdFiles = files.filter(file => file.endsWith('.md'));
        totalSpecs += mdFiles.length;
      } catch (error) {
        // Folder doesn't exist, already reported above
      }
    }

    if (totalSpecs > 0) {
      console.log(chalk.green(`✅ Found ${totalSpecs} specification files`));
    } else {
      console.log(chalk.yellow('⚠️  No specification files found'));
    }

    // Check dependencies
    try {
      require('terminal-kit');
      console.log(chalk.green('✅ terminal-kit dependency available'));
    } catch (error) {
      console.log(chalk.red('❌ terminal-kit dependency missing'));
      allGood = false;
    }

    console.log(chalk.gray('='.repeat(50)));
    if (allGood) {
      console.log(chalk.green('🎉 All checks passed! ASD is ready to use.'));
    } else {
      console.log(chalk.red('❌ Some issues found. Run "asd init" to set up missing directories.'));
      process.exit(1);
    }
  });

// Default command - start the interactive terminal
program
  .command('start')
  .description('Start the interactive ASD terminal interface (default)')
  .action(async () => {
    const options = program.opts();
    await startASD(options);
  });

// Handle when no command is specified (default to start)
program.action(async () => {
  const options = program.opts();
  await startASD(options);
});

// Handler functions for context commands
async function handleContextAdd(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Determine context type and ID
    let contextType, contextId;
    if (options.project) {
      contextType = 'project';
      contextId = null;
    } else if (options.spec) {
      contextType = 'spec';
      contextId = options.spec;
    } else if (options.task) {
      contextType = 'task';
      contextId = options.task;
    } else {
      console.error(chalk.red('❌ Must specify --project, --spec <id>, or --task <id>'));
      process.exit(1);
    }

    // Build updates object
    const updates = { frontmatter: {} };

    if (options.constraint) {
      updates.frontmatter.constraints = updates.frontmatter.constraints || [];
      updates.frontmatter.constraints.push(options.constraint);
    }

    if (options.research) {
      updates.frontmatter.research_findings = updates.frontmatter.research_findings || [];
      updates.frontmatter.research_findings.push({
        finding: options.research,
        timestamp: new Date().toISOString(),
        source: 'manual'
      });
    }

    if (options.decision) {
      updates.frontmatter.implementation_decisions = updates.frontmatter.implementation_decisions || [];
      updates.frontmatter.implementation_decisions.push({
        decision: options.decision,
        timestamp: new Date().toISOString(),
        rationale: 'user input'
      });
    }

    if (options.content) {
      updates.content = options.content;
    }

    if (Object.keys(updates.frontmatter).length === 0 && !updates.content) {
      console.error(chalk.red('❌ Must provide --constraint, --research, --decision, or --content'));
      process.exit(1);
    }

    // Update context and trigger system
    const success = await contextManager.updateContext(contextType, contextId, updates);

    if (success) {
      // Fire trigger for context addition
      await triggerSystem.fireTrigger('context_add', {
        contextType,
        contextId,
        updates,
        source: 'cli_command'
      });

      console.log(chalk.green(`✅ Updated ${contextType} context${contextId ? ` for ${contextId}` : ''}`));
    } else {
      console.error(chalk.red('❌ Failed to update context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Context add failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextUpdate(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);

    // Determine what to update
    if (!options.spec && !options.task) {
      console.error(chalk.red('❌ Must specify --spec <id> or --task <id>'));
      process.exit(1);
    }

    const contextType = options.spec ? 'spec' : 'task';
    const contextId = options.spec || options.task;

    const updates = { frontmatter: {} };

    if (options.status) {
      updates.frontmatter.status = options.status;
    }

    if (options.progress) {
      updates.frontmatter.progress = JSON.parse(options.progress);
    }

    if (options.assign) {
      updates.frontmatter.assigned_agent = options.assign;
      updates.frontmatter.assigned_at = new Date().toISOString();
    }

    // Update context
    const success = await contextManager.updateContext(contextType, contextId, updates);

    if (success) {
      console.log(chalk.green(`✅ Updated ${contextType} context for ${contextId}`));
    } else {
      console.error(chalk.red('❌ Failed to update context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Context update failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextShow(options) {
  try {
    const configManager = new ConfigManager(process.cwd());

    if (options.inject && options.agent) {
      // Show full injected context for agent
      const contextInjector = new ContextInjector(configManager);
      const injectedContext = await contextInjector.injectContext({
        agentType: options.agent,
        specId: options.spec,
        taskId: options.task
      });

      console.log(chalk.cyan('🔄 Injected Context Preview'));
      console.log(chalk.gray('='.repeat(50)));

      if (options.layers) {
        console.log(JSON.stringify(injectedContext, null, 2));
      } else {
        // Show condensed view
        console.log(chalk.white('Agent:'), chalk.yellow(injectedContext.metadata.agentType));
        console.log(chalk.white('Layers:'), chalk.cyan(Object.keys(injectedContext.layers).join(', ')));
        console.log(chalk.white('Performance:'), chalk.green(`${injectedContext.metadata.performance.total}ms`));

        if (injectedContext.inheritance) {
          console.log(chalk.white('Inheritance:'), chalk.blue(injectedContext.inheritance.hierarchy.join(' → ')));
        }

        if (injectedContext.relevanceScore) {
          console.log(chalk.white('Relevance:'), chalk.magenta(`${Math.round(injectedContext.relevanceScore * 100)}%`));
        }
      }
    } else if (options.spec || options.task) {
      // Show specific context
      const contextManager = new ContextManager(configManager);
      const contextType = options.spec ? 'spec' : 'task';
      const contextId = options.spec || options.task;

      const contextPath = contextType === 'spec'
        ? path.join(configManager.getProjectRoot(), '.asd', 'context', 'specs', `${contextId}-context.md`)
        : path.join(configManager.getProjectRoot(), '.asd', 'context', 'tasks', `${contextId}-context.md`);

      if (await contextManager.fileExists(contextPath)) {
        const fs = require('fs').promises;
        const content = await fs.readFile(contextPath, 'utf-8');
        console.log(chalk.cyan(`📄 ${contextType.charAt(0).toUpperCase() + contextType.slice(1)} Context: ${contextId}`));
        console.log(chalk.gray('='.repeat(50)));
        console.log(content);
      } else {
        console.log(chalk.yellow(`⚠️  No ${contextType} context found for ${contextId}`));
      }
    } else {
      // Show general context info
      const contextManager = new ContextManager(configManager);
      const paths = contextManager.getContextPaths();

      console.log(chalk.cyan('📋 Context System Overview'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Base Directory:'), chalk.yellow(paths.base));
      console.log(chalk.white('Context Path:'), chalk.yellow(paths.context));
      console.log(chalk.white('Agents Path:'), chalk.yellow(paths.agents));
      console.log(chalk.white('Processes Path:'), chalk.yellow(paths.processes));
    }

  } catch (error) {
    console.error(chalk.red('❌ Context show failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextValidate(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextValidator = new ContextValidator(configManager);

    if (options.files) {
      // Validate specific files using glob pattern
      const glob = require('glob');
      const filePaths = glob.sync(options.files);

      if (filePaths.length === 0) {
        console.log(chalk.yellow(`⚠️  No files found matching pattern: ${options.files}`));
        return;
      }

      const summary = await contextValidator.validateContextFiles(filePaths);

      console.log(chalk.cyan('🔍 Context Validation Results'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Total Files:'), chalk.blue(summary.totalFiles));
      console.log(chalk.white('Valid Files:'), chalk.green(summary.validFiles));
      console.log(chalk.white('Invalid Files:'), summary.invalidFiles > 0 ? chalk.red(summary.invalidFiles) : chalk.green(summary.invalidFiles));
      console.log(chalk.white('Warnings:'), summary.warnings > 0 ? chalk.yellow(summary.warnings) : chalk.green(summary.warnings));

      if (options.verbose) {
        summary.results.forEach(result => {
          console.log(chalk.gray('\n---'));
          console.log(chalk.white('File:'), result.filePath);
          console.log(chalk.white('Valid:'), result.isValid ? chalk.green('✓') : chalk.red('✗'));

          if (result.errors.length > 0) {
            console.log(chalk.red('Errors:'));
            result.errors.forEach(error => console.log(chalk.red(`  • ${error}`)));
          }

          if (result.warnings.length > 0) {
            console.log(chalk.yellow('Warnings:'));
            result.warnings.forEach(warning => console.log(chalk.yellow(`  • ${warning}`)));
          }
        });
      }
    } else {
      // Validate entire context system
      const glob = require('glob');
      const contextPaths = contextValidator.configManager.getProjectRoot();
      const allContextFiles = glob.sync(path.join(contextPaths, '.asd/**/*.md'));

      const summary = await contextValidator.validateContextFiles(allContextFiles);

      console.log(chalk.cyan('🔍 Full Context System Validation'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Total Files:'), chalk.blue(summary.totalFiles));
      console.log(chalk.white('Valid Files:'), chalk.green(summary.validFiles));
      console.log(chalk.white('Invalid Files:'), summary.invalidFiles > 0 ? chalk.red(summary.invalidFiles) : chalk.green(summary.invalidFiles));
      console.log(chalk.white('Warnings:'), summary.warnings > 0 ? chalk.yellow(summary.warnings) : chalk.green(summary.warnings));

      if (summary.invalidFiles === 0 && summary.warnings === 0) {
        console.log(chalk.green('\n✅ Context system validation passed!'));
      } else if (summary.invalidFiles === 0) {
        console.log(chalk.yellow('\n⚠️  Context system validation passed with warnings'));
      } else {
        console.log(chalk.red('\n❌ Context system validation failed'));
        process.exit(1);
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Context validation failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextExport(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const paths = contextManager.getContextPaths();

    const exportData = {
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      context: {},
      agents: {},
      processes: {}
    };

    // Export context files
    const glob = require('glob');
    const fs = require('fs').promises;

    const contextFiles = glob.sync(path.join(paths.context, '**/*.md'));
    for (const filePath of contextFiles) {
      const relativePath = path.relative(paths.context, filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      exportData.context[relativePath] = parsed;
    }

    // Export agent definitions
    const agentFiles = glob.sync(path.join(paths.agents, '*.md'));
    for (const filePath of agentFiles) {
      const filename = path.basename(filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      exportData.agents[filename] = parsed;
    }

    // Export process templates
    const processFiles = glob.sync(path.join(paths.processes, '*.md'));
    for (const filePath of processFiles) {
      const filename = path.basename(filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      exportData.processes[filename] = parsed;
    }

    // Include state if requested
    if (options.includeState) {
      const dynamicContext = await contextManager.loadDynamicContext();
      exportData.state = dynamicContext;
    }

    // Filter by spec if requested
    if (options.spec) {
      const specContext = exportData.context[`specs/${options.spec}-context.md`];
      exportData.context = specContext ? { [`specs/${options.spec}-context.md`]: specContext } : {};
    }

    // Write export file
    await fs.writeFile(options.output, JSON.stringify(exportData, null, 2), 'utf-8');

    console.log(chalk.green(`✅ Context exported to ${options.output}`));
    console.log(chalk.gray(`   Context files: ${Object.keys(exportData.context).length}`));
    console.log(chalk.gray(`   Agent files: ${Object.keys(exportData.agents).length}`));
    console.log(chalk.gray(`   Process files: ${Object.keys(exportData.processes).length}`));

  } catch (error) {
    console.error(chalk.red('❌ Context export failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextImport(file, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const paths = contextManager.getContextPaths();

    const fs = require('fs').promises;

    // Read import file
    const importData = JSON.parse(await fs.readFile(file, 'utf-8'));

    if (options.dryRun) {
      console.log(chalk.cyan('🔍 Import Preview (Dry Run)'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Context files to import:'), chalk.blue(Object.keys(importData.context || {}).length));
      console.log(chalk.white('Agent files to import:'), chalk.blue(Object.keys(importData.agents || {}).length));
      console.log(chalk.white('Process files to import:'), chalk.blue(Object.keys(importData.processes || {}).length));

      if (importData.state) {
        console.log(chalk.white('State data:'), chalk.yellow('included'));
      }

      console.log(chalk.yellow('\nNo changes made (dry run)'));
      return;
    }

    // Ensure directories exist
    await contextManager.initializeContextStructure();

    let importedCount = 0;

    // Import context files
    for (const [relativePath, parsed] of Object.entries(importData.context || {})) {
      const fullPath = path.join(paths.context, relativePath);
      await fs.mkdir(path.dirname(fullPath), { recursive: true });

      const content = contextManager.serializeMarkdownWithFrontmatter(
        parsed.frontmatter || {},
        parsed.content || ''
      );

      await fs.writeFile(fullPath, content, 'utf-8');
      importedCount++;
    }

    // Import agent definitions
    for (const [filename, parsed] of Object.entries(importData.agents || {})) {
      const fullPath = path.join(paths.agents, filename);

      const content = contextManager.serializeMarkdownWithFrontmatter(
        parsed.frontmatter || {},
        parsed.content || ''
      );

      await fs.writeFile(fullPath, content, 'utf-8');
      importedCount++;
    }

    // Import process templates
    for (const [filename, parsed] of Object.entries(importData.processes || {})) {
      const fullPath = path.join(paths.processes, filename);

      const content = contextManager.serializeMarkdownWithFrontmatter(
        parsed.frontmatter || {},
        parsed.content || ''
      );

      await fs.writeFile(fullPath, content, 'utf-8');
      importedCount++;
    }

    // Import state if present
    if (importData.state) {
      const assignmentsPath = path.join(paths.state, 'assignments.json');
      const progressPath = path.join(paths.state, 'progress.json');

      if (importData.state.assignments) {
        await fs.writeFile(assignmentsPath, JSON.stringify(importData.state.assignments, null, 2), 'utf-8');
      }

      if (importData.state.progress) {
        await fs.writeFile(progressPath, JSON.stringify(importData.state.progress, null, 2), 'utf-8');
      }
    }

    console.log(chalk.green('✅ Context import completed'));
    console.log(chalk.gray(`   Files imported: ${importedCount}`));
    console.log(chalk.gray(`   Source: ${file}`));

  } catch (error) {
    console.error(chalk.red('❌ Context import failed:'), error.message);
    process.exit(1);
  }
}

async function handleAgentCustomize(agentType, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const agentPath = path.join(configManager.getProjectRoot(), '.asd', 'agents', `${agentType}.md`);

    const fs = require('fs').promises;

    // Check if agent exists
    if (!(await fs.access(agentPath).then(() => true).catch(() => false))) {
      console.error(chalk.red(`❌ Agent definition not found: ${agentType}`));
      console.log(chalk.gray(`   Expected path: ${agentPath}`));
      process.exit(1);
    }

    if (options.edit) {
      // Open in editor
      const { spawn } = require('child_process');
      const editor = process.env.EDITOR || 'nano';

      const child = spawn(editor, [agentPath], {
        stdio: 'inherit'
      });

      child.on('exit', (code) => {
        if (code === 0) {
          console.log(chalk.green(`✅ Agent definition updated: ${agentType}`));
        } else {
          console.error(chalk.red('❌ Editor exited with error'));
          process.exit(1);
        }
      });
    } else {
      // Programmatic updates
      const content = await fs.readFile(agentPath, 'utf-8');
      const contextManager = new ContextManager(configManager);
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);

      let updated = false;
      const frontmatter = parsed.frontmatter || {};

      if (options.addStep) {
        frontmatter.workflow_steps = frontmatter.workflow_steps || [];
        frontmatter.workflow_steps.push(options.addStep);
        updated = true;
      }

      if (options.removeStep) {
        if (frontmatter.workflow_steps) {
          const index = frontmatter.workflow_steps.indexOf(options.removeStep);
          if (index > -1) {
            frontmatter.workflow_steps.splice(index, 1);
            updated = true;
          }
        }
      }

      if (options.addRequirement) {
        frontmatter.context_requirements = frontmatter.context_requirements || [];
        frontmatter.context_requirements.push(options.addRequirement);
        updated = true;
      }

      if (options.addCapability) {
        frontmatter.capabilities = frontmatter.capabilities || [];
        frontmatter.capabilities.push(options.addCapability);
        updated = true;
      }

      if (updated) {
        const newContent = contextManager.serializeMarkdownWithFrontmatter(frontmatter, parsed.content);
        await fs.writeFile(agentPath, newContent, 'utf-8');
        console.log(chalk.green(`✅ Agent definition updated: ${agentType}`));
      } else {
        console.log(chalk.yellow('⚠️  No updates specified'));
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Agent customize failed:'), error.message);
    process.exit(1);
  }
}

async function handleAgentList(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const agentsPath = path.join(configManager.getProjectRoot(), '.asd', 'agents');

    const fs = require('fs').promises;
    const glob = require('glob');

    const agentFiles = glob.sync(path.join(agentsPath, '*.md'));

    console.log(chalk.cyan('👥 Available Agents'));
    console.log(chalk.gray('='.repeat(50)));

    if (agentFiles.length === 0) {
      console.log(chalk.yellow('⚠️  No agent definitions found'));
      return;
    }

    const contextManager = new ContextManager(configManager);

    for (const filePath of agentFiles) {
      const agentType = path.basename(filePath, '.md');
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      const frontmatter = parsed.frontmatter || {};

      console.log(chalk.white('\n• Agent:'), chalk.yellow(agentType));

      if (options.details) {
        if (frontmatter.capabilities) {
          console.log(chalk.gray('  Capabilities:'), frontmatter.capabilities.slice(0, 3).join(', '));
        }
        if (frontmatter.specialization_areas) {
          console.log(chalk.gray('  Specializations:'), frontmatter.specialization_areas.slice(0, 3).join(', '));
        }
        if (frontmatter.context_requirements) {
          console.log(chalk.gray('  Context Needs:'), frontmatter.context_requirements.slice(0, 2).join(', '));
        }
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Agent list failed:'), error.message);
    process.exit(1);
  }
}

async function handleProcessUpdate(templateName, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const processPath = path.join(configManager.getProjectRoot(), '.asd', 'processes', `${templateName}.md`);

    const fs = require('fs').promises;

    if (options.edit) {
      // Open in editor
      const { spawn } = require('child_process');
      const editor = process.env.EDITOR || 'nano';

      const child = spawn(editor, [processPath], {
        stdio: 'inherit'
      });

      child.on('exit', (code) => {
        if (code === 0) {
          console.log(chalk.green(`✅ Process template updated: ${templateName}`));
        } else {
          console.error(chalk.red('❌ Editor exited with error'));
          process.exit(1);
        }
      });
    } else {
      // Programmatic updates
      let content, parsed;

      try {
        content = await fs.readFile(processPath, 'utf-8');
        const contextManager = new ContextManager(configManager);
        parsed = contextManager.parseMarkdownWithFrontmatter(content);
      } catch (error) {
        // File doesn't exist, create new
        parsed = { frontmatter: {}, content: '' };
      }

      let updated = false;
      const frontmatter = parsed.frontmatter || {};

      if (options.addRequirement) {
        frontmatter.validation_requirements = frontmatter.validation_requirements || [];
        frontmatter.validation_requirements.push(options.addRequirement);
        updated = true;
      }

      if (options.addStep) {
        frontmatter.process_steps = frontmatter.process_steps || [];
        frontmatter.process_steps.push(options.addStep);
        updated = true;
      }

      if (updated) {
        const contextManager = new ContextManager(configManager);
        const newContent = contextManager.serializeMarkdownWithFrontmatter(frontmatter, parsed.content);
        await fs.writeFile(processPath, newContent, 'utf-8');
        console.log(chalk.green(`✅ Process template updated: ${templateName}`));
      } else {
        console.log(chalk.yellow('⚠️  No updates specified'));
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Process update failed:'), error.message);
    process.exit(1);
  }
}

async function handleProcessList() {
  try {
    const configManager = new ConfigManager(process.cwd());
    const processesPath = path.join(configManager.getProjectRoot(), '.asd', 'processes');

    const fs = require('fs').promises;
    const glob = require('glob');

    const processFiles = glob.sync(path.join(processesPath, '*.md'));

    console.log(chalk.cyan('📋 Available Process Templates'));
    console.log(chalk.gray('='.repeat(50)));

    if (processFiles.length === 0) {
      console.log(chalk.yellow('⚠️  No process templates found'));
      return;
    }

    const contextManager = new ContextManager(configManager);

    for (const filePath of processFiles) {
      const templateName = path.basename(filePath, '.md');
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      const frontmatter = parsed.frontmatter || {};

      console.log(chalk.white('• Template:'), chalk.yellow(templateName));

      if (frontmatter.process_type) {
        console.log(chalk.gray('  Type:'), frontmatter.process_type);
      }

      if (frontmatter.validation_requirements && frontmatter.validation_requirements.length > 0) {
        console.log(chalk.gray('  Requirements:'), frontmatter.validation_requirements.length);
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Process list failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskAssign(specId, taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    if (!options.agent) {
      console.error(chalk.red('❌ Must specify --agent <agent-type>'));
      process.exit(1);
    }

    // Validate assignment using routing system if requested
    if (options.validate !== false) {
      console.log(chalk.blue('🔍 Validating assignment...'));

      const taskAPI = new TaskRecommendationAPI(configManager);
      const initialized = await taskAPI.initialize();

      if (initialized) {
        const validation = await taskAPI.validateAssignment({
          taskId: taskId,
          agentType: options.agent
        });

        if (validation.success && !validation.valid) {
          console.error(chalk.red('❌ Assignment validation failed:'));
          validation.issues.forEach(issue => {
            console.error(chalk.red(`  • ${issue}`));
          });

          if (validation.warnings && validation.warnings.length > 0) {
            console.warn(chalk.yellow('⚠️  Warnings:'));
            validation.warnings.forEach(warning => {
              console.warn(chalk.yellow(`  • ${warning}`));
            });
          }

          console.log(chalk.gray('\n💡 Use --no-validate to skip validation'));
          process.exit(1);
        } else if (validation.success) {
          console.log(chalk.green('✅ Assignment validation passed'));

          if (validation.warnings && validation.warnings.length > 0) {
            console.warn(chalk.yellow('⚠️  Validation warnings:'));
            validation.warnings.forEach(warning => {
              console.warn(chalk.yellow(`  • ${warning}`));
            });
          }
        } else {
          console.warn(chalk.yellow('⚠️  Could not validate assignment, proceeding anyway'));
        }
      } else {
        console.warn(chalk.yellow('⚠️  Task routing system unavailable, skipping validation'));
      }
    }

    // Update task context with assignment
    const updates = {
      frontmatter: {
        assigned_agent: options.agent,
        assigned_at: new Date().toISOString(),
        status: 'in_progress'
      }
    };

    if (options.priority) {
      updates.frontmatter.priority = options.priority;
    }

    // Update task context
    const taskSuccess = await contextManager.updateContext('task', taskId, updates);

    // Update dynamic state (assignments.json)
    const paths = contextManager.getContextPaths();
    const assignmentsPath = path.join(paths.state, 'assignments.json');

    const fs = require('fs').promises;
    let assignments = {};

    try {
      if (await contextManager.fileExists(assignmentsPath)) {
        const assignmentsContent = await fs.readFile(assignmentsPath, 'utf-8');
        assignments = JSON.parse(assignmentsContent);
      }
    } catch (error) {
      // Start fresh if file is corrupted
    }

    // Update assignments
    assignments[specId] = assignments[specId] || {};
    assignments[specId][taskId] = {
      agent: options.agent,
      assigned_at: new Date().toISOString(),
      priority: options.priority || 'P2',
      status: 'in_progress'
    };

    // Ensure state directory exists
    await fs.mkdir(paths.state, { recursive: true });
    await fs.writeFile(assignmentsPath, JSON.stringify(assignments, null, 2), 'utf-8');

    if (taskSuccess) {
      // Fire trigger for task assignment
      await triggerSystem.fireTrigger('assign', {
        specId,
        taskId,
        agentType: options.agent,
        priority: options.priority || 'P2',
        source: 'cli_command'
      });

      console.log(chalk.green(`✅ Assigned ${taskId} to ${options.agent}`));
      console.log(chalk.gray(`   Spec: ${specId}`));
      console.log(chalk.gray(`   Priority: ${options.priority || 'P2'}`));
    } else {
      console.error(chalk.red('❌ Failed to update task context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Task assignment failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskComplete(specId, taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Update task context with completion
    const updates = {
      frontmatter: {
        status: 'completed',
        completed_at: new Date().toISOString()
      }
    };

    if (options.notes) {
      updates.frontmatter.completion_notes = options.notes;
    }

    if (options.handoff) {
      updates.frontmatter.handoff_to = options.handoff;
    }

    // Update task context
    const taskSuccess = await contextManager.updateContext('task', taskId, updates);

    // Update progress tracking
    const paths = contextManager.getContextPaths();
    const progressPath = path.join(paths.state, 'progress.json');

    const fs = require('fs').promises;
    let progress = {};

    try {
      if (await contextManager.fileExists(progressPath)) {
        const progressContent = await fs.readFile(progressPath, 'utf-8');
        progress = JSON.parse(progressContent);
      }
    } catch (error) {
      // Start fresh if file is corrupted
    }

    // Update progress
    progress[specId] = progress[specId] || {};
    progress[specId][taskId] = {
      status: 'completed',
      completed_at: new Date().toISOString(),
      completion_notes: options.notes || null
    };

    // Ensure state directory exists
    await fs.mkdir(paths.state, { recursive: true });
    await fs.writeFile(progressPath, JSON.stringify(progress, null, 2), 'utf-8');

    if (taskSuccess) {
      // Fire trigger for task completion
      await triggerSystem.fireTrigger('complete', {
        specId,
        taskId,
        completionNotes: options.notes,
        handoffTo: options.handoff,
        source: 'cli_command'
      });

      console.log(chalk.green(`✅ Marked ${taskId} as complete`));
      console.log(chalk.gray(`   Spec: ${specId}`));
      if (options.notes) {
        console.log(chalk.gray(`   Notes: ${options.notes}`));
      }
      if (options.handoff) {
        console.log(chalk.yellow(`   🔄 Handoff to: ${options.handoff}`));
      }
    } else {
      console.error(chalk.red('❌ Failed to update task context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Task completion failed:'), error.message);
    process.exit(1);
  }
}

async function handleResearchCapture(specId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    if (!options.finding) {
      console.error(chalk.red('❌ Must specify --finding <text>'));
      process.exit(1);
    }

    const contextType = options.task ? 'task' : 'spec';
    const contextId = options.task || specId;

    // Create research finding object
    const researchFinding = {
      finding: options.finding,
      timestamp: new Date().toISOString(),
      source: options.source || 'manual',
      context: contextType === 'task' ? `${specId}:${options.task}` : specId
    };

    // Update context with research finding
    const updates = {
      frontmatter: {
        research_findings: [researchFinding]
      }
    };

    const success = await contextManager.updateContext(contextType, contextId, updates);

    if (success) {
      // Fire trigger for research capture
      await triggerSystem.fireTrigger('research', {
        specId,
        taskId: options.task,
        finding: options.finding,
        source: options.source,
        contextType,
        contextId
      });

      console.log(chalk.green(`✅ Research finding captured for ${contextType} ${contextId}`));
      console.log(chalk.gray(`   Finding: ${options.finding.slice(0, 80)}${options.finding.length > 80 ? '...' : ''}`));
      if (options.source) {
        console.log(chalk.gray(`   Source: ${options.source}`));
      }
    } else {
      console.error(chalk.red('❌ Failed to capture research finding'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Research capture failed:'), error.message);
    process.exit(1);
  }
}

async function startASD(options) {
  try {
    // Prepare configuration
    const configOptions = {
      cwd: process.cwd(),
      configPath: options.config,
      appName: options.appName,
      appIcon: options.appIcon,
    };

    if (options.path) {
      configOptions.featuresPath = options.path;
    }

    if (options.noAutoRefresh) {
      configOptions.autoRefresh = false;
    }

    if (options.debug) {
      process.env.DEBUG_STARTUP = 'true';
      process.env.DEBUG_LAYOUT = 'true';
    }

    // Create and start ASD client
    const asd = new ASDClient(configOptions);
    await asd.init();

  } catch (error) {
    console.error(chalk.red('❌ Failed to start ASD:'), error.message);

    if (options.debug) {
      console.error(chalk.gray('Stack trace:'), error.stack);
    }

    process.exit(1);
  }
}

// Handler functions for task routing commands
async function handleNextTask(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const taskAPI = new TaskRecommendationAPI(configManager);

    // Initialize the API
    const initialized = await taskAPI.initialize();
    if (!initialized) {
      console.error(chalk.red('❌ Failed to initialize task routing system'));
      process.exit(1);
    }

    // Parse filter options
    const priority = options.priority ? options.priority.split(',') : undefined;
    const phase = options.phase ? options.phase.split(',') : undefined;
    const specStatus = options.specStatus ? options.specStatus.split(',') : undefined;
    const limit = parseInt(options.limit) || 5;

    // Use transparent API if requested
    if (options.transparent) {
      const result = await taskAPI.getTransparentRecommendation({
        agentType: options.agent,
        filters: { priority, phase, specStatus }
      });

      if (!result.success) {
        console.error(chalk.red('❌ Task recommendation failed:'), result.error);
        process.exit(1);
      }

      displayTransparentRecommendation(result);
      return;
    }

    // Get task recommendation
    const result = await taskAPI.getNextTask({
      agentType: options.agent,
      priority,
      phase,
      specStatus,
      includeReasoning: options.showReasoning,
      includeAlternatives: options.showAlternatives
    });

    if (!result.success) {
      console.error(chalk.red('❌ Task recommendation failed:'), result.error);
      process.exit(1);
    }

    displayTaskRecommendation(result, options);

  } catch (error) {
    console.error(chalk.red('❌ Next task command failed:'), error.message);
    process.exit(1);
  }
}

async function handleTasksList(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const taskAPI = new TaskRecommendationAPI(configManager);

    const initialized = await taskAPI.initialize();
    if (!initialized) {
      console.error(chalk.red('❌ Failed to initialize task routing system'));
      process.exit(1);
    }

    // Parse filter options
    const priority = options.priority ? options.priority.split(',') : undefined;
    const phase = options.phase ? options.phase.split(',') : undefined;
    const specStatus = options.specStatus ? options.specStatus.split(',') : undefined;
    const limit = parseInt(options.limit) || 10;

    const result = await taskAPI.getAvailableTasks({
      agentType: options.agent,
      priority,
      phase,
      specStatus,
      limit,
      includeBlocked: options.includeBlocked
    });

    if (!result.success) {
      console.error(chalk.red('❌ Failed to list tasks:'), result.error);
      process.exit(1);
    }

    displayTasksList(result);

  } catch (error) {
    console.error(chalk.red('❌ Tasks list command failed:'), error.message);
    process.exit(1);
  }
}

async function handleValidateAssignment(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const taskAPI = new TaskRecommendationAPI(configManager);

    const initialized = await taskAPI.initialize();
    if (!initialized) {
      console.error(chalk.red('❌ Failed to initialize task routing system'));
      process.exit(1);
    }

    const result = await taskAPI.validateAssignment({
      taskId: options.task,
      agentType: options.agent
    });

    if (!result.success) {
      console.error(chalk.red('❌ Assignment validation failed:'), result.error);
      process.exit(1);
    }

    displayValidationResult(result, options);

  } catch (error) {
    console.error(chalk.red('❌ Validate assignment command failed:'), error.message);
    process.exit(1);
  }
}

function displayTaskRecommendation(result, options) {
  console.log(chalk.cyan('🎯 Task Recommendation'));
  console.log(chalk.gray('='.repeat(50)));

  if (!result.task) {
    console.log(chalk.yellow('⚠️  No task found matching criteria'));

    if (result.reasoning) {
      console.log(chalk.gray('\nReason:'), result.reasoning.summary);

      if (result.reasoning.suggestion) {
        console.log(chalk.blue('💡 Suggestion:'), result.reasoning.suggestion);
      }

      if (result.reasoning.availableAlternatives > 0) {
        console.log(chalk.gray(`Available alternatives: ${result.reasoning.availableAlternatives}`));
      }
    }

    console.log(chalk.gray('\nFilters applied:'));
    console.log(chalk.gray(`  Agent: ${result.metadata.filters.agentType}`));
    if (result.metadata.filters.priority) {
      console.log(chalk.gray(`  Priority: ${Array.isArray(result.metadata.filters.priority) ? result.metadata.filters.priority.join(', ') : result.metadata.filters.priority}`));
    }
    if (result.metadata.filters.phase) {
      console.log(chalk.gray(`  Phase: ${Array.isArray(result.metadata.filters.phase) ? result.metadata.filters.phase.join(', ') : result.metadata.filters.phase}`));
    }

    return;
  }

  // Main recommendation
  console.log(chalk.green('✅ Recommended Task:'), chalk.yellow(result.task.id));
  console.log(chalk.white('Title:'), result.task.title);
  console.log(chalk.white('Spec:'), result.task.specId || 'N/A');
  console.log(chalk.white('Priority:'), getPriorityDisplay(result.task.specPriority || result.task.priority));
  console.log(chalk.white('Phase:'), result.task.phase || 'N/A');
  console.log(chalk.white('Estimated Hours:'), result.task.estimated_hours || 'N/A');

  if (result.task.agent_type) {
    console.log(chalk.white('Required Agent:'), result.task.agent_type);
  }

  if (result.task.context_requirements && result.task.context_requirements.length > 0) {
    console.log(chalk.white('Context Requirements:'), result.task.context_requirements.join(', '));
  }

  // Show score if available
  if (result.task.score !== undefined) {
    console.log(chalk.white('Recommendation Score:'), chalk.cyan(result.task.score));
  }

  // Show reasoning if requested
  if (options.showReasoning && result.reasoning) {
    console.log(chalk.blue('\n📋 Recommendation Reasoning:'));
    console.log(chalk.gray(result.reasoning.summary));

    if (result.reasoning.factors && result.reasoning.factors.length > 0) {
      console.log(chalk.blue('\nScoring Factors:'));
      result.reasoning.factors.forEach(factor => {
        const impactColor = factor.impact === 'High' ? 'green' :
                           factor.impact === 'Positive' ? 'cyan' :
                           factor.impact === 'Negative' ? 'red' : 'gray';
        console.log(chalk.gray(`  • ${factor.factor}: ${factor.value}`), chalk[impactColor](`(${factor.impact})`));
      });
    }

    console.log(chalk.white('Confidence:'), getConfidenceDisplay(result.reasoning.confidence));
    console.log(chalk.white('Recommendation:'), chalk.cyan(result.reasoning.recommendation));
  }

  // Show constraint validation if available
  if (result.task.constraintValidation) {
    const validation = result.task.constraintValidation;
    console.log(chalk.blue('\n🔍 Constraint Validation:'));
    console.log(chalk.white('Valid:'), validation.isValid ? chalk.green('✓') : chalk.red('✗'));

    if (validation.violations && validation.violations.length > 0) {
      console.log(chalk.red('Violations:'));
      validation.violations.forEach(violation => {
        console.log(chalk.red(`  • ${violation}`));
      });
    }

    if (validation.warnings && validation.warnings.length > 0) {
      console.log(chalk.yellow('Warnings:'));
      validation.warnings.forEach(warning => {
        console.log(chalk.yellow(`  • ${warning}`));
      });
    }
  }

  // Show alternatives if requested
  if (options.showAlternatives && result.alternatives && result.alternatives.length > 0) {
    console.log(chalk.blue('\n🔄 Alternative Tasks:'));
    result.alternatives.slice(0, 3).forEach((alt, index) => {
      console.log(chalk.gray(`${index + 1}. ${alt.id} - ${alt.title}`));
      console.log(chalk.gray(`   Score: ${alt.score}, Priority: ${getPriorityDisplay(alt.specPriority || alt.priority)}`));
    });
  }

  // Show performance and metadata
  console.log(chalk.gray(`\nPerformance: ${result.metadata.performance.total}ms`));
  console.log(chalk.gray(`Available tasks: ${result.metadata.totalAvailable}, Agent matches: ${result.metadata.agentMatches}`));
}

function displayTransparentRecommendation(result) {
  console.log(chalk.cyan('🔍 Transparent Task Recommendation'));
  console.log(chalk.gray('='.repeat(50)));

  if (!result.recommendation.task) {
    console.log(chalk.yellow('⚠️  No task found matching criteria'));
    if (result.recommendation.transparency.reasoning) {
      console.log(chalk.gray('\nReason:'), result.recommendation.transparency.reasoning.summary);
    }
    return;
  }

  const task = result.recommendation.task;
  const transparency = result.recommendation.transparency;

  // Basic task info
  console.log(chalk.green('✅ Recommended Task:'), chalk.yellow(task.id));
  console.log(chalk.white('Title:'), task.title);
  console.log(chalk.white('Score:'), chalk.cyan(task.score));

  // Scoring breakdown
  if (transparency.scoring) {
    console.log(chalk.blue('\n📊 Scoring Breakdown:'));
    const breakdown = transparency.scoring.breakdown;
    Object.entries(breakdown).forEach(([factor, data]) => {
      if (data && typeof data === 'object' && data.multiplier !== undefined) {
        console.log(chalk.gray(`  ${factor}:`), `${data.multiplier}x`, chalk.gray(`(${data.details})`));
      }
    });
  }

  // Constraint details
  if (transparency.constraints) {
    console.log(chalk.blue('\n🔒 Constraint Analysis:'));
    console.log(chalk.white('Valid:'), transparency.constraints.isValid ? chalk.green('✓') : chalk.red('✗'));
    console.log(chalk.white('Score Multiplier:'), chalk.cyan(transparency.constraints.score));

    Object.entries(transparency.constraints.details).forEach(([constraint, details]) => {
      console.log(chalk.gray(`  ${constraint}:`), details.isValid ? chalk.green('✓') : chalk.red('✗'));
      if (details.details && typeof details.details === 'string') {
        console.log(chalk.gray(`    ${details.details}`));
      }
    });
  }

  // Agent matching analysis
  if (transparency.agentMatch) {
    console.log(chalk.blue('\n👤 Agent Match Analysis:'));
    console.log(chalk.white('Agent Type Match:'), transparency.agentMatch.agentTypeMatch ? chalk.green('✓') : chalk.gray('–'));
    console.log(chalk.white('Match Quality:'), getMatchQualityDisplay(transparency.agentMatch.matchQuality));

    if (transparency.agentMatch.requiredContexts && transparency.agentMatch.requiredContexts.length > 0) {
      console.log(chalk.white('Required Contexts:'), transparency.agentMatch.requiredContexts.join(', '));
    }

    if (transparency.agentMatch.matchingContexts && transparency.agentMatch.matchingContexts.length > 0) {
      console.log(chalk.white('Matching Contexts:'), chalk.green(transparency.agentMatch.matchingContexts.join(', ')));
    }
  }

  // Algorithmic details
  if (transparency.reasoning && transparency.reasoning.algorithmic) {
    console.log(chalk.blue('\n⚙️  Algorithm Details:'));
    const algo = transparency.reasoning.algorithmic;
    console.log(chalk.gray('Scoring Method:'), algo.scoringMethod);
    console.log(chalk.gray('Constraint Engine:'), algo.constraintEngine);
    console.log(chalk.gray('Agent Matching:'), algo.agentMatching);
  }

  console.log(chalk.gray(`\nPerformance: ${result.metadata.performance.total}ms`));
}

function displayTasksList(result) {
  console.log(chalk.cyan('📋 Available Tasks'));
  console.log(chalk.gray('='.repeat(50)));

  if (result.tasks.length === 0) {
    console.log(chalk.yellow('⚠️  No tasks found matching criteria'));
    return;
  }

  console.log(chalk.white(`Found ${result.tasks.length} tasks:`));
  console.log();

  result.tasks.forEach((task, index) => {
    const status = task.blocked ? chalk.red('[BLOCKED]') :
                   task.status === 'complete' ? chalk.green('[COMPLETE]') :
                   task.status === 'in_progress' ? chalk.blue('[IN PROGRESS]') :
                   chalk.green('[READY]');

    console.log(chalk.white(`${index + 1}. ${task.id}`), status);
    console.log(chalk.gray(`   Title: ${task.title}`));
    console.log(chalk.gray(`   Spec: ${task.specId || 'N/A'}, Priority: ${getPriorityDisplay(task.specPriority || task.priority)}`));

    if (task.agent_type) {
      console.log(chalk.gray(`   Required Agent: ${task.agent_type}`));
    }

    if (task.estimated_hours) {
      console.log(chalk.gray(`   Estimated Hours: ${task.estimated_hours}`));
    }

    if (task.blocked && task.blockedReason) {
      console.log(chalk.red(`   Blocked: ${task.blockedReason}`));
    }

    console.log();
  });

  console.log(chalk.gray(`Performance: ${result.metadata.performance.total}ms`));
  console.log(chalk.gray(`Total available: ${result.metadata.total}, Filters: ${JSON.stringify(result.metadata.filters)}`));
}

function displayValidationResult(result, _options) {
  console.log(chalk.cyan('🔍 Assignment Validation'));
  console.log(chalk.gray('='.repeat(50)));

  console.log(chalk.white('Task:'), result.taskId || _options.task);
  console.log(chalk.white('Agent:'), _options.agent);
  console.log(chalk.white('Valid:'), result.valid ? chalk.green('✓ Valid') : chalk.red('✗ Invalid'));

  if (result.issues && result.issues.length > 0) {
    console.log(chalk.red('\nIssues:'));
    result.issues.forEach(issue => {
      console.log(chalk.red(`  • ${issue}`));
    });
  }

  if (result.warnings && result.warnings.length > 0) {
    console.log(chalk.yellow('\nWarnings:'));
    result.warnings.forEach(warning => {
      console.log(chalk.yellow(`  • ${warning}`));
    });
  }

  if (_options.showDetails && result.details) {
    console.log(chalk.blue('\n📊 Validation Details:'));
    console.log(chalk.gray('Task Available:'), result.details.taskAvailable ? chalk.green('✓') : chalk.red('✗'));
    console.log(chalk.gray('Agent Capable:'), result.details.agentCapable ? chalk.green('✓') : chalk.red('✗'));
    console.log(chalk.gray('Constraints Passed:'), result.details.constraintsPassed ? chalk.green('✓') : chalk.red('✗'));
  }

  if (result.constraintDetails) {
    console.log(chalk.blue('\n🔒 Constraint Details:'));
    console.log(chalk.gray('Constraint Score:'), chalk.cyan(result.constraintDetails.score));

    if (result.constraintDetails.details) {
      Object.entries(result.constraintDetails.details).forEach(([constraint, details]) => {
        console.log(chalk.gray(`  ${constraint}:`), details.isValid ? chalk.green('✓') : chalk.red('✗'));
      });
    }
  }

  console.log(chalk.gray(`\nValidation time: ${result.performance.total}ms`));
}

// Utility display functions
function getPriorityDisplay(priority) {
  switch (priority) {
    case 'P0': return chalk.red('P0 (Critical)');
    case 'P1': return chalk.yellow('P1 (High)');
    case 'P2': return chalk.blue('P2 (Medium)');
    case 'P3': return chalk.gray('P3 (Low)');
    default: return chalk.gray(priority || 'N/A');
  }
}

function getConfidenceDisplay(confidence) {
  const percent = Math.round(confidence * 100);
  const color = confidence >= 0.8 ? 'green' : confidence >= 0.6 ? 'yellow' : 'red';
  return chalk[color](`${percent}%`);
}

function getMatchQualityDisplay(quality) {
  switch (quality) {
    case 'Excellent match': return chalk.green(quality);
    case 'Good match': return chalk.cyan(quality);
    case 'Partial match': return chalk.yellow(quality);
    case 'Poor match': return chalk.red(quality);
    default: return chalk.gray(quality);
  }
}

// Workflow state management handler functions
async function handleWorkflowStatus(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const assignments = await stateManager.getCurrentAssignments();
    
    console.log(chalk.cyan('📊 Current Workflow Status'));
    console.log(chalk.gray('='.repeat(70)));
    
    if (assignments.current_assignments.length === 0) {
      console.log(chalk.yellow('⚠️  No active assignments'));
      console.log(chalk.gray('\nUse "asd assign <spec-id> <task-id> --agent <agent-type>" to create assignments'));
      return;
    }

    console.log(chalk.white(`🎯 Active Assignments: ${chalk.cyan(assignments.total_active_assignments)}`));
    console.log();

    // Sort assignments by priority and start time
    let sortedAssignments = [...assignments.current_assignments];
    if (!options.agent) {
      const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3 };
      sortedAssignments.sort((a, b) => {
        const priorityDiff = (priorityOrder[a.priority] || 4) - (priorityOrder[b.priority] || 4);
        if (priorityDiff !== 0) return priorityDiff;
        return new Date(a.started_at) - new Date(b.started_at);
      });
    }

    for (const assignment of sortedAssignments) {
      if (!options.agent || assignment.assigned_agent === options.agent) {
        const priorityIcon = ui.getPriorityIcon(assignment.priority);
        const statusIcon = assignment.status === 'completed' ? '✅' : '🔄';
        
        if (options.visual) {
          // Rich visual display
          console.log(`${statusIcon} ${priorityIcon} ${chalk.yellow(assignment.spec_id)}:${chalk.cyan(assignment.task_id)}`);
          console.log(`   👤 ${chalk.white(assignment.assigned_agent)} | 📅 ${chalk.gray(ui.formatDate(assignment.started_at))}`);
          
          if (options.verbose) {
            const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 10) / 10;
            const estimatedHours = assignment.estimated_hours || 'N/A';
            console.log(`   ⏱️  Duration: ${chalk.cyan(duration + 'h')} | Estimated: ${chalk.gray(estimatedHours + 'h')}`);
            
            if (assignment.completion_notes && assignment.status === 'completed') {
              const notes = assignment.completion_notes.substring(0, 60) + '...';
              console.log(`   📝 ${chalk.gray(notes)}`);
            }
          }
        } else {
          // Standard display
          console.log(chalk.white(`• ${assignment.spec_id}:${assignment.task_id}`));
          console.log(chalk.gray(`  Agent: ${assignment.assigned_agent}`));
          console.log(chalk.gray(`  Started: ${new Date(assignment.started_at).toLocaleString()}`));
          console.log(chalk.gray(`  Priority: ${getPriorityDisplay(assignment.priority)}`));
          
          if (options.verbose) {
            console.log(chalk.gray(`  Estimated Hours: ${assignment.estimated_hours || 'N/A'}`));
            const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 100) / 100;
            console.log(chalk.gray(`  Duration: ${duration}h`));
          }
        }
        console.log();
      }
    }

    // Enhanced agent workload display
    if ((options.workload || options.visual) && Object.keys(assignments.agent_workloads).length > 0) {
      console.log(chalk.blue('👥 Agent Workload Summary:'));
      console.log(chalk.gray('─'.repeat(50)));
      
      const workloadEntries = Object.entries(assignments.agent_workloads);
      workloadEntries.sort((a, b) => b[1].current_tasks - a[1].current_tasks); // Sort by task count
      
      for (const [agent, workload] of workloadEntries) {
        if (!options.agent || agent === options.agent) {
          const taskCount = workload.current_tasks;
          const totalHours = workload.total_hours;
          
          if (options.visual) {
            // Create workload bar (assuming max 5 tasks for visualization)
            const maxTasks = Math.max(5, Math.max(...workloadEntries.map(([_, w]) => w.current_tasks)));
            const workloadPercentage = Math.round((taskCount / maxTasks) * 100);
            const workloadBar = ui.createProgressBar(workloadPercentage, 10);
            
            console.log(`  👤 ${chalk.cyan(agent.padEnd(20))} [${chalk[workloadBar.barColor](workloadBar.filled)}${chalk.gray(workloadBar.empty)}] ${chalk.white(taskCount)} tasks (${chalk.gray(totalHours + 'h')})`);
            
            // Show individual assignments for this agent
            if (options.verbose) {
              for (const assignment of workload.assignments) {
                const priorityIcon = ui.getPriorityIcon(assignment.priority);
                console.log(`     ${priorityIcon} ${chalk.gray(assignment.spec_id + ':' + assignment.task_id)}`);
              }
            }
          } else {
            console.log(chalk.gray(`  ${agent}: ${taskCount} tasks, ${totalHours}h total`));
          }
        }
      }
    }

    // Timeline view
    if (options.timeline) {
      console.log(chalk.blue('\n📅 Assignment Timeline:'));
      console.log(chalk.gray('─'.repeat(50)));
      
      const timelineAssignments = [...assignments.current_assignments]
        .filter(a => !options.agent || a.assigned_agent === options.agent)
        .sort((a, b) => new Date(a.started_at) - new Date(b.started_at));
      
      for (const assignment of timelineAssignments) {
        const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 10) / 10;
        const priorityIcon = ui.getPriorityIcon(assignment.priority);
        const timeAgo = ui.formatDate(assignment.started_at);
        
        console.log(`  ${chalk.gray(timeAgo.padEnd(12))} ${priorityIcon} ${chalk.yellow(assignment.spec_id)}:${chalk.cyan(assignment.task_id)} → ${chalk.white(assignment.assigned_agent)} ${chalk.gray('(' + duration + 'h)')}`);
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow status failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowProgress(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    if (options.spec) {
      const specProgress = await stateManager.getSpecProgress(options.spec);
      const specs = specParser.getSpecs();
      const spec = specs.find(s => s.id === options.spec);
      
      console.log(chalk.cyan(`📈 Progress for ${options.spec}`));
      if (spec && spec.title) {
        console.log(chalk.white(`   ${spec.title}`));
      }
      console.log(chalk.gray('='.repeat(70)));
      
      // Rich progress visualization for single spec
      const totalTasks = specProgress.total_tasks || 0;
      const completedTasks = specProgress.completed_tasks || 0;
      const percentage = Math.round(specProgress.completion_percentage || 0);
      
      if (options.visual || options.bars) {
        const progressBar = ui.createProgressBar(percentage, 20);
        console.log(chalk.white('\nOverall Progress:'));
        console.log(`  [${chalk[progressBar.percentageColor](progressBar.filled)}${chalk.gray(progressBar.empty)}] ${chalk[progressBar.percentageColor](progressBar.percentage)} (${completedTasks}/${totalTasks} tasks)`);
      } else {
        console.log(chalk.white(`Total Tasks: ${totalTasks}`));
        console.log(chalk.white(`Completed Tasks: ${completedTasks}`));
        console.log(chalk.white(`Completion: ${percentage}%`));
      }
      
      console.log(chalk.white(`Active Assignments: ${specProgress.active_assignments?.length || 0}`));
      
      if (options.detailed && specProgress.active_assignments && specProgress.active_assignments.length > 0) {
        console.log(chalk.blue('\n📋 Active Assignments:'));
        for (const assignment of specProgress.active_assignments) {
          const agentColor = ui.getColoredPriority(assignment.priority || 'P2');
          console.log(`  • ${chalk.yellow(assignment.task_id)} → ${chalk.cyan(assignment.assigned_agent)} ${agentColor.text}`);
          if (assignment.started_at) {
            const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 10) / 10;
            console.log(chalk.gray(`    Started: ${ui.formatDate(assignment.started_at)} (${duration}h ago)`));
          }
        }
      }
    } else {
      const progress = await stateManager.getProjectProgress();
      const specs = specParser.getSpecs();
      
      console.log(chalk.cyan('📈 Project Progress Overview'));
      console.log(chalk.gray('='.repeat(70)));
      
      // Overall project stats with rich visualization
      const overallPercentage = Math.round(progress.overall.completion_percentage || 0);
      
      if (options.visual || options.bars) {
        console.log(chalk.white('\n🎯 Overall Project Progress:'));
        const overallBar = ui.createProgressBar(overallPercentage, 25);
        console.log(`  [${chalk[overallBar.percentageColor](overallBar.filled)}${chalk.gray(overallBar.empty)}] ${chalk[overallBar.percentageColor](overallBar.percentage)}`);
        console.log(chalk.gray(`  Tasks: ${progress.overall.completed_tasks}/${progress.overall.total_tasks} | Specs: ${progress.overall.completed_specs}/${progress.overall.total_specs}`));
      } else {
        console.log(chalk.white(`Total Specs: ${progress.overall.total_specs}`));
        console.log(chalk.white(`Active Specs: ${progress.overall.active_specs}`));
        console.log(chalk.white(`Completed Specs: ${progress.overall.completed_specs}`));
        console.log(chalk.white(`Total Tasks: ${progress.overall.total_tasks}`));
        console.log(chalk.white(`Completed Tasks: ${progress.overall.completed_tasks}`));
        console.log(chalk.white(`Overall Completion: ${overallPercentage}%`));
      }
      
      console.log(chalk.white(`Active Assignments: ${progress.active_assignments || 0}`));
      
      // Phase progress with visual bars
      if (options.detailed && progress.by_phase && Object.keys(progress.by_phase).length > 0) {
        console.log(chalk.blue('\n📊 Progress by Phase:'));
        const phases = Object.entries(progress.by_phase);
        
        // Sort phases if requested
        if (options.sort === 'completion') {
          phases.sort((a, b) => b[1].completion_percentage - a[1].completion_percentage);
        }
        
        for (const [phase, phaseData] of phases) {
          if (!options.phase || phase === options.phase) {
            const phasePercentage = Math.round(phaseData.completion_percentage || 0);
            
            if (options.visual || options.bars) {
              const phaseBar = ui.createProgressBar(phasePercentage, 15);
              console.log(`  ${chalk.cyan(phase.padEnd(12))} [${chalk[phaseBar.percentageColor](phaseBar.filled)}${chalk.gray(phaseBar.empty)}] ${chalk[phaseBar.percentageColor](phaseBar.percentage)} (${phaseData.completed_specs}/${phaseData.specs})`);
            } else {
              console.log(chalk.gray(`  ${phase}: ${phaseData.completed_specs}/${phaseData.specs} specs (${phasePercentage}%)`));
            }
          }
        }
      }
      
      // Spec-level progress breakdown
      if (options.detailed && progress.by_spec && Object.keys(progress.by_spec).length > 0) {
        console.log(chalk.blue('\n📋 Progress by Specification:'));
        const specEntries = Object.entries(progress.by_spec).filter(([_, specData]) => 
          specData.total_tasks > 0 || specData.completed_tasks > 0
        );
        
        // Sort specs if requested
        if (options.sort === 'completion') {
          specEntries.sort((a, b) => (b[1].completion_percentage || 0) - (a[1].completion_percentage || 0));
        } else if (options.sort === 'priority') {
          specEntries.sort((a, b) => {
            const specA = specs.find(s => s.id === a[0]);
            const specB = specs.find(s => s.id === b[0]);
            const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3 };
            return (priorityOrder[specA?.priority] || 4) - (priorityOrder[specB?.priority] || 4);
          });
        }
        
        for (const [specId, specData] of specEntries.slice(0, 10)) { // Show top 10
          const spec = specs.find(s => s.id === specId);
          const percentage = Math.round(specData.completion_percentage || 0);
          const priorityIcon = spec ? ui.getPriorityIcon(spec.priority) : '';
          
          if (options.visual || options.bars) {
            const specBar = ui.createProgressBar(percentage, 12);
            const title = spec ? ui.formatFeatureTitle(spec.title, 35) : specId;
            console.log(`  ${priorityIcon} ${chalk.yellow(specId.padEnd(10))} [${chalk[specBar.percentageColor](specBar.filled)}${chalk.gray(specBar.empty)}] ${chalk[specBar.percentageColor](specBar.percentage)} ${chalk.gray(title)}`);
          } else {
            console.log(`  ${priorityIcon} ${chalk.yellow(specId)}: ${specData.completed_tasks}/${specData.total_tasks} tasks (${percentage}%)`);
          }
        }
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow progress failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowHandoffs(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const handoffStatus = await stateManager.getHandoffStatus();
    const specs = specParser.getSpecs();
    
    console.log(chalk.cyan('🔄 Workflow Handoffs'));
    console.log(chalk.gray('='.repeat(70)));
    
    if (!options.history) {
      console.log(chalk.white(`🎯 Ready Handoffs: ${chalk.cyan(handoffStatus.ready_handoffs.length)}`));
      
      if (handoffStatus.ready_handoffs.length > 0) {
        console.log(chalk.blue('\n📤 Ready for Handoff:'));
        
        for (const handoff of handoffStatus.ready_handoffs) {
          const spec = specs.find(s => s.id === handoff.spec_id);
          const priorityIcon = spec ? ui.getPriorityIcon(spec.priority) : '';
          const timeReady = ui.formatDate(handoff.ready_at);
          
          if (options.visual) {
            console.log(`🔄 ${priorityIcon} ${chalk.yellow(handoff.spec_id)}: ${chalk.cyan(handoff.from_task)} → ${chalk.green(handoff.to_task)}`);
            console.log(`   👤 ${chalk.white(handoff.next_agent)} | ⏰ Ready since ${chalk.gray(timeReady)}`);
            console.log(`   📝 ${chalk.gray(handoff.handoff_reason || handoff.reason || 'No reason provided')}`);
            
            if (handoff.context_prepared) {
              console.log(`   ✅ ${chalk.green('Context prepared for handoff')}`);
            } else {
              console.log(`   ⚠️  ${chalk.yellow('Context preparation pending')}`);
            }
          } else {
            console.log(chalk.white(`• ${handoff.spec_id}: ${handoff.from_task} → ${handoff.to_task}`));
            console.log(chalk.gray(`  Next Agent: ${handoff.next_agent}`));
            console.log(chalk.gray(`  Ready Since: ${new Date(handoff.ready_at).toLocaleString()}`));
            console.log(chalk.gray(`  Reason: ${handoff.handoff_reason || handoff.reason}`));
          }
          console.log();
        }
      } else {
        console.log(chalk.gray('\n⚡ No handoffs ready at this time'));
        console.log(chalk.gray('   All tasks are either in progress or waiting for dependencies'));
      }
    }
    
    // Timeline view for handoffs
    if (options.timeline && handoffStatus.ready_handoffs.length > 0) {
      console.log(chalk.blue('📅 Handoff Timeline:'));
      console.log(chalk.gray('─'.repeat(50)));
      
      const sortedHandoffs = [...handoffStatus.ready_handoffs].sort((a, b) => 
        new Date(a.ready_at) - new Date(b.ready_at)
      );
      
      for (const handoff of sortedHandoffs) {
        const timeReady = new Date(handoff.ready_at).toLocaleDateString('en-US', { 
          month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' 
        });
        const spec = specs.find(s => s.id === handoff.spec_id);
        const priorityIcon = spec ? ui.getPriorityIcon(spec.priority) : '';
        
        console.log(`  ${chalk.gray(timeReady.padEnd(15))} ${priorityIcon} ${chalk.yellow(handoff.spec_id)} ${chalk.cyan(handoff.from_task)} → ${chalk.green(handoff.to_task)} (${chalk.white(handoff.next_agent)})`);
      }
    }
    
    if (options.history && handoffStatus.handoff_history.length > 0) {
      console.log(chalk.blue('\n📜 Recent Handoff History:'));
      console.log(chalk.gray('─'.repeat(50)));
      
      for (const historyItem of handoffStatus.handoff_history) {
        const completedTime = ui.formatDate(historyItem.completed_at);
        
        if (options.visual) {
          console.log(`✅ ${chalk.yellow(historyItem.spec_id)}: ${chalk.cyan(historyItem.from_task)} → ${chalk.green(historyItem.to_task)}`);
          console.log(`   ⏰ Completed: ${chalk.gray(completedTime)}`);
        } else {
          console.log(chalk.gray(`• ${historyItem.spec_id}: ${historyItem.from_task} → ${historyItem.to_task}`));
          console.log(chalk.gray(`  Completed: ${new Date(historyItem.completed_at).toLocaleString()}`));
        }
      }
    }

    // Agent availability summary
    if (options.visual && handoffStatus.agent_availability && Object.keys(handoffStatus.agent_availability).length > 0) {
      console.log(chalk.green('\n👥 Agent Availability for Handoffs:'));
      console.log(chalk.gray('─'.repeat(50)));
      
      for (const [agent, availability] of Object.entries(handoffStatus.agent_availability)) {
        const taskCount = availability.current_tasks || 0;
        const totalHours = availability.total_hours || 0;
        const workloadLevel = taskCount === 0 ? 'Available' : 
                             taskCount <= 2 ? 'Light Load' : 
                             taskCount <= 4 ? 'Moderate Load' : 'Heavy Load';
        
        const workloadColor = taskCount === 0 ? 'green' : 
                             taskCount <= 2 ? 'cyan' : 
                             taskCount <= 4 ? 'yellow' : 'red';
        
        console.log(`  👤 ${chalk.cyan(agent.padEnd(20))} ${chalk[workloadColor](workloadLevel)} (${taskCount} tasks, ${totalHours}h)`);
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow handoffs failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowValidate(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();

    console.log(chalk.cyan('🔍 Validating Workflow State'));
    console.log(chalk.gray('='.repeat(50)));
    
    const validation = await stateManager.validateState();
    
    console.log(chalk.white('Valid:'), validation.isValid ? chalk.green('✓') : chalk.red('✗'));
    console.log(chalk.white('Validation Time:'), chalk.cyan(`${validation.performance.total}ms`));
    
    if (validation.statistics) {
      console.log(chalk.blue('\nStatistics:'));
      console.log(chalk.gray(`  Total Assignments: ${validation.statistics.total_assignments}`));
      console.log(chalk.gray(`  Total Specs: ${validation.statistics.total_specs}`));
      console.log(chalk.gray(`  Ready Handoffs: ${validation.statistics.ready_handoffs}`));
    }
    
    if (validation.errors && validation.errors.length > 0) {
      console.log(chalk.red('\nErrors:'));
      validation.errors.forEach(error => {
        console.log(chalk.red(`  • ${error}`));
      });
    }
    
    if (validation.warnings && validation.warnings.length > 0) {
      console.log(chalk.yellow('\nWarnings:'));
      validation.warnings.forEach(warning => {
        console.log(chalk.yellow(`  • ${warning}`));
      });
    }
    
    if (validation.isValid) {
      console.log(chalk.green('\n✅ Workflow state validation passed!'));
    } else {
      console.log(chalk.red('\n❌ Workflow state validation failed'));
      if (options.fix) {
        console.log(chalk.yellow('🔧 Automatic fixing not yet implemented'));
      }
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow validation failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowDashboard(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const progress = await stateManager.getProjectProgress();
    const assignments = await stateManager.getCurrentAssignments();
    const handoffStatus = await stateManager.getHandoffStatus();
    const specs = specParser.getSpecs();

    console.log(chalk.cyan('📊 ASD Workflow Dashboard'));
    console.log(chalk.gray('='.repeat(70)));
    
    // Overall project health at a glance
    const overallPercentage = Math.round(progress.overall.completion_percentage || 0);
    const overallBar = ui.createProgressBar(overallPercentage, options.compact ? 15 : 25);
    
    console.log(chalk.white('\n🎯 Project Health:'));
    console.log(`  [${chalk[overallBar.percentageColor](overallBar.filled)}${chalk.gray(overallBar.empty)}] ${chalk[overallBar.percentageColor](overallBar.percentage)} Complete`);
    console.log(chalk.gray(`  ${progress.overall.completed_tasks}/${progress.overall.total_tasks} tasks | ${progress.overall.completed_specs}/${progress.overall.total_specs} specs | ${assignments.total_active_assignments} active`));

    // Critical items requiring attention
    const criticalSpecs = specs.filter(s => s.priority === 'P0' && s.status === 'active').slice(0, 3);
    if (criticalSpecs.length > 0) {
      console.log(chalk.red('\n🔥 Critical Items:'));
      for (const spec of criticalSpecs) {
        const specProgress = progress.by_spec[spec.id];
        const percentage = Math.round(specProgress?.completion_percentage || 0);
        const progressBar = ui.createProgressBar(percentage, 10);
        
        console.log(`  ${ui.getPriorityIcon(spec.priority)} ${chalk.yellow(spec.id)} [${chalk[progressBar.percentageColor](progressBar.filled)}${chalk.gray(progressBar.empty)}] ${chalk.white(ui.formatFeatureTitle(spec.title, 40))}`);
      }
    }

    // Active work summary
    if (assignments.total_active_assignments > 0) {
      console.log(chalk.blue('\n🔄 Active Work:'));
      const activeByAgent = {};
      
      for (const assignment of assignments.current_assignments) {
        if (!activeByAgent[assignment.assigned_agent]) {
          activeByAgent[assignment.assigned_agent] = [];
        }
        activeByAgent[assignment.assigned_agent].push(assignment);
      }
      
      for (const [agent, agentAssignments] of Object.entries(activeByAgent)) {
        const taskCount = agentAssignments.length;
        const highPriorityTasks = agentAssignments.filter(a => a.priority === 'P0' || a.priority === 'P1').length;
        
        console.log(`  👤 ${chalk.cyan(agent)} - ${chalk.white(taskCount)} tasks${highPriorityTasks > 0 ? ` (${chalk.red(highPriorityTasks + ' high priority')})` : ''}`);
        
        if (!options.compact) {
          for (const assignment of agentAssignments.slice(0, 2)) {
            const priorityIcon = ui.getPriorityIcon(assignment.priority);
            console.log(`     ${priorityIcon} ${chalk.gray(assignment.spec_id + ':' + assignment.task_id)}`);
          }
        }
      }
    }

    // Ready handoffs
    if (handoffStatus.ready_handoffs.length > 0) {
      console.log(chalk.yellow('\n🔄 Ready Handoffs:'));
      for (const handoff of handoffStatus.ready_handoffs.slice(0, options.compact ? 2 : 5)) {
        const timeReady = ui.formatDate(handoff.ready_at);
        console.log(`  📤 ${chalk.yellow(handoff.spec_id)}:${chalk.cyan(handoff.to_task)} → ${chalk.white(handoff.next_agent)} (${chalk.gray('ready ' + timeReady)})`);
      }
    }

    // Phase progress summary
    if (!options.compact && progress.by_phase && Object.keys(progress.by_phase).length > 0) {
      console.log(chalk.blue('\n📊 Phase Progress:'));
      for (const [phase, phaseData] of Object.entries(progress.by_phase)) {
        const phasePercentage = Math.round(phaseData.completion_percentage || 0);
        const phaseBar = ui.createProgressBar(phasePercentage, 12);
        console.log(`  ${chalk.cyan(phase.padEnd(12))} [${chalk[phaseBar.percentageColor](phaseBar.filled)}${chalk.gray(phaseBar.empty)}] ${chalk[phaseBar.percentageColor](phaseBar.percentage)} (${phaseData.completed_specs}/${phaseData.specs})`);
      }
    }

    // Velocity metrics if requested
    if (options.velocity) {
      console.log(chalk.magenta('\n📈 Velocity Metrics:'));
      const completedToday = assignments.assignment_history.filter(h => 
        h.action === 'completed' && 
        new Date(h.completed_at) > new Date(Date.now() - 24 * 60 * 60 * 1000)
      ).length;
      
      const completedThisWeek = assignments.assignment_history.filter(h => 
        h.action === 'completed' && 
        new Date(h.completed_at) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
      ).length;
      
      console.log(`  📅 Today: ${chalk.white(completedToday)} tasks completed`);
      console.log(`  📅 This Week: ${chalk.white(completedThisWeek)} tasks completed`);
      console.log(`  📅 Average: ${chalk.white(Math.round(completedThisWeek / 7 * 10) / 10)} tasks/day`);
    }

    // Agent performance if requested
    if (options.agents && Object.keys(assignments.agent_workloads).length > 0) {
      console.log(chalk.green('\n👥 Agent Performance:'));
      for (const [agent, workload] of Object.entries(assignments.agent_workloads)) {
        const avgHoursPerTask = workload.current_tasks > 0 ? Math.round(workload.total_hours / workload.current_tasks * 10) / 10 : 0;
        console.log(`  👤 ${chalk.cyan(agent)} - ${chalk.white(workload.current_tasks)} active tasks (${chalk.gray(avgHoursPerTask + 'h avg')})`);
      }
    }

    console.log(chalk.gray(`\n📊 Dashboard generated at ${new Date().toLocaleTimeString()}`));
    
  } catch (error) {
    console.error(chalk.red('❌ Workflow dashboard failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowMetrics(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const progress = await stateManager.getProjectProgress();
    const assignments = await stateManager.getCurrentAssignments();
    
    console.log(chalk.cyan('📈 Workflow Metrics & Analytics'));
    console.log(chalk.gray('='.repeat(70)));

    // Time period calculations
    const periodMs = {
      'day': 24 * 60 * 60 * 1000,
      'week': 7 * 24 * 60 * 60 * 1000,
      'month': 30 * 24 * 60 * 60 * 1000
    };
    
    const periodLength = periodMs[options.period] || periodMs.week;
    const periodStart = new Date(Date.now() - periodLength);
    
    // Completion metrics for the period
    const completedInPeriod = assignments.assignment_history.filter(h => 
      h.action === 'completed' && new Date(h.completed_at) > periodStart
    );
    
    const assignedInPeriod = assignments.assignment_history.filter(h => 
      h.action === 'assigned' && new Date(h.started_at) > periodStart
    );

    console.log(chalk.white(`\n📊 ${options.period.charAt(0).toUpperCase() + options.period.slice(1)} Metrics:`));
    console.log(chalk.white(`Tasks Completed: ${chalk.green(completedInPeriod.length)}`));
    console.log(chalk.white(`Tasks Started: ${chalk.blue(assignedInPeriod.length)}`));
    console.log(chalk.white(`Completion Rate: ${chalk.cyan(Math.round(completedInPeriod.length / Math.max(assignedInPeriod.length, 1) * 100) + '%')}`));

    // Agent productivity
    const agentMetrics = {};
    for (const task of completedInPeriod) {
      if (!agentMetrics[task.assigned_agent]) {
        agentMetrics[task.assigned_agent] = { completed: 0, totalHours: 0 };
      }
      agentMetrics[task.assigned_agent].completed++;
      agentMetrics[task.assigned_agent].totalHours += task.duration_hours || 0;
    }

    if (Object.keys(agentMetrics).length > 0) {
      console.log(chalk.blue('\n👥 Agent Performance:'));
      const sortedAgents = Object.entries(agentMetrics).sort((a, b) => b[1].completed - a[1].completed);
      
      for (const [agent, metrics] of sortedAgents) {
        const avgHours = metrics.completed > 0 ? Math.round(metrics.totalHours / metrics.completed * 10) / 10 : 0;
        console.log(`  👤 ${chalk.cyan(agent.padEnd(20))} ${chalk.white(metrics.completed)} completed | ${chalk.gray(avgHours + 'h avg')}`);
      }
    }

    // Priority breakdown
    const priorityBreakdown = { P0: 0, P1: 0, P2: 0, P3: 0 };
    for (const task of completedInPeriod) {
      priorityBreakdown[task.priority] = (priorityBreakdown[task.priority] || 0) + 1;
    }

    console.log(chalk.blue('\n🔥 Priority Breakdown:'));
    for (const [priority, count] of Object.entries(priorityBreakdown)) {
      if (count > 0) {
        const priorityIcon = ui.getPriorityIcon(priority);
        console.log(`  ${priorityIcon} ${priority}: ${chalk.white(count)} tasks`);
      }
    }

    // Velocity trend if requested
    if (options.velocity) {
      console.log(chalk.magenta('\n📈 Velocity Trend:'));
      const days = Math.ceil(periodLength / (24 * 60 * 60 * 1000));
      const dailyCompletions = Array(days).fill(0);
      
      for (const task of completedInPeriod) {
        const daysAgo = Math.floor((Date.now() - new Date(task.completed_at)) / (24 * 60 * 60 * 1000));
        if (daysAgo < days) {
          dailyCompletions[days - 1 - daysAgo]++;
        }
      }
      
      // Simple ASCII chart for last 7 days
      const maxDaily = Math.max(...dailyCompletions);
      if (maxDaily > 0) {
        for (let i = Math.max(0, days - 7); i < days; i++) {
          const barLength = Math.round((dailyCompletions[i] / maxDaily) * 10);
          const bar = '█'.repeat(barLength) + '░'.repeat(10 - barLength);
          const date = new Date(Date.now() - (days - 1 - i) * 24 * 60 * 60 * 1000);
          console.log(`  ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }).padEnd(6)} [${chalk.green(bar)}] ${dailyCompletions[i]}`);
        }
      }
    }

    // Export data if requested
    if (options.export) {
      const exportData = {
        period: options.period,
        generated_at: new Date().toISOString(),
        summary: {
          completed_tasks: completedInPeriod.length,
          started_tasks: assignedInPeriod.length,
          completion_rate: Math.round(completedInPeriod.length / Math.max(assignedInPeriod.length, 1) * 100)
        },
        agent_metrics: agentMetrics,
        priority_breakdown: priorityBreakdown,
        overall_progress: progress.overall
      };

      const fs = require('fs').promises;
      const filename = `asd-metrics-${options.period}-${new Date().toISOString().split('T')[0]}.${options.export}`;
      
      if (options.export === 'json') {
        await fs.writeFile(filename, JSON.stringify(exportData, null, 2));
      } else if (options.export === 'csv') {
        // Simple CSV export for completed tasks
        const csvLines = ['Date,Spec,Task,Agent,Priority,Duration'];
        for (const task of completedInPeriod) {
          const line = [
            new Date(task.completed_at).toISOString().split('T')[0],
            task.spec_id,
            task.task_id,
            task.assigned_agent,
            task.priority,
            task.duration_hours || 0
          ].join(',');
          csvLines.push(line);
        }
        await fs.writeFile(filename, csvLines.join('\n'));
      }
      
      console.log(chalk.green(`\n📁 Metrics exported to ${filename}`));
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow metrics failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowAssignments(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();
    
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const assignments = await stateManager.getCurrentAssignments();
    
    console.log(chalk.cyan('📋 Current Assignments'));
    console.log(chalk.gray('='.repeat(70)));

    if (assignments.current_assignments.length === 0) {
      console.log(chalk.yellow('⚠️  No current assignments'));
      return;
    }

    // Filter assignments
    let filteredAssignments = [...assignments.current_assignments];
    
    if (options.agent) {
      filteredAssignments = filteredAssignments.filter(a => a.assigned_agent === options.agent);
    }
    
    if (options.priority) {
      const priorities = options.priority.split(',');
      filteredAssignments = filteredAssignments.filter(a => priorities.includes(a.priority));
    }
    
    if (options.status) {
      const statuses = options.status.split(',');
      filteredAssignments = filteredAssignments.filter(a => statuses.includes(a.status));
    }

    // Sort assignments
    const sortOptions = {
      'priority': (a, b) => {
        const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3 };
        return (priorityOrder[a.priority] || 4) - (priorityOrder[b.priority] || 4);
      },
      'started': (a, b) => new Date(a.started_at) - new Date(b.started_at),
      'agent': (a, b) => a.assigned_agent.localeCompare(b.assigned_agent),
      'spec': (a, b) => a.spec_id.localeCompare(b.spec_id)
    };

    if (sortOptions[options.sort]) {
      filteredAssignments.sort(sortOptions[options.sort]);
    }

    console.log(chalk.white(`\n📊 Found ${filteredAssignments.length} assignments:\n`));

    // Display assignments
    for (const assignment of filteredAssignments) {
      const priorityIcon = ui.getPriorityIcon(assignment.priority);
      const statusIcon = assignment.status === 'completed' ? '✅' : 
                        assignment.status === 'in_progress' ? '🔄' : '⏳';
      const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 10) / 10;
      
      console.log(`${statusIcon} ${priorityIcon} ${chalk.yellow(assignment.spec_id)}:${chalk.cyan(assignment.task_id)}`);
      console.log(`   👤 ${chalk.white(assignment.assigned_agent)} | 📅 ${chalk.gray(ui.formatDate(assignment.started_at))} | ⏱️  ${chalk.cyan(duration + 'h')}`);
      
      if (assignment.estimated_hours) {
        const progressHours = Math.round((duration / assignment.estimated_hours) * 100);
        const timeBar = ui.createProgressBar(Math.min(progressHours, 100), 10);
        console.log(`   ⏱️  Progress: [${chalk[timeBar.barColor](timeBar.filled)}${chalk.gray(timeBar.empty)}] ${duration}h/${assignment.estimated_hours}h`);
      }
      
      if (assignment.completion_notes && assignment.status === 'completed') {
        const notes = assignment.completion_notes.substring(0, 80) + '...';
        console.log(`   📝 ${chalk.gray(notes)}`);
      }
      
      console.log();
    }

    // Timeline view
    if (options.timeline) {
      console.log(chalk.blue('📅 Assignment Timeline:'));
      console.log(chalk.gray('─'.repeat(50)));
      
      const timelineSorted = [...filteredAssignments].sort((a, b) => new Date(a.started_at) - new Date(b.started_at));
      
      for (const assignment of timelineSorted) {
        const startTime = new Date(assignment.started_at);
        const timeLabel = startTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
        const priorityIcon = ui.getPriorityIcon(assignment.priority);
        
        console.log(`  ${chalk.gray(timeLabel.padEnd(15))} ${priorityIcon} ${chalk.yellow(assignment.spec_id)}:${chalk.cyan(assignment.task_id)} → ${chalk.white(assignment.assigned_agent)}`);
      }
    }

  } catch (error) {
    console.error(chalk.red('❌ Workflow assignments failed:'), error.message);
    process.exit(1);
  }
}

// Handle CLI parsing
program.parse();

// If no command was specified and no arguments, show help
if (!process.argv.slice(2).length) {
  const options = program.opts();
  startASD(options);
}