#!/usr/bin/env node

const { Command } = require('commander');
const path = require('path');
const chalk = require('chalk');
const ASDClient = require('../lib/index');
const ConfigManager = require('../lib/config-manager');
const ContextInjector = require('../lib/context-injector');
const ContextManager = require('../lib/context-manager');
const ContextValidator = require('../lib/context-validator');
const ContextTriggerSystem = require('../lib/context-triggers');
const { TaskRecommendationAPI } = require('../lib/task-router');
const WorkflowStateManager = require('../lib/workflow-state-manager');
const HandoffAutomationEngine = require('../lib/handoff-automation-engine');
const DocumentationTemplateManager = require('../lib/documentation-template-manager');
const UIComponents = require('../lib/ui-components');

const program = new Command();

program
  .name('asd')
  .description('Agentic Spec Development (ASD) - AI-first terminal tool for specification development and project management')
  .version('0.1.0-alpha')
  .addHelpText('before', chalk.yellow('‚ö†Ô∏è  Pre-Production Software: Features may change before stable release\n'))
  .option('-c, --config <path>', 'Path to configuration file')
  .option('-p, --path <path>', 'Path to specs directory (overrides config)')
  .option('--no-auto-refresh', 'Disable automatic file watching and refresh')
  .option('--app-name <name>', 'Custom application name')
  .option('--app-icon <icon>', 'Custom application icon')
  .option('--debug', 'Enable debug output');

// Context management commands
const contextCommand = program
  .command('context')
  .description('Manage context files and injection system');

contextCommand
  .command('add')
  .description('Add content to context files')
  .option('--project', 'Add to project-level context')
  .option('--spec <spec-id>', 'Add to spec context')
  .option('--task <task-id>', 'Add to task context')
  .option('--constraint <text>', 'Add constraint')
  .option('--research <text>', 'Add research finding')
  .option('--decision <text>', 'Add implementation decision')
  .option('--content <text>', 'Add markdown content')
  .action(async (options) => {
    await handleContextAdd(options);
  });

contextCommand
  .command('update')
  .description('Update existing context files')
  .option('--spec <spec-id>', 'Update spec context')
  .option('--task <task-id>', 'Update task context')
  .option('--status <status>', 'Update status')
  .option('--progress <progress>', 'Update progress information')
  .option('--assign <agent-type>', 'Assign agent to task')
  .action(async (options) => {
    await handleContextUpdate(options);
  });

contextCommand
  .command('show')
  .description('Display context information')
  .option('--spec <spec-id>', 'Show spec context')
  .option('--task <task-id>', 'Show task context')
  .option('--agent <agent-type>', 'Show agent-specific context')
  .option('--inject', 'Show full injected context for agent')
  .option('--layers', 'Show all context layers')
  .action(async (options) => {
    await handleContextShow(options);
  });

contextCommand
  .command('validate')
  .description('Validate context files and system consistency')
  .option('--fix-issues', 'Attempt to fix validation issues')
  .option('--files <pattern>', 'Validate specific files (glob pattern)')
  .option('--verbose', 'Show detailed validation results')
  .action(async (options) => {
    await handleContextValidate(options);
  });

contextCommand
  .command('export')
  .description('Export context data for backup or sharing')
  .option('--output <path>', 'Output file path', './context-export.json')
  .option('--format <format>', 'Export format: json, csv, yaml, markdown', 'json')
  .option('--spec <spec-id>', 'Export specific spec context')
  .option('--include-state', 'Include dynamic state data')
  .option('--include-research', 'Include research findings')
  .option('--compress', 'Compress output for large exports')
  .action(async (options) => {
    await handleContextExport(options);
  });

contextCommand
  .command('import')
  .description('Import context data from backup')
  .argument('<file>', 'Context export file to import')
  .option('--merge', 'Merge with existing context (default: replace)')
  .option('--dry-run', 'Show what would be imported without making changes')
  .action(async (file, options) => {
    await handleContextImport(file, options);
  });

// Agent customization commands
const agentCommand = program
  .command('agent')
  .description('Manage agent definitions and customization');

agentCommand
  .command('customize')
  .description('Customize agent workflows and requirements')
  .argument('<agent-type>', 'Agent type to customize')
  .option('--add-step <step>', 'Add workflow step')
  .option('--add-requirement <req>', 'Add context requirement')
  .option('--add-capability <cap>', 'Add agent capability')
  .option('--remove-step <step>', 'Remove workflow step')
  .option('--edit', 'Open agent definition in editor')
  .action(async (agentType, options) => {
    await handleAgentCustomize(agentType, options);
  });

agentCommand
  .command('list')
  .description('List available agents and their capabilities')
  .option('--details', 'Show detailed agent information')
  .action(async (options) => {
    await handleAgentList(options);
  });

// Process management commands
const processCommand = program
  .command('process')
  .description('Manage process templates and workflows');

processCommand
  .command('update')
  .description('Update process templates')
  .argument('<template-name>', 'Process template to update')
  .option('--add-requirement <req>', 'Add validation requirement')
  .option('--add-step <step>', 'Add process step')
  .option('--edit', 'Open template in editor')
  .action(async (templateName, options) => {
    await handleProcessUpdate(templateName, options);
  });

processCommand
  .command('list')
  .description('List available process templates')
  .action(async () => {
    await handleProcessList();
  });

// Task routing and recommendation commands
program
  .command('next')
  .description('Get next recommended task for an agent')
  .requiredOption('--agent <agent-type>', 'Agent type (required)')
  .option('--priority <priorities>', 'Filter by priority (P0,P1,P2,P3)', 'P0,P1,P2,P3')
  .option('--phase <phases>', 'Filter by phase (PHASE-1A,PHASE-1B)', 'PHASE-1A,PHASE-1B')
  .option('--spec-status <status>', 'Filter by spec status (active,ready,backlog)', 'active,ready')
  .option('--show-alternatives', 'Show alternative task recommendations', false)
  .option('--show-reasoning', 'Show detailed recommendation reasoning', false)
  .option('--transparent', 'Show full scoring and constraint details', false)
  .option('--limit <number>', 'Maximum number of tasks to return', '5')
  .action(async (options) => {
    await handleNextTask(options);
  });

program
  .command('tasks')
  .description('Enhanced task listing with comprehensive filtering and output formats')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--priority <priorities>', 'Filter by priority (P0,P1,P2,P3)')
  .option('--phase <phases>', 'Filter by phase')
  .option('--spec <spec-ids>', 'Filter by specification IDs (comma-separated)')
  .option('--spec-status <status>', 'Filter by spec status (active,backlog,done)')
  .option('--status <status>', 'Filter by task status (ready,blocked,complete,in_progress)')
  .option('--include-blocked', 'Include blocked tasks', false)
  .option('--only-assigned', 'Show only assigned tasks')
  .option('--only-unassigned', 'Show only unassigned tasks')
  .option('--sort <sort>', 'Sort by: priority, created, agent, spec, status', 'priority')
  .option('--format <format>', 'Output format: table, json, csv, summary', 'table')
  .option('--limit <number>', 'Maximum number of tasks to return', '20')
  .option('--show-dependencies', 'Show task dependencies and blocking relationships')
  .option('--show-context', 'Show context requirements for each task')
  .action(async (options) => {
    await handleTasksListEnhanced(options);
  });

program
  .command('validate-assignment')
  .description('Validate if a task can be assigned to an agent')
  .requiredOption('--task <task-id>', 'Task ID to validate')
  .requiredOption('--agent <agent-type>', 'Agent type for assignment')
  .option('--show-details', 'Show detailed validation information', false)
  .action(async (options) => {
    await handleValidateAssignment(options);
  });

// Task lifecycle commands with context updates
program
  .command('assign')
  .description('Assign task to agent with context update and routing validation')
  .argument('<spec-id>', 'Specification ID')
  .argument('<task-id>', 'Task ID')
  .option('--agent <agent-type>', 'Agent type to assign')
  .option('--priority <priority>', 'Task priority (P0, P1, P2, P3)')
  .option('--validate', 'Validate assignment before applying', true)
  .action(async (specId, taskId, options) => {
    await handleTaskAssign(specId, taskId, options);
  });

program
  .command('complete')
  .description('Mark task as complete and update context')
  .argument('<spec-id>', 'Specification ID')
  .argument('<task-id>', 'Task ID')
  .option('--notes <notes>', 'Completion notes')
  .option('--handoff <next-task>', 'Next task to hand off to')
  .action(async (specId, taskId, options) => {
    await handleTaskComplete(specId, taskId, options);
  });

// Research management commands
const researchCommand = program
  .command('research')
  .description('Manage research findings and capture');

researchCommand
  .command('add')
  .description('Capture research findings and update context')
  .argument('<spec-id>', 'Specification ID')
  .option('--task <task-id>', 'Specific task ID')
  .option('--finding <text>', 'Research finding to record')
  .option('--source <source>', 'Source of research')
  .action(async (specId, options) => {
    await handleResearchCapture(specId, options);
  });

researchCommand
  .command('show')
  .description('Display research findings')
  .option('--spec <spec-id>', 'Show research for specific spec')
  .option('--task <task-id>', 'Show research for specific task')
  .option('--format <format>', 'Output format: table, json, summary', 'summary')
  .option('--recent <days>', 'Show research from last N days', '30')
  .action(async (options) => {
    await handleResearchShow(options);
  });

// Project-level export/import commands for complete data portability
program
  .command('export-project')
  .description('Export complete project data with all specs, context, and state')
  .option('--output <path>', 'Output file path', './project-export')
  .option('--format <format>', 'Export format: json, tar, zip', 'json')
  .option('--include-state', 'Include dynamic state files', true)
  .option('--include-context', 'Include all context files', true)
  .option('--include-research', 'Include research findings', true)
  .option('--exclude-drafts', 'Exclude draft specifications')
  .option('--compress', 'Compress output for large projects')
  .action(async (options) => {
    await handleProjectExport(options);
  });

program
  .command('import-project')
  .description('Import complete project data from backup')
  .argument('<file>', 'Project export file to import')
  .option('--merge', 'Merge with existing project (default: replace)')
  .option('--dry-run', 'Show what would be imported without making changes')
  .option('--validate', 'Validate imported data before applying', true)
  .action(async (file, options) => {
    await handleProjectImport(file, options);
  });

// Enhanced task management commands for FEAT-018 TASK-003
program
  .command('start')
  .description('Start a task with context injection')
  .argument('<task-id>', 'Task ID to start (SPEC-ID:TASK-ID or just TASK-ID)')
  .option('--spec <spec-id>', 'Specification ID (if not in task-id)')
  .option('--agent <agent-type>', 'Agent type starting the task')
  .option('--inject-context <levels>', 'Context levels to inject (spec,project,phase)', 'spec,project')
  .option('--dry-run', 'Show what context would be injected without starting')
  .action(async (taskId, options) => {
    await handleTaskStart(taskId, options);
  });

program
  .command('task-assign')
  .description('Alternative task assignment with flexible task ID format')
  .argument('<task-id>', 'Task ID (SPEC-ID:TASK-ID or just TASK-ID)')
  .requiredOption('--agent <agent-type>', 'Agent type to assign task to')
  .option('--spec <spec-id>', 'Specification ID (if not in task-id)')
  .option('--priority <priority>', 'Task priority (P0, P1, P2, P3)')
  .option('--validate', 'Validate assignment before applying', true)
  .option('--force', 'Force assignment even if validation warnings exist')
  .action(async (taskId, options) => {
    await handleTaskAssignFlexible(taskId, options);
  });

program
  .command('complete-task')
  .description('Mark task or subtask as complete with enhanced options')
  .argument('<task-id>', 'Task ID (SPEC-ID:TASK-ID or TASK-ID)')
  .option('--spec <spec-id>', 'Specification ID (if not in task-id)')
  .option('--type <type>', 'Completion type: task, subtask', 'task')
  .option('--subtask <subtask-id>', 'Subtask ID (for subtask completion)')
  .option('--notes <notes>', 'Completion notes')
  .option('--handoff <next-task>', 'Next task to hand off to')
  .option('--trigger-automation', 'Trigger automated handoff evaluation', true)
  .action(async (taskId, options) => {
    await handleTaskCompleteEnhanced(taskId, options);
  });

program
  .command('block')
  .description('Block a task with reason')
  .argument('<task-id>', 'Task ID to block (SPEC-ID:TASK-ID or TASK-ID)')
  .requiredOption('--reason <reason>', 'Reason for blocking the task')
  .option('--spec <spec-id>', 'Specification ID (if not in task-id)')
  .option('--until <date>', 'Block until specific date (YYYY-MM-DD)')
  .option('--depends-on <task-ids>', 'Comma-separated list of tasks this depends on')
  .action(async (taskId, options) => {
    await handleTaskBlock(taskId, options);
  });

program
  .command('unblock')
  .description('Unblock a previously blocked task')
  .argument('<task-id>', 'Task ID to unblock (SPEC-ID:TASK-ID or TASK-ID)')
  .option('--spec <spec-id>', 'Specification ID (if not in task-id)')
  .option('--notes <notes>', 'Notes about unblocking')
  .action(async (taskId, options) => {
    await handleTaskUnblock(taskId, options);
  });

program
  .command('task-deps')
  .description('Manage task dependencies')
  .argument('<action>', 'Action: add, remove, list')
  .argument('<task-id>', 'Task ID (SPEC-ID:TASK-ID or TASK-ID)')
  .option('--spec <spec-id>', 'Specification ID (if not in task-id)')
  .option('--depends-on <task-ids>', 'Comma-separated list of dependency task IDs')
  .option('--blocks <task-ids>', 'Comma-separated list of task IDs this blocks')
  .action(async (action, taskId, options) => {
    await handleTaskDependencies(action, taskId, options);
  });

// Workflow state management commands
const workflowCommand = program
  .command('workflow')
  .description('Manage workflow state and progress tracking');

workflowCommand
  .command('status')
  .description('Show current workflow status and assignments with rich visualizations')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--verbose', 'Show detailed status information')
  .option('--visual', 'Show rich status visualizations')
  .option('--workload', 'Display agent workload summary')
  .option('--timeline', 'Show task timeline view')
  .action(async (options) => {
    await handleWorkflowStatus(options);
  });

workflowCommand
  .command('progress')
  .description('Show project progress breakdown with visualizations')
  .option('--spec <spec-id>', 'Show progress for specific spec')
  .option('--phase <phase>', 'Filter by phase')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--detailed', 'Show detailed progress breakdown')
  .option('--visual', 'Show rich progress visualizations')
  .option('--bars', 'Display progress bars')
  .option('--sort <sort>', 'Sort by: completion, priority, phase, recent', 'completion')
  .action(async (options) => {
    await handleWorkflowProgress(options);
  });

workflowCommand
  .command('handoffs')
  .description('Show ready handoffs and handoff history with visualizations')
  .option('--ready-only', 'Show only ready handoffs')
  .option('--history', 'Show handoff history')
  .option('--visual', 'Show rich handoff visualizations')
  .option('--timeline', 'Show handoff timeline')
  .action(async (options) => {
    await handleWorkflowHandoffs(options);
  });

workflowCommand
  .command('validate')
  .description('Validate workflow state consistency')
  .option('--fix', 'Attempt to fix consistency issues')
  .action(async (options) => {
    await handleWorkflowValidate(options);
  });

workflowCommand
  .command('dashboard')
  .description('Show comprehensive progress dashboard')
  .option('--compact', 'Show compact dashboard view')
  .option('--velocity', 'Include velocity metrics')
  .option('--agents', 'Show agent performance breakdown')
  .action(async (options) => {
    await handleWorkflowDashboard(options);
  });

workflowCommand
  .command('metrics')
  .description('Show detailed workflow metrics and analytics')
  .option('--period <period>', 'Time period: day, week, month', 'week')
  .option('--export <format>', 'Export format: json, csv')
  .option('--velocity', 'Show velocity trends')
  .action(async (options) => {
    await handleWorkflowMetrics(options);
  });

workflowCommand
  .command('assignments')
  .description('Show current assignments with rich details')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--priority <priority>', 'Filter by priority (P0,P1,P2,P3)')
  .option('--status <status>', 'Filter by status (in_progress,completed)')
  .option('--sort <sort>', 'Sort by: priority, started, agent, spec', 'priority')
  .option('--timeline', 'Show assignment timeline')
  .action(async (options) => {
    await handleWorkflowAssignments(options);
  });

// Handoff automation commands
workflowCommand
  .command('handoff')
  .description('Manage automated agent handoffs')
  .command('trigger')
  .description('Trigger manual handoff for a task')
  .argument('<spec-id>', 'Specification ID')
  .argument('<task-id>', 'Task ID to hand off')
  .argument('<to-agent>', 'Target agent type')
  .option('--from-agent <agent>', 'Source agent type')
  .option('--reason <reason>', 'Reason for handoff')
  .option('--next-task <task-id>', 'Specific next task (optional)')
  .action(async (specId, taskId, toAgent, options) => {
    await handleHandoffTrigger(specId, taskId, toAgent, options);
  });

workflowCommand
  .command('handoff-status')
  .description('Show handoff automation system status')
  .option('--active', 'Show active handoffs only')
  .option('--history', 'Show handoff history')
  .option('--health', 'Show system health status')
  .option('--performance', 'Show performance metrics')
  .action(async (options) => {
    await handleHandoffStatus(options);
  });

workflowCommand
  .command('complete-task')
  .description('Complete task and trigger automatic handoff')
  .argument('<spec-id>', 'Specification ID')
  .argument('<task-id>', 'Task ID to complete')
  .option('--notes <notes>', 'Completion notes')
  .option('--handoff', 'Force handoff evaluation')
  .action(async (specId, taskId, options) => {
    await handleCompleteTaskWithHandoff(specId, taskId, options);
  });

// Documentation template management commands
const reportCommand = program
  .command('report')
  .description('Manage structured temporary documentation with automatic lifecycle management');

reportCommand
  .command('create')
  .description('Create a new report from template')
  .argument('<type>', 'Report type: analysis, findings, recommendations, handoff, audit')
  .argument('<title>', 'Report title')
  .argument('<spec-id>', 'Associated specification ID')
  .option('--task-id <task-id>', 'Associated task ID')
  .option('--agent <agent-type>', 'Agent type creating the report', 'software-architect')
  .option('--context <json>', 'Additional context data as JSON')
  .option('--metadata <json>', 'Additional metadata as JSON')
  .action(async (type, title, specId, options) => {
    await handleReportCreate(type, title, specId, options);
  });

reportCommand
  .command('list')
  .description('List reports with filtering options')
  .option('--type <type>', 'Filter by report type')
  .option('--spec <spec-id>', 'Filter by specification ID')
  .option('--task <task-id>', 'Filter by task ID')
  .option('--agent <agent-type>', 'Filter by agent type')
  .option('--status <status>', 'Filter by status (active, archived)')
  .option('--sort <field>', 'Sort by field: createdAt, title, type', 'createdAt')
  .option('--order <order>', 'Sort order: asc, desc', 'desc')
  .option('--limit <n>', 'Maximum number of reports to show', '20')
  .option('--verbose', 'Show detailed report information')
  .action(async (options) => {
    await handleReportList(options);
  });

reportCommand
  .command('show')
  .description('Show report content and metadata')
  .argument('<report-id>', 'Report ID to show')
  .option('--metadata-only', 'Show only metadata, not content')
  .action(async (reportId, options) => {
    await handleReportShow(reportId, options);
  });

reportCommand
  .command('update')
  .description('Update existing report')
  .argument('<report-id>', 'Report ID to update')
  .option('--content <content>', 'New content for the report')
  .option('--metadata <json>', 'Updated metadata as JSON')
  .option('--edit', 'Open report in editor')
  .action(async (reportId, options) => {
    await handleReportUpdate(reportId, options);
  });

reportCommand
  .command('cleanup')
  .description('Execute cleanup based on lifecycle rules')
  .option('--dry-run', 'Show what would be cleaned up without making changes')
  .option('--completed-tasks <task-ids>', 'Comma-separated list of completed task IDs')
  .option('--completed-specs <spec-ids>', 'Comma-separated list of completed spec IDs')
  .option('--force', 'Force cleanup regardless of retention rules')
  .option('--respect-retention', 'Only cleanup reports past retention time', true)
  .action(async (options) => {
    await handleReportCleanup(options);
  });

reportCommand
  .command('templates')
  .description('Manage report templates')
  .option('--list', 'List available templates')
  .option('--show <type>', 'Show template content for specific type')
  .option('--validate', 'Validate all templates')
  .action(async (options) => {
    await handleReportTemplates(options);
  });

reportCommand
  .command('stats')
  .description('Show documentation system statistics and health')
  .option('--detailed', 'Show detailed statistics')
  .option('--by-type', 'Group statistics by report type')
  .option('--by-agent', 'Group statistics by agent type')
  .option('--cleanup-preview', 'Show upcoming cleanup candidates')
  .action(async (options) => {
    await handleReportStats(options);
  });

program
  .command('init')
  .description('Initialize ASD in the current directory')
  .option('-t, --type <type>', 'Project type (spec, feature, mixed)', 'mixed')
  .action(async (_options) => {
    console.log(chalk.cyan('ü§ñ Initializing Agentic Spec Development...'));

    const configManager = new ConfigManager(process.cwd());
    const configPath = path.join(process.cwd(), 'asd.config.js');

    try {
      configManager.createExampleConfig(configPath);
      console.log(chalk.green(`‚úÖ Created configuration file: ${configPath}`));

      // Create default directory structure
      const fs = require('fs').promises;
      const specsPath = path.join(process.cwd(), 'docs/specs');

      await fs.mkdir(path.join(specsPath, 'active'), { recursive: true });
      await fs.mkdir(path.join(specsPath, 'backlog'), { recursive: true });
      await fs.mkdir(path.join(specsPath, 'done'), { recursive: true });
      await fs.mkdir(path.join(specsPath, 'template'), { recursive: true });

      console.log(chalk.green('‚úÖ Created directory structure:'));
      console.log(chalk.gray('   docs/specs/active/'));
      console.log(chalk.gray('   docs/specs/backlog/'));
      console.log(chalk.gray('   docs/specs/done/'));
      console.log(chalk.gray('   docs/specs/template/'));

      console.log(chalk.cyan('\nüöÄ ASD initialization complete!'));
      console.log(chalk.white('Run "asd" to start the terminal interface.'));

    } catch (error) {
      console.error(chalk.red('‚ùå Initialization failed:'), error.message);
      process.exit(1);
    }
  });

program
  .command('config')
  .description('Show current configuration')
  .action(() => {
    const configManager = new ConfigManager(process.cwd());
    const configInfo = configManager.getConfigInfo();

    console.log(chalk.cyan('ü§ñ ASD Configuration'));
    console.log(chalk.gray('='.repeat(50)));

    if (configInfo.configPath) {
      console.log(chalk.white('Config file:'), chalk.yellow(configInfo.configPath));
    } else {
      console.log(chalk.white('Config file:'), chalk.gray('Using defaults (no config file found)'));
    }

    console.log(chalk.white('Project root:'), chalk.yellow(configInfo.projectRoot));
    console.log(chalk.white('Specs path:'), chalk.yellow(configInfo.config.dataPath));
    console.log(chalk.white('Auto refresh:'), configInfo.config.autoRefresh ? chalk.green('enabled') : chalk.red('disabled'));
    console.log(chalk.white('Supported types:'), chalk.cyan(configInfo.config.supportedTypes.join(', ')));
    console.log(chalk.white('Status folders:'), chalk.cyan(configInfo.config.statusFolders.join(', ')));
  });

program
  .command('doctor')
  .description('Check ASD setup and configuration')
  .action(async () => {
    console.log(chalk.cyan('üîç ASD Health Check'));
    console.log(chalk.gray('='.repeat(50)));

    const configManager = new ConfigManager(process.cwd());
    const config = configManager.loadConfig();
    const fs = require('fs').promises;

    let allGood = true;

    // Check if specs directory exists
    try {
      await fs.access(config.dataPath);
      console.log(chalk.green('‚úÖ Specs directory exists:'), chalk.yellow(config.dataPath));
    } catch (error) {
      console.log(chalk.red('‚ùå Specs directory missing:'), chalk.yellow(config.dataPath));
      allGood = false;
    }

    // Check if status folders exist
    for (const folder of config.statusFolders) {
      const folderPath = path.join(config.dataPath, folder);
      try {
        await fs.access(folderPath);
        console.log(chalk.green('‚úÖ Status folder exists:'), chalk.gray(folder));
      } catch (error) {
        console.log(chalk.red('‚ùå Status folder missing:'), chalk.gray(folder));
        allGood = false;
      }
    }

    // Check for spec files
    let totalSpecs = 0;
    for (const folder of config.statusFolders) {
      const folderPath = path.join(config.dataPath, folder);
      try {
        const files = await fs.readdir(folderPath);
        const mdFiles = files.filter(file => file.endsWith('.md'));
        totalSpecs += mdFiles.length;
      } catch (error) {
        // Folder doesn't exist, already reported above
      }
    }

    if (totalSpecs > 0) {
      console.log(chalk.green(`‚úÖ Found ${totalSpecs} specification files`));
    } else {
      console.log(chalk.yellow('‚ö†Ô∏è  No specification files found'));
    }

    // Check dependencies
    try {
      require('terminal-kit');
      console.log(chalk.green('‚úÖ terminal-kit dependency available'));
    } catch (error) {
      console.log(chalk.red('‚ùå terminal-kit dependency missing'));
      allGood = false;
    }

    console.log(chalk.gray('='.repeat(50)));
    if (allGood) {
      console.log(chalk.green('üéâ All checks passed! ASD is ready to use.'));
    } else {
      console.log(chalk.red('‚ùå Some issues found. Run "asd init" to set up missing directories.'));
      process.exit(1);
    }
  });

// Default command - start the interactive terminal
// Feature management commands
const specCommand = program
  .command('spec')
  .description('Manage specifications and features');

specCommand
  .command('create')
  .description('Create a new specification or feature')
  .argument('<type>', 'Spec type: spec, feat, bug')
  .argument('<title>', 'Spec title')
  .option('--priority <priority>', 'Priority level (P0, P1, P2, P3)', 'P2')
  .option('--phase <phase>', 'Development phase', 'PHASE-1A')
  .option('--agent <agent-type>', 'Assign to agent type')
  .option('--template <template>', 'Use specific template')
  .action(async (type, title, options) => {
    await handleSpecCreate(type, title, options);
  });

specCommand
  .command('list')
  .description('List specifications with filtering and multiple output formats')
  .option('--status <status>', 'Filter by status (active, backlog, done)')
  .option('--priority <priority>', 'Filter by priority (P0,P1,P2,P3)')
  .option('--phase <phase>', 'Filter by phase')
  .option('--type <type>', 'Filter by type (FEAT, BUG, SPEC)')
  .option('--format <format>', 'Output format (table, json, csv, summary)', 'table')
  .option('--sort <field>', 'Sort by field (priority, title, status, created)', 'priority')
  .option('--limit <n>', 'Maximum number of specs to show', '20')
  .action(async (options) => {
    await handleSpecList(options);
  });

specCommand
  .command('show')
  .description('Display detailed information about a specification')
  .argument('<spec-id>', 'Specification ID to show')
  .option('--format <format>', 'Output format (detailed, summary, json)', 'detailed')
  .option('--include-tasks', 'Include task details', false)
  .option('--include-context', 'Include context information', false)
  .action(async (specId, options) => {
    await handleSpecShow(specId, options);
  });

specCommand
  .command('update')
  .description('Update specification fields')
  .argument('<spec-id>', 'Specification ID to update')
  .option('--status <status>', 'Update status')
  .option('--priority <priority>', 'Update priority (P0, P1, P2, P3)')
  .option('--phase <phase>', 'Update phase')
  .option('--title <title>', 'Update title')
  .option('--assign <agent-type>', 'Assign to agent type')
  .action(async (specId, options) => {
    await handleSpecUpdate(specId, options);
  });

specCommand
  .command('move')
  .description('Move specification to different status or phase')
  .argument('<spec-id>', 'Specification ID to move')
  .option('--to-status <status>', 'Move to status (active, backlog, done)')
  .option('--to-phase <phase>', 'Move to phase')
  .option('--validate-deps', 'Validate dependencies before moving', true)
  .action(async (specId, options) => {
    await handleSpecMove(specId, options);
  });

program
  .command('start')
  .description('Start the interactive ASD terminal interface (default)')
  .action(async () => {
    const options = program.opts();
    await startASD(options);
  });

// Handle when no command is specified (default to start)
program.action(async () => {
  const options = program.opts();
  await startASD(options);
});

// Handler functions for context commands
async function handleContextAdd(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Determine context type and ID
    let contextType, contextId;
    if (options.project) {
      contextType = 'project';
      contextId = null;
    } else if (options.spec) {
      contextType = 'spec';
      contextId = options.spec;
    } else if (options.task) {
      contextType = 'task';
      contextId = options.task;
    } else {
      console.error(chalk.red('‚ùå Must specify --project, --spec <id>, or --task <id>'));
      process.exit(1);
    }

    // Build updates object
    const updates = { frontmatter: {} };

    if (options.constraint) {
      updates.frontmatter.constraints = updates.frontmatter.constraints || [];
      updates.frontmatter.constraints.push(options.constraint);
    }

    if (options.research) {
      updates.frontmatter.research_findings = updates.frontmatter.research_findings || [];
      updates.frontmatter.research_findings.push({
        finding: options.research,
        timestamp: new Date().toISOString(),
        source: 'manual'
      });
    }

    if (options.decision) {
      updates.frontmatter.implementation_decisions = updates.frontmatter.implementation_decisions || [];
      updates.frontmatter.implementation_decisions.push({
        decision: options.decision,
        timestamp: new Date().toISOString(),
        rationale: 'user input'
      });
    }

    if (options.content) {
      updates.content = options.content;
    }

    if (Object.keys(updates.frontmatter).length === 0 && !updates.content) {
      console.error(chalk.red('‚ùå Must provide --constraint, --research, --decision, or --content'));
      process.exit(1);
    }

    // Update context and trigger system
    const success = await contextManager.updateContext(contextType, contextId, updates);

    if (success) {
      // Fire trigger for context addition
      await triggerSystem.fireTrigger('context_add', {
        contextType,
        contextId,
        updates,
        source: 'cli_command'
      });

      console.log(chalk.green(`‚úÖ Updated ${contextType} context${contextId ? ` for ${contextId}` : ''}`));
    } else {
      console.error(chalk.red('‚ùå Failed to update context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Context add failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextUpdate(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);

    // Determine what to update
    if (!options.spec && !options.task) {
      console.error(chalk.red('‚ùå Must specify --spec <id> or --task <id>'));
      process.exit(1);
    }

    const contextType = options.spec ? 'spec' : 'task';
    const contextId = options.spec || options.task;

    const updates = { frontmatter: {} };

    if (options.status) {
      updates.frontmatter.status = options.status;
    }

    if (options.progress) {
      updates.frontmatter.progress = JSON.parse(options.progress);
    }

    if (options.assign) {
      updates.frontmatter.assigned_agent = options.assign;
      updates.frontmatter.assigned_at = new Date().toISOString();
    }

    // Update context
    const success = await contextManager.updateContext(contextType, contextId, updates);

    if (success) {
      console.log(chalk.green(`‚úÖ Updated ${contextType} context for ${contextId}`));
    } else {
      console.error(chalk.red('‚ùå Failed to update context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Context update failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextShow(options) {
  try {
    const configManager = new ConfigManager(process.cwd());

    if (options.inject && options.agent) {
      // Show full injected context for agent
      const contextInjector = new ContextInjector(configManager);
      const injectedContext = await contextInjector.injectContext({
        agentType: options.agent,
        specId: options.spec,
        taskId: options.task
      });

      console.log(chalk.cyan('üîÑ Injected Context Preview'));
      console.log(chalk.gray('='.repeat(50)));

      if (options.layers) {
        console.log(JSON.stringify(injectedContext, null, 2));
      } else {
        // Show condensed view
        console.log(chalk.white('Agent:'), chalk.yellow(injectedContext.metadata.agentType));
        console.log(chalk.white('Layers:'), chalk.cyan(Object.keys(injectedContext.layers).join(', ')));
        console.log(chalk.white('Performance:'), chalk.green(`${injectedContext.metadata.performance.total}ms`));

        if (injectedContext.inheritance) {
          console.log(chalk.white('Inheritance:'), chalk.blue(injectedContext.inheritance.hierarchy.join(' ‚Üí ')));
        }

        if (injectedContext.relevanceScore) {
          console.log(chalk.white('Relevance:'), chalk.magenta(`${Math.round(injectedContext.relevanceScore * 100)}%`));
        }
      }
    } else if (options.spec || options.task) {
      // Show specific context
      const contextManager = new ContextManager(configManager);
      const contextType = options.spec ? 'spec' : 'task';
      const contextId = options.spec || options.task;

      const contextPath = contextType === 'spec'
        ? path.join(configManager.getProjectRoot(), '.asd', 'context', 'specs', `${contextId}-context.md`)
        : path.join(configManager.getProjectRoot(), '.asd', 'context', 'tasks', `${contextId}-context.md`);

      if (await contextManager.fileExists(contextPath)) {
        const fs = require('fs').promises;
        const content = await fs.readFile(contextPath, 'utf-8');
        console.log(chalk.cyan(`üìÑ ${contextType.charAt(0).toUpperCase() + contextType.slice(1)} Context: ${contextId}`));
        console.log(chalk.gray('='.repeat(50)));
        console.log(content);
      } else {
        console.log(chalk.yellow(`‚ö†Ô∏è  No ${contextType} context found for ${contextId}`));
      }
    } else {
      // Show general context info
      const contextManager = new ContextManager(configManager);
      const paths = contextManager.getContextPaths();

      console.log(chalk.cyan('üìã Context System Overview'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Base Directory:'), chalk.yellow(paths.base));
      console.log(chalk.white('Context Path:'), chalk.yellow(paths.context));
      console.log(chalk.white('Agents Path:'), chalk.yellow(paths.agents));
      console.log(chalk.white('Processes Path:'), chalk.yellow(paths.processes));
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Context show failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextValidate(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextValidator = new ContextValidator(configManager);

    if (options.files) {
      // Validate specific files using glob pattern
      const glob = require('glob');
      const filePaths = glob.sync(options.files);

      if (filePaths.length === 0) {
        console.log(chalk.yellow(`‚ö†Ô∏è  No files found matching pattern: ${options.files}`));
        return;
      }

      const summary = await contextValidator.validateContextFiles(filePaths);

      console.log(chalk.cyan('üîç Context Validation Results'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Total Files:'), chalk.blue(summary.totalFiles));
      console.log(chalk.white('Valid Files:'), chalk.green(summary.validFiles));
      console.log(chalk.white('Invalid Files:'), summary.invalidFiles > 0 ? chalk.red(summary.invalidFiles) : chalk.green(summary.invalidFiles));
      console.log(chalk.white('Warnings:'), summary.warnings > 0 ? chalk.yellow(summary.warnings) : chalk.green(summary.warnings));

      if (options.verbose) {
        summary.results.forEach(result => {
          console.log(chalk.gray('\n---'));
          console.log(chalk.white('File:'), result.filePath);
          console.log(chalk.white('Valid:'), result.isValid ? chalk.green('‚úì') : chalk.red('‚úó'));

          if (result.errors.length > 0) {
            console.log(chalk.red('Errors:'));
            result.errors.forEach(error => console.log(chalk.red(`  ‚Ä¢ ${error}`)));
          }

          if (result.warnings.length > 0) {
            console.log(chalk.yellow('Warnings:'));
            result.warnings.forEach(warning => console.log(chalk.yellow(`  ‚Ä¢ ${warning}`)));
          }
        });
      }
    } else {
      // Validate entire context system
      const glob = require('glob');
      const contextPaths = contextValidator.configManager.getProjectRoot();
      const allContextFiles = glob.sync(path.join(contextPaths, '.asd/**/*.md'));

      const summary = await contextValidator.validateContextFiles(allContextFiles);

      console.log(chalk.cyan('üîç Full Context System Validation'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Total Files:'), chalk.blue(summary.totalFiles));
      console.log(chalk.white('Valid Files:'), chalk.green(summary.validFiles));
      console.log(chalk.white('Invalid Files:'), summary.invalidFiles > 0 ? chalk.red(summary.invalidFiles) : chalk.green(summary.invalidFiles));
      console.log(chalk.white('Warnings:'), summary.warnings > 0 ? chalk.yellow(summary.warnings) : chalk.green(summary.warnings));

      if (summary.invalidFiles === 0 && summary.warnings === 0) {
        console.log(chalk.green('\n‚úÖ Context system validation passed!'));
      } else if (summary.invalidFiles === 0) {
        console.log(chalk.yellow('\n‚ö†Ô∏è  Context system validation passed with warnings'));
      } else {
        console.log(chalk.red('\n‚ùå Context system validation failed'));
        process.exit(1);
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Context validation failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextExport(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const paths = contextManager.getContextPaths();

    const exportData = {
      timestamp: new Date().toISOString(),
      version: '1.0.0',
      context: {},
      agents: {},
      processes: {}
    };

    // Export context files
    const glob = require('glob');
    const fs = require('fs').promises;

    const contextFiles = glob.sync(path.join(paths.context, '**/*.md'));
    for (const filePath of contextFiles) {
      const relativePath = path.relative(paths.context, filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      exportData.context[relativePath] = parsed;
    }

    // Export agent definitions
    const agentFiles = glob.sync(path.join(paths.agents, '*.md'));
    for (const filePath of agentFiles) {
      const filename = path.basename(filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      exportData.agents[filename] = parsed;
    }

    // Export process templates
    const processFiles = glob.sync(path.join(paths.processes, '*.md'));
    for (const filePath of processFiles) {
      const filename = path.basename(filePath);
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      exportData.processes[filename] = parsed;
    }

    // Include state if requested
    if (options.includeState) {
      const dynamicContext = await contextManager.loadDynamicContext();
      exportData.state = dynamicContext;
    }

    // Filter by spec if requested
    if (options.spec) {
      const specContext = exportData.context[`specs/${options.spec}-context.md`];
      exportData.context = specContext ? { [`specs/${options.spec}-context.md`]: specContext } : {};
    }

    // Include research if requested
    if (options.includeResearch) {
      exportData.research = [];
      for (const contextData of Object.values(exportData.context)) {
        if (contextData.research) {
          exportData.research.push(...contextData.research);
        }
      }
    }

    // Export based on format
    const outputPath = options.output;
    exportData.format = options.format;

    switch (options.format) {
      case 'json':
        await fs.writeFile(outputPath, JSON.stringify(exportData, null, 2), 'utf-8');
        console.log(chalk.green(`‚úÖ Context exported to ${outputPath}`));
        break;

      case 'csv': {
        // Convert to CSV format for context items
        const csvLines = ['Type,Path,Title,Status,Created,Modified'];

        // Add context files to CSV
        Object.entries(exportData.context).forEach(([path, data]) => {
          const row = [
            'context',
            path,
            data.frontmatter?.title || 'N/A',
            data.frontmatter?.status || 'N/A',
            data.frontmatter?.created || 'N/A',
            data.frontmatter?.modified || 'N/A'
          ].map(field => `'${field}'`).join(',');
          csvLines.push(row);
        });

        await fs.writeFile(outputPath.replace(/\.json$/, '.csv'), csvLines.join('\n'));
        console.log(chalk.green(`‚úÖ Context exported to CSV: ${outputPath.replace(/\.json$/, '.csv')}`));
        break;
      }

      case 'yaml':
        try {
          const yaml = require('js-yaml');
          const yamlContent = yaml.dump(exportData, { indent: 2 });
          await fs.writeFile(outputPath.replace(/\.json$/, '.yaml'), yamlContent);
          console.log(chalk.green(`‚úÖ Context exported to YAML: ${outputPath.replace(/\.json$/, '.yaml')}`));
        } catch (error) {
          console.warn(chalk.yellow('‚ö†Ô∏è  YAML export failed, falling back to JSON'));
          await fs.writeFile(outputPath, JSON.stringify(exportData, null, 2), 'utf-8');
          console.log(chalk.green(`‚úÖ Context exported to JSON: ${outputPath}`));
        }
        break;

      case 'markdown': {
        // Create markdown report
        let markdown = '# Context Export Report\n\n';
        markdown += `**Exported:** ${exportData.timestamp}\n\n`;

        markdown += `## Context Files (${Object.keys(exportData.context).length})\n\n`;
        Object.entries(exportData.context).forEach(([path, data]) => {
          markdown += `### ${path}\n`;
          if (data.frontmatter?.title) markdown += `**Title:** ${data.frontmatter.title}\n`;
          if (data.frontmatter?.status) markdown += `**Status:** ${data.frontmatter.status}\n`;
          markdown += '\n';
        });

        await fs.writeFile(outputPath.replace(/\.json$/, '.md'), markdown);
        console.log(chalk.green(`‚úÖ Context exported to Markdown: ${outputPath.replace(/\.json$/, '.md')}`));
        break;
      }

      default:
        await fs.writeFile(outputPath, JSON.stringify(exportData, null, 2), 'utf-8');
        console.log(chalk.green(`‚úÖ Context exported to ${outputPath}`));
    }

    console.log(chalk.gray(`   Context files: ${Object.keys(exportData.context).length}`));
    console.log(chalk.gray(`   Agent files: ${Object.keys(exportData.agents).length}`));
    console.log(chalk.gray(`   Process files: ${Object.keys(exportData.processes).length}`));
    if (options.includeState) {
      console.log(chalk.gray('   State data: included'));
    }
    if (options.includeResearch) {
      console.log(chalk.gray(`   Research items: ${exportData.research?.length || 0}`));
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Context export failed:'), error.message);
    process.exit(1);
  }
}

async function handleContextImport(file, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const paths = contextManager.getContextPaths();

    const fs = require('fs').promises;

    // Read import file
    const importData = JSON.parse(await fs.readFile(file, 'utf-8'));

    if (options.dryRun) {
      console.log(chalk.cyan('üîç Import Preview (Dry Run)'));
      console.log(chalk.gray('='.repeat(50)));
      console.log(chalk.white('Context files to import:'), chalk.blue(Object.keys(importData.context || {}).length));
      console.log(chalk.white('Agent files to import:'), chalk.blue(Object.keys(importData.agents || {}).length));
      console.log(chalk.white('Process files to import:'), chalk.blue(Object.keys(importData.processes || {}).length));

      if (importData.state) {
        console.log(chalk.white('State data:'), chalk.yellow('included'));
      }

      console.log(chalk.yellow('\nNo changes made (dry run)'));
      return;
    }

    // Ensure directories exist
    await contextManager.initializeContextStructure();

    let importedCount = 0;

    // Import context files
    for (const [relativePath, parsed] of Object.entries(importData.context || {})) {
      const fullPath = path.join(paths.context, relativePath);
      await fs.mkdir(path.dirname(fullPath), { recursive: true });

      const content = contextManager.serializeMarkdownWithFrontmatter(
        parsed.frontmatter || {},
        parsed.content || ''
      );

      await fs.writeFile(fullPath, content, 'utf-8');
      importedCount++;
    }

    // Import agent definitions
    for (const [filename, parsed] of Object.entries(importData.agents || {})) {
      const fullPath = path.join(paths.agents, filename);

      const content = contextManager.serializeMarkdownWithFrontmatter(
        parsed.frontmatter || {},
        parsed.content || ''
      );

      await fs.writeFile(fullPath, content, 'utf-8');
      importedCount++;
    }

    // Import process templates
    for (const [filename, parsed] of Object.entries(importData.processes || {})) {
      const fullPath = path.join(paths.processes, filename);

      const content = contextManager.serializeMarkdownWithFrontmatter(
        parsed.frontmatter || {},
        parsed.content || ''
      );

      await fs.writeFile(fullPath, content, 'utf-8');
      importedCount++;
    }

    // Import state if present
    if (importData.state) {
      const assignmentsPath = path.join(paths.state, 'assignments.json');
      const progressPath = path.join(paths.state, 'progress.json');

      if (importData.state.assignments) {
        await fs.writeFile(assignmentsPath, JSON.stringify(importData.state.assignments, null, 2), 'utf-8');
      }

      if (importData.state.progress) {
        await fs.writeFile(progressPath, JSON.stringify(importData.state.progress, null, 2), 'utf-8');
      }
    }

    console.log(chalk.green('‚úÖ Context import completed'));
    console.log(chalk.gray(`   Files imported: ${importedCount}`));
    console.log(chalk.gray(`   Source: ${file}`));

  } catch (error) {
    console.error(chalk.red('‚ùå Context import failed:'), error.message);
    process.exit(1);
  }
}

async function handleAgentCustomize(agentType, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const agentPath = path.join(configManager.getProjectRoot(), '.asd', 'agents', `${agentType}.md`);

    const fs = require('fs').promises;

    // Check if agent exists
    if (!(await fs.access(agentPath).then(() => true).catch(() => false))) {
      console.error(chalk.red(`‚ùå Agent definition not found: ${agentType}`));
      console.log(chalk.gray(`   Expected path: ${agentPath}`));
      process.exit(1);
    }

    if (options.edit) {
      // Open in editor
      const { spawn } = require('child_process');
      const editor = process.env.EDITOR || 'nano';

      const child = spawn(editor, [agentPath], {
        stdio: 'inherit'
      });

      child.on('exit', (code) => {
        if (code === 0) {
          console.log(chalk.green(`‚úÖ Agent definition updated: ${agentType}`));
        } else {
          console.error(chalk.red('‚ùå Editor exited with error'));
          process.exit(1);
        }
      });
    } else {
      // Programmatic updates
      const content = await fs.readFile(agentPath, 'utf-8');
      const contextManager = new ContextManager(configManager);
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);

      let updated = false;
      const frontmatter = parsed.frontmatter || {};

      if (options.addStep) {
        frontmatter.workflow_steps = frontmatter.workflow_steps || [];
        frontmatter.workflow_steps.push(options.addStep);
        updated = true;
      }

      if (options.removeStep) {
        if (frontmatter.workflow_steps) {
          const index = frontmatter.workflow_steps.indexOf(options.removeStep);
          if (index > -1) {
            frontmatter.workflow_steps.splice(index, 1);
            updated = true;
          }
        }
      }

      if (options.addRequirement) {
        frontmatter.context_requirements = frontmatter.context_requirements || [];
        frontmatter.context_requirements.push(options.addRequirement);
        updated = true;
      }

      if (options.addCapability) {
        frontmatter.capabilities = frontmatter.capabilities || [];
        frontmatter.capabilities.push(options.addCapability);
        updated = true;
      }

      if (updated) {
        const newContent = contextManager.serializeMarkdownWithFrontmatter(frontmatter, parsed.content);
        await fs.writeFile(agentPath, newContent, 'utf-8');
        console.log(chalk.green(`‚úÖ Agent definition updated: ${agentType}`));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è  No updates specified'));
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Agent customize failed:'), error.message);
    process.exit(1);
  }
}

async function handleAgentList(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const agentsPath = path.join(configManager.getProjectRoot(), '.asd', 'agents');

    const fs = require('fs').promises;
    const glob = require('glob');

    const agentFiles = glob.sync(path.join(agentsPath, '*.md'));

    console.log(chalk.cyan('üë• Available Agents'));
    console.log(chalk.gray('='.repeat(50)));

    if (agentFiles.length === 0) {
      console.log(chalk.yellow('‚ö†Ô∏è  No agent definitions found'));
      return;
    }

    const contextManager = new ContextManager(configManager);

    for (const filePath of agentFiles) {
      const agentType = path.basename(filePath, '.md');
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      const frontmatter = parsed.frontmatter || {};

      console.log(chalk.white('\n‚Ä¢ Agent:'), chalk.yellow(agentType));

      if (options.details) {
        if (frontmatter.capabilities) {
          console.log(chalk.gray('  Capabilities:'), frontmatter.capabilities.slice(0, 3).join(', '));
        }
        if (frontmatter.specialization_areas) {
          console.log(chalk.gray('  Specializations:'), frontmatter.specialization_areas.slice(0, 3).join(', '));
        }
        if (frontmatter.context_requirements) {
          console.log(chalk.gray('  Context Needs:'), frontmatter.context_requirements.slice(0, 2).join(', '));
        }
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Agent list failed:'), error.message);
    process.exit(1);
  }
}

async function handleProcessUpdate(templateName, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const processPath = path.join(configManager.getProjectRoot(), '.asd', 'processes', `${templateName}.md`);

    const fs = require('fs').promises;

    if (options.edit) {
      // Open in editor
      const { spawn } = require('child_process');
      const editor = process.env.EDITOR || 'nano';

      const child = spawn(editor, [processPath], {
        stdio: 'inherit'
      });

      child.on('exit', (code) => {
        if (code === 0) {
          console.log(chalk.green(`‚úÖ Process template updated: ${templateName}`));
        } else {
          console.error(chalk.red('‚ùå Editor exited with error'));
          process.exit(1);
        }
      });
    } else {
      // Programmatic updates
      let content, parsed;

      try {
        content = await fs.readFile(processPath, 'utf-8');
        const contextManager = new ContextManager(configManager);
        parsed = contextManager.parseMarkdownWithFrontmatter(content);
      } catch (error) {
        // File doesn't exist, create new
        parsed = { frontmatter: {}, content: '' };
      }

      let updated = false;
      const frontmatter = parsed.frontmatter || {};

      if (options.addRequirement) {
        frontmatter.validation_requirements = frontmatter.validation_requirements || [];
        frontmatter.validation_requirements.push(options.addRequirement);
        updated = true;
      }

      if (options.addStep) {
        frontmatter.process_steps = frontmatter.process_steps || [];
        frontmatter.process_steps.push(options.addStep);
        updated = true;
      }

      if (updated) {
        const contextManager = new ContextManager(configManager);
        const newContent = contextManager.serializeMarkdownWithFrontmatter(frontmatter, parsed.content);
        await fs.writeFile(processPath, newContent, 'utf-8');
        console.log(chalk.green(`‚úÖ Process template updated: ${templateName}`));
      } else {
        console.log(chalk.yellow('‚ö†Ô∏è  No updates specified'));
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Process update failed:'), error.message);
    process.exit(1);
  }
}

async function handleProcessList() {
  try {
    const configManager = new ConfigManager(process.cwd());
    const processesPath = path.join(configManager.getProjectRoot(), '.asd', 'processes');

    const fs = require('fs').promises;
    const glob = require('glob');

    const processFiles = glob.sync(path.join(processesPath, '*.md'));

    console.log(chalk.cyan('üìã Available Process Templates'));
    console.log(chalk.gray('='.repeat(50)));

    if (processFiles.length === 0) {
      console.log(chalk.yellow('‚ö†Ô∏è  No process templates found'));
      return;
    }

    const contextManager = new ContextManager(configManager);

    for (const filePath of processFiles) {
      const templateName = path.basename(filePath, '.md');
      const content = await fs.readFile(filePath, 'utf-8');
      const parsed = contextManager.parseMarkdownWithFrontmatter(content);
      const frontmatter = parsed.frontmatter || {};

      console.log(chalk.white('‚Ä¢ Template:'), chalk.yellow(templateName));

      if (frontmatter.process_type) {
        console.log(chalk.gray('  Type:'), frontmatter.process_type);
      }

      if (frontmatter.validation_requirements && frontmatter.validation_requirements.length > 0) {
        console.log(chalk.gray('  Requirements:'), frontmatter.validation_requirements.length);
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Process list failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskAssign(specId, taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    if (!options.agent) {
      console.error(chalk.red('‚ùå Must specify --agent <agent-type>'));
      process.exit(1);
    }

    // Validate assignment using routing system if requested
    if (options.validate !== false) {
      console.log(chalk.blue('üîç Validating assignment...'));

      const taskAPI = new TaskRecommendationAPI(configManager);
      const initialized = await taskAPI.initialize();

      if (initialized) {
        const validation = await taskAPI.validateAssignment({
          taskId: taskId,
          agentType: options.agent
        });

        if (validation.success && !validation.valid) {
          console.error(chalk.red('‚ùå Assignment validation failed:'));
          validation.issues.forEach(issue => {
            console.error(chalk.red(`  ‚Ä¢ ${issue}`));
          });

          if (validation.warnings && validation.warnings.length > 0) {
            console.warn(chalk.yellow('‚ö†Ô∏è  Warnings:'));
            validation.warnings.forEach(warning => {
              console.warn(chalk.yellow(`  ‚Ä¢ ${warning}`));
            });
          }

          console.log(chalk.gray('\nüí° Use --no-validate to skip validation'));
          process.exit(1);
        } else if (validation.success) {
          console.log(chalk.green('‚úÖ Assignment validation passed'));

          if (validation.warnings && validation.warnings.length > 0) {
            console.warn(chalk.yellow('‚ö†Ô∏è  Validation warnings:'));
            validation.warnings.forEach(warning => {
              console.warn(chalk.yellow(`  ‚Ä¢ ${warning}`));
            });
          }
        } else {
          console.warn(chalk.yellow('‚ö†Ô∏è  Could not validate assignment, proceeding anyway'));
        }
      } else {
        console.warn(chalk.yellow('‚ö†Ô∏è  Task routing system unavailable, skipping validation'));
      }
    }

    // Update task context with assignment
    const updates = {
      frontmatter: {
        assigned_agent: options.agent,
        assigned_at: new Date().toISOString(),
        status: 'in_progress'
      }
    };

    if (options.priority) {
      updates.frontmatter.priority = options.priority;
    }

    // Update task context
    const taskSuccess = await contextManager.updateContext('task', taskId, updates);

    // Update dynamic state (assignments.json)
    const paths = contextManager.getContextPaths();
    const assignmentsPath = path.join(paths.state, 'assignments.json');

    const fs = require('fs').promises;
    let assignments = {};

    try {
      if (await contextManager.fileExists(assignmentsPath)) {
        const assignmentsContent = await fs.readFile(assignmentsPath, 'utf-8');
        assignments = JSON.parse(assignmentsContent);
      }
    } catch (error) {
      // Start fresh if file is corrupted
    }

    // Update assignments
    assignments[specId] = assignments[specId] || {};
    assignments[specId][taskId] = {
      agent: options.agent,
      assigned_at: new Date().toISOString(),
      priority: options.priority || 'P2',
      status: 'in_progress'
    };

    // Ensure state directory exists
    await fs.mkdir(paths.state, { recursive: true });
    await fs.writeFile(assignmentsPath, JSON.stringify(assignments, null, 2), 'utf-8');

    if (taskSuccess) {
      // Fire trigger for task assignment
      await triggerSystem.fireTrigger('assign', {
        specId,
        taskId,
        agentType: options.agent,
        priority: options.priority || 'P2',
        source: 'cli_command'
      });

      console.log(chalk.green(`‚úÖ Assigned ${taskId} to ${options.agent}`));
      console.log(chalk.gray(`   Spec: ${specId}`));
      console.log(chalk.gray(`   Priority: ${options.priority || 'P2'}`));
    } else {
      console.error(chalk.red('‚ùå Failed to update task context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Task assignment failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskComplete(specId, taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Update task context with completion
    const updates = {
      frontmatter: {
        status: 'completed',
        completed_at: new Date().toISOString()
      }
    };

    if (options.notes) {
      updates.frontmatter.completion_notes = options.notes;
    }

    if (options.handoff) {
      updates.frontmatter.handoff_to = options.handoff;
    }

    // Update task context
    const taskSuccess = await contextManager.updateContext('task', taskId, updates);

    // Update progress tracking
    const paths = contextManager.getContextPaths();
    const progressPath = path.join(paths.state, 'progress.json');

    const fs = require('fs').promises;
    let progress = {};

    try {
      if (await contextManager.fileExists(progressPath)) {
        const progressContent = await fs.readFile(progressPath, 'utf-8');
        progress = JSON.parse(progressContent);
      }
    } catch (error) {
      // Start fresh if file is corrupted
    }

    // Update progress
    progress[specId] = progress[specId] || {};
    progress[specId][taskId] = {
      status: 'completed',
      completed_at: new Date().toISOString(),
      completion_notes: options.notes || null
    };

    // Ensure state directory exists
    await fs.mkdir(paths.state, { recursive: true });
    await fs.writeFile(progressPath, JSON.stringify(progress, null, 2), 'utf-8');

    if (taskSuccess) {
      // Fire trigger for task completion
      await triggerSystem.fireTrigger('complete', {
        specId,
        taskId,
        completionNotes: options.notes,
        handoffTo: options.handoff,
        source: 'cli_command'
      });

      console.log(chalk.green(`‚úÖ Marked ${taskId} as complete`));
      console.log(chalk.gray(`   Spec: ${specId}`));
      if (options.notes) {
        console.log(chalk.gray(`   Notes: ${options.notes}`));
      }
      if (options.handoff) {
        console.log(chalk.yellow(`   üîÑ Handoff to: ${options.handoff}`));
      }
    } else {
      console.error(chalk.red('‚ùå Failed to update task context'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Task completion failed:'), error.message);
    process.exit(1);
  }
}

async function handleResearchCapture(specId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    if (!options.finding) {
      console.error(chalk.red('‚ùå Must specify --finding <text>'));
      process.exit(1);
    }

    const contextType = options.task ? 'task' : 'spec';
    const contextId = options.task || specId;

    // Create research finding object
    const researchFinding = {
      finding: options.finding,
      timestamp: new Date().toISOString(),
      source: options.source || 'manual',
      context: contextType === 'task' ? `${specId}:${options.task}` : specId
    };

    // Update context with research finding
    const updates = {
      frontmatter: {
        research_findings: [researchFinding]
      }
    };

    const success = await contextManager.updateContext(contextType, contextId, updates);

    if (success) {
      // Fire trigger for research capture
      await triggerSystem.fireTrigger('research', {
        specId,
        taskId: options.task,
        finding: options.finding,
        source: options.source,
        contextType,
        contextId
      });

      console.log(chalk.green(`‚úÖ Research finding captured for ${contextType} ${contextId}`));
      console.log(chalk.gray(`   Finding: ${options.finding.slice(0, 80)}${options.finding.length > 80 ? '...' : ''}`));
      if (options.source) {
        console.log(chalk.gray(`   Source: ${options.source}`));
      }
    } else {
      console.error(chalk.red('‚ùå Failed to capture research finding'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Research capture failed:'), error.message);
    process.exit(1);
  }
}

async function startASD(options) {
  try {
    // Prepare configuration
    const configOptions = {
      cwd: process.cwd(),
      configPath: options.config,
      appName: options.appName,
      appIcon: options.appIcon,
    };

    if (options.path) {
      configOptions.featuresPath = options.path;
    }

    if (options.noAutoRefresh) {
      configOptions.autoRefresh = false;
    }

    if (options.debug) {
      process.env.DEBUG_STARTUP = 'true';
      process.env.DEBUG_LAYOUT = 'true';
    }

    // Create and start ASD client
    const asd = new ASDClient(configOptions);
    await asd.init();

  } catch (error) {
    console.error(chalk.red('‚ùå Failed to start ASD:'), error.message);

    if (options.debug) {
      console.error(chalk.gray('Stack trace:'), error.stack);
    }

    process.exit(1);
  }
}

// Handler functions for task routing commands
async function handleNextTask(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const taskAPI = new TaskRecommendationAPI(configManager);

    // Initialize the API
    const initialized = await taskAPI.initialize();
    if (!initialized) {
      console.error(chalk.red('‚ùå Failed to initialize task routing system'));
      process.exit(1);
    }

    // Parse filter options
    const priority = options.priority ? options.priority.split(',') : undefined;
    const phase = options.phase ? options.phase.split(',') : undefined;
    const specStatus = options.specStatus ? options.specStatus.split(',') : undefined;

    // Use transparent API if requested
    if (options.transparent) {
      const result = await taskAPI.getTransparentRecommendation({
        agentType: options.agent,
        filters: { priority, phase, specStatus }
      });

      if (!result.success) {
        console.error(chalk.red('‚ùå Task recommendation failed:'), result.error);
        process.exit(1);
      }

      displayTransparentRecommendation(result);
      return;
    }

    // Get task recommendation
    const result = await taskAPI.getNextTask({
      agentType: options.agent,
      priority,
      phase,
      specStatus,
      includeReasoning: options.showReasoning,
      includeAlternatives: options.showAlternatives
    });

    if (!result.success) {
      console.error(chalk.red('‚ùå Task recommendation failed:'), result.error);
      process.exit(1);
    }

    displayTaskRecommendation(result, options);

  } catch (error) {
    console.error(chalk.red('‚ùå Next task command failed:'), error.message);
    process.exit(1);
  }
}


async function handleValidateAssignment(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const taskAPI = new TaskRecommendationAPI(configManager);

    const initialized = await taskAPI.initialize();
    if (!initialized) {
      console.error(chalk.red('‚ùå Failed to initialize task routing system'));
      process.exit(1);
    }

    const result = await taskAPI.validateAssignment({
      taskId: options.task,
      agentType: options.agent
    });

    if (!result.success) {
      console.error(chalk.red('‚ùå Assignment validation failed:'), result.error);
      process.exit(1);
    }

    displayValidationResult(result, options);

  } catch (error) {
    console.error(chalk.red('‚ùå Validate assignment command failed:'), error.message);
    process.exit(1);
  }
}

function displayTaskRecommendation(result, options) {
  console.log(chalk.cyan('üéØ Task Recommendation'));
  console.log(chalk.gray('='.repeat(50)));

  if (!result.task) {
    console.log(chalk.yellow('‚ö†Ô∏è  No task found matching criteria'));

    if (result.reasoning) {
      console.log(chalk.gray('\nReason:'), result.reasoning.summary);

      if (result.reasoning.suggestion) {
        console.log(chalk.blue('üí° Suggestion:'), result.reasoning.suggestion);
      }

      if (result.reasoning.availableAlternatives > 0) {
        console.log(chalk.gray(`Available alternatives: ${result.reasoning.availableAlternatives}`));
      }
    }

    console.log(chalk.gray('\nFilters applied:'));
    console.log(chalk.gray(`  Agent: ${result.metadata.filters.agentType}`));
    if (result.metadata.filters.priority) {
      console.log(chalk.gray(`  Priority: ${Array.isArray(result.metadata.filters.priority) ? result.metadata.filters.priority.join(', ') : result.metadata.filters.priority}`));
    }
    if (result.metadata.filters.phase) {
      console.log(chalk.gray(`  Phase: ${Array.isArray(result.metadata.filters.phase) ? result.metadata.filters.phase.join(', ') : result.metadata.filters.phase}`));
    }

    return;
  }

  // Main recommendation
  console.log(chalk.green('‚úÖ Recommended Task:'), chalk.yellow(result.task.id));
  console.log(chalk.white('Title:'), result.task.title);
  console.log(chalk.white('Spec:'), result.task.specId || 'N/A');
  console.log(chalk.white('Priority:'), getPriorityDisplay(result.task.specPriority || result.task.priority));
  console.log(chalk.white('Phase:'), result.task.phase || 'N/A');
  console.log(chalk.white('Estimated Hours:'), result.task.estimated_hours || 'N/A');

  if (result.task.agent_type) {
    console.log(chalk.white('Required Agent:'), result.task.agent_type);
  }

  if (result.task.context_requirements && result.task.context_requirements.length > 0) {
    console.log(chalk.white('Context Requirements:'), result.task.context_requirements.join(', '));
  }

  // Show score if available
  if (result.task.score !== undefined) {
    console.log(chalk.white('Recommendation Score:'), chalk.cyan(result.task.score));
  }

  // Show reasoning if requested
  if (options.showReasoning && result.reasoning) {
    console.log(chalk.blue('\nüìã Recommendation Reasoning:'));
    console.log(chalk.gray(result.reasoning.summary));

    if (result.reasoning.factors && result.reasoning.factors.length > 0) {
      console.log(chalk.blue('\nScoring Factors:'));
      result.reasoning.factors.forEach(factor => {
        const impactColor = factor.impact === 'High' ? 'green' :
                           factor.impact === 'Positive' ? 'cyan' :
                           factor.impact === 'Negative' ? 'red' : 'gray';
        console.log(chalk.gray(`  ‚Ä¢ ${factor.factor}: ${factor.value}`), chalk[impactColor](`(${factor.impact})`));
      });
    }

    console.log(chalk.white('Confidence:'), getConfidenceDisplay(result.reasoning.confidence));
    console.log(chalk.white('Recommendation:'), chalk.cyan(result.reasoning.recommendation));
  }

  // Show constraint validation if available
  if (result.task.constraintValidation) {
    const validation = result.task.constraintValidation;
    console.log(chalk.blue('\nüîç Constraint Validation:'));
    console.log(chalk.white('Valid:'), validation.isValid ? chalk.green('‚úì') : chalk.red('‚úó'));

    if (validation.violations && validation.violations.length > 0) {
      console.log(chalk.red('Violations:'));
      validation.violations.forEach(violation => {
        console.log(chalk.red(`  ‚Ä¢ ${violation}`));
      });
    }

    if (validation.warnings && validation.warnings.length > 0) {
      console.log(chalk.yellow('Warnings:'));
      validation.warnings.forEach(warning => {
        console.log(chalk.yellow(`  ‚Ä¢ ${warning}`));
      });
    }
  }

  // Show alternatives if requested
  if (options.showAlternatives && result.alternatives && result.alternatives.length > 0) {
    console.log(chalk.blue('\nüîÑ Alternative Tasks:'));
    result.alternatives.slice(0, 3).forEach((alt, index) => {
      console.log(chalk.gray(`${index + 1}. ${alt.id} - ${alt.title}`));
      console.log(chalk.gray(`   Score: ${alt.score}, Priority: ${getPriorityDisplay(alt.specPriority || alt.priority)}`));
    });
  }

  // Show performance and metadata
  console.log(chalk.gray(`\nPerformance: ${result.metadata.performance.total}ms`));
  console.log(chalk.gray(`Available tasks: ${result.metadata.totalAvailable}, Agent matches: ${result.metadata.agentMatches}`));
}

function displayTransparentRecommendation(result) {
  console.log(chalk.cyan('üîç Transparent Task Recommendation'));
  console.log(chalk.gray('='.repeat(50)));

  if (!result.recommendation.task) {
    console.log(chalk.yellow('‚ö†Ô∏è  No task found matching criteria'));
    if (result.recommendation.transparency.reasoning) {
      console.log(chalk.gray('\nReason:'), result.recommendation.transparency.reasoning.summary);
    }
    return;
  }

  const task = result.recommendation.task;
  const transparency = result.recommendation.transparency;

  // Basic task info
  console.log(chalk.green('‚úÖ Recommended Task:'), chalk.yellow(task.id));
  console.log(chalk.white('Title:'), task.title);
  console.log(chalk.white('Score:'), chalk.cyan(task.score));

  // Scoring breakdown
  if (transparency.scoring) {
    console.log(chalk.blue('\nüìä Scoring Breakdown:'));
    const breakdown = transparency.scoring.breakdown;
    Object.entries(breakdown).forEach(([factor, data]) => {
      if (data && typeof data === 'object' && data.multiplier !== undefined) {
        console.log(chalk.gray(`  ${factor}:`), `${data.multiplier}x`, chalk.gray(`(${data.details})`));
      }
    });
  }

  // Constraint details
  if (transparency.constraints) {
    console.log(chalk.blue('\nüîí Constraint Analysis:'));
    console.log(chalk.white('Valid:'), transparency.constraints.isValid ? chalk.green('‚úì') : chalk.red('‚úó'));
    console.log(chalk.white('Score Multiplier:'), chalk.cyan(transparency.constraints.score));

    Object.entries(transparency.constraints.details).forEach(([constraint, details]) => {
      console.log(chalk.gray(`  ${constraint}:`), details.isValid ? chalk.green('‚úì') : chalk.red('‚úó'));
      if (details.details && typeof details.details === 'string') {
        console.log(chalk.gray(`    ${details.details}`));
      }
    });
  }

  // Agent matching analysis
  if (transparency.agentMatch) {
    console.log(chalk.blue('\nüë§ Agent Match Analysis:'));
    console.log(chalk.white('Agent Type Match:'), transparency.agentMatch.agentTypeMatch ? chalk.green('‚úì') : chalk.gray('‚Äì'));
    console.log(chalk.white('Match Quality:'), getMatchQualityDisplay(transparency.agentMatch.matchQuality));

    if (transparency.agentMatch.requiredContexts && transparency.agentMatch.requiredContexts.length > 0) {
      console.log(chalk.white('Required Contexts:'), transparency.agentMatch.requiredContexts.join(', '));
    }

    if (transparency.agentMatch.matchingContexts && transparency.agentMatch.matchingContexts.length > 0) {
      console.log(chalk.white('Matching Contexts:'), chalk.green(transparency.agentMatch.matchingContexts.join(', ')));
    }
  }

  // Algorithmic details
  if (transparency.reasoning && transparency.reasoning.algorithmic) {
    console.log(chalk.blue('\n‚öôÔ∏è  Algorithm Details:'));
    const algo = transparency.reasoning.algorithmic;
    console.log(chalk.gray('Scoring Method:'), algo.scoringMethod);
    console.log(chalk.gray('Constraint Engine:'), algo.constraintEngine);
    console.log(chalk.gray('Agent Matching:'), algo.agentMatching);
  }

  console.log(chalk.gray(`\nPerformance: ${result.metadata.performance.total}ms`));
}


function displayValidationResult(result, _options) {
  console.log(chalk.cyan('üîç Assignment Validation'));
  console.log(chalk.gray('='.repeat(50)));

  console.log(chalk.white('Task:'), result.taskId || _options.task);
  console.log(chalk.white('Agent:'), _options.agent);
  console.log(chalk.white('Valid:'), result.valid ? chalk.green('‚úì Valid') : chalk.red('‚úó Invalid'));

  if (result.issues && result.issues.length > 0) {
    console.log(chalk.red('\nIssues:'));
    result.issues.forEach(issue => {
      console.log(chalk.red(`  ‚Ä¢ ${issue}`));
    });
  }

  if (result.warnings && result.warnings.length > 0) {
    console.log(chalk.yellow('\nWarnings:'));
    result.warnings.forEach(warning => {
      console.log(chalk.yellow(`  ‚Ä¢ ${warning}`));
    });
  }

  if (_options.showDetails && result.details) {
    console.log(chalk.blue('\nüìä Validation Details:'));
    console.log(chalk.gray('Task Available:'), result.details.taskAvailable ? chalk.green('‚úì') : chalk.red('‚úó'));
    console.log(chalk.gray('Agent Capable:'), result.details.agentCapable ? chalk.green('‚úì') : chalk.red('‚úó'));
    console.log(chalk.gray('Constraints Passed:'), result.details.constraintsPassed ? chalk.green('‚úì') : chalk.red('‚úó'));
  }

  if (result.constraintDetails) {
    console.log(chalk.blue('\nüîí Constraint Details:'));
    console.log(chalk.gray('Constraint Score:'), chalk.cyan(result.constraintDetails.score));

    if (result.constraintDetails.details) {
      Object.entries(result.constraintDetails.details).forEach(([constraint, details]) => {
        console.log(chalk.gray(`  ${constraint}:`), details.isValid ? chalk.green('‚úì') : chalk.red('‚úó'));
      });
    }
  }

  console.log(chalk.gray(`\nValidation time: ${result.performance.total}ms`));
}

// Utility display functions
function getPriorityDisplay(priority) {
  switch (priority) {
    case 'P0': return chalk.red('P0 (Critical)');
    case 'P1': return chalk.yellow('P1 (High)');
    case 'P2': return chalk.blue('P2 (Medium)');
    case 'P3': return chalk.gray('P3 (Low)');
    default: return chalk.gray(priority || 'N/A');
  }
}

function getConfidenceDisplay(confidence) {
  const percent = Math.round(confidence * 100);
  const color = confidence >= 0.8 ? 'green' : confidence >= 0.6 ? 'yellow' : 'red';
  return chalk[color](`${percent}%`);
}

function getMatchQualityDisplay(quality) {
  switch (quality) {
    case 'Excellent match': return chalk.green(quality);
    case 'Good match': return chalk.cyan(quality);
    case 'Partial match': return chalk.yellow(quality);
    case 'Poor match': return chalk.red(quality);
    default: return chalk.gray(quality);
  }
}

// Workflow state management handler functions
async function handleWorkflowStatus(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const assignments = await stateManager.getCurrentAssignments();

    console.log(chalk.cyan('üìä Current Workflow Status'));
    console.log(chalk.gray('='.repeat(70)));

    if (assignments.current_assignments.length === 0) {
      console.log(chalk.yellow('‚ö†Ô∏è  No active assignments'));
      console.log(chalk.gray('\nUse "asd assign <spec-id> <task-id> --agent <agent-type>" to create assignments'));
      return;
    }

    console.log(chalk.white(`üéØ Active Assignments: ${chalk.cyan(assignments.total_active_assignments)}`));
    console.log();

    // Sort assignments by priority and start time
    let sortedAssignments = [...assignments.current_assignments];
    if (!options.agent) {
      const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3 };
      sortedAssignments.sort((a, b) => {
        const priorityDiff = (priorityOrder[a.priority] || 4) - (priorityOrder[b.priority] || 4);
        if (priorityDiff !== 0) return priorityDiff;
        return new Date(a.started_at) - new Date(b.started_at);
      });
    }

    for (const assignment of sortedAssignments) {
      if (!options.agent || assignment.assigned_agent === options.agent) {
        const priorityIcon = ui.getPriorityIcon(assignment.priority);
        const statusIcon = assignment.status === 'completed' ? '‚úÖ' : 'üîÑ';

        if (options.visual) {
          // Rich visual display
          console.log(`${statusIcon} ${priorityIcon} ${chalk.yellow(assignment.spec_id)}:${chalk.cyan(assignment.task_id)}`);
          console.log(`   üë§ ${chalk.white(assignment.assigned_agent)} | üìÖ ${chalk.gray(ui.formatDate(assignment.started_at))}`);

          if (options.verbose) {
            const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 10) / 10;
            const estimatedHours = assignment.estimated_hours || 'N/A';
            console.log(`   ‚è±Ô∏è  Duration: ${chalk.cyan(duration + 'h')} | Estimated: ${chalk.gray(estimatedHours + 'h')}`);

            if (assignment.completion_notes && assignment.status === 'completed') {
              const notes = assignment.completion_notes.substring(0, 60) + '...';
              console.log(`   üìù ${chalk.gray(notes)}`);
            }
          }
        } else {
          // Standard display
          console.log(chalk.white(`‚Ä¢ ${assignment.spec_id}:${assignment.task_id}`));
          console.log(chalk.gray(`  Agent: ${assignment.assigned_agent}`));
          console.log(chalk.gray(`  Started: ${new Date(assignment.started_at).toLocaleString()}`));
          console.log(chalk.gray(`  Priority: ${getPriorityDisplay(assignment.priority)}`));

          if (options.verbose) {
            console.log(chalk.gray(`  Estimated Hours: ${assignment.estimated_hours || 'N/A'}`));
            const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 100) / 100;
            console.log(chalk.gray(`  Duration: ${duration}h`));
          }
        }
        console.log();
      }
    }

    // Enhanced agent workload display
    if ((options.workload || options.visual) && Object.keys(assignments.agent_workloads).length > 0) {
      console.log(chalk.blue('üë• Agent Workload Summary:'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      const workloadEntries = Object.entries(assignments.agent_workloads);
      workloadEntries.sort((a, b) => b[1].current_tasks - a[1].current_tasks); // Sort by task count

      for (const [agent, workload] of workloadEntries) {
        if (!options.agent || agent === options.agent) {
          const taskCount = workload.current_tasks;
          const totalHours = workload.total_hours;

          if (options.visual) {
            // Create workload bar (assuming max 5 tasks for visualization)
            const maxTasks = Math.max(5, Math.max(...workloadEntries.map(([_, w]) => w.current_tasks)));
            const workloadPercentage = Math.round((taskCount / maxTasks) * 100);
            const workloadBar = ui.createProgressBar(workloadPercentage, 10);

            console.log(`  üë§ ${chalk.cyan(agent.padEnd(20))} [${chalk[workloadBar.barColor](workloadBar.filled)}${chalk.gray(workloadBar.empty)}] ${chalk.white(taskCount)} tasks (${chalk.gray(totalHours + 'h')})`);

            // Show individual assignments for this agent
            if (options.verbose) {
              for (const assignment of workload.assignments) {
                const priorityIcon = ui.getPriorityIcon(assignment.priority);
                console.log(`     ${priorityIcon} ${chalk.gray(assignment.spec_id + ':' + assignment.task_id)}`);
              }
            }
          } else {
            console.log(chalk.gray(`  ${agent}: ${taskCount} tasks, ${totalHours}h total`));
          }
        }
      }
    }

    // Timeline view
    if (options.timeline) {
      console.log(chalk.blue('\nüìÖ Assignment Timeline:'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      const timelineAssignments = [...assignments.current_assignments]
        .filter(a => !options.agent || a.assigned_agent === options.agent)
        .sort((a, b) => new Date(a.started_at) - new Date(b.started_at));

      for (const assignment of timelineAssignments) {
        const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 10) / 10;
        const priorityIcon = ui.getPriorityIcon(assignment.priority);
        const timeAgo = ui.formatDate(assignment.started_at);

        console.log(`  ${chalk.gray(timeAgo.padEnd(12))} ${priorityIcon} ${chalk.yellow(assignment.spec_id)}:${chalk.cyan(assignment.task_id)} ‚Üí ${chalk.white(assignment.assigned_agent)} ${chalk.gray('(' + duration + 'h)')}`);
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Workflow status failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowProgress(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    if (options.spec) {
      const specProgress = await stateManager.getSpecProgress(options.spec);
      const specs = specParser.getSpecs();
      const spec = specs.find(s => s.id === options.spec);

      console.log(chalk.cyan(`üìà Progress for ${options.spec}`));
      if (spec && spec.title) {
        console.log(chalk.white(`   ${spec.title}`));
      }
      console.log(chalk.gray('='.repeat(70)));

      // Rich progress visualization for single spec
      const totalTasks = specProgress.total_tasks || 0;
      const completedTasks = specProgress.completed_tasks || 0;
      const percentage = Math.round(specProgress.completion_percentage || 0);

      if (options.visual || options.bars) {
        const progressBar = ui.createProgressBar(percentage, 20);
        console.log(chalk.white('\nOverall Progress:'));
        console.log(`  [${chalk[progressBar.percentageColor](progressBar.filled)}${chalk.gray(progressBar.empty)}] ${chalk[progressBar.percentageColor](progressBar.percentage)} (${completedTasks}/${totalTasks} tasks)`);
      } else {
        console.log(chalk.white(`Total Tasks: ${totalTasks}`));
        console.log(chalk.white(`Completed Tasks: ${completedTasks}`));
        console.log(chalk.white(`Completion: ${percentage}%`));
      }

      console.log(chalk.white(`Active Assignments: ${specProgress.active_assignments?.length || 0}`));

      if (options.detailed && specProgress.active_assignments && specProgress.active_assignments.length > 0) {
        console.log(chalk.blue('\nüìã Active Assignments:'));
        for (const assignment of specProgress.active_assignments) {
          const agentColor = ui.getColoredPriority(assignment.priority || 'P2');
          console.log(`  ‚Ä¢ ${chalk.yellow(assignment.task_id)} ‚Üí ${chalk.cyan(assignment.assigned_agent)} ${agentColor.text}`);
          if (assignment.started_at) {
            const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 10) / 10;
            console.log(chalk.gray(`    Started: ${ui.formatDate(assignment.started_at)} (${duration}h ago)`));
          }
        }
      }
    } else {
      const progress = await stateManager.getProjectProgress();
      const specs = specParser.getSpecs();

      console.log(chalk.cyan('üìà Project Progress Overview'));
      console.log(chalk.gray('='.repeat(70)));

      // Overall project stats with rich visualization
      const overallPercentage = Math.round(progress.overall.completion_percentage || 0);

      if (options.visual || options.bars) {
        console.log(chalk.white('\nüéØ Overall Project Progress:'));
        const overallBar = ui.createProgressBar(overallPercentage, 25);
        console.log(`  [${chalk[overallBar.percentageColor](overallBar.filled)}${chalk.gray(overallBar.empty)}] ${chalk[overallBar.percentageColor](overallBar.percentage)}`);
        console.log(chalk.gray(`  Tasks: ${progress.overall.completed_tasks}/${progress.overall.total_tasks} | Specs: ${progress.overall.completed_specs}/${progress.overall.total_specs}`));
      } else {
        console.log(chalk.white(`Total Specs: ${progress.overall.total_specs}`));
        console.log(chalk.white(`Active Specs: ${progress.overall.active_specs}`));
        console.log(chalk.white(`Completed Specs: ${progress.overall.completed_specs}`));
        console.log(chalk.white(`Total Tasks: ${progress.overall.total_tasks}`));
        console.log(chalk.white(`Completed Tasks: ${progress.overall.completed_tasks}`));
        console.log(chalk.white(`Overall Completion: ${overallPercentage}%`));
      }

      console.log(chalk.white(`Active Assignments: ${progress.active_assignments || 0}`));

      // Phase progress with visual bars
      if (options.detailed && progress.by_phase && Object.keys(progress.by_phase).length > 0) {
        console.log(chalk.blue('\nüìä Progress by Phase:'));
        const phases = Object.entries(progress.by_phase);

        // Sort phases if requested
        if (options.sort === 'completion') {
          phases.sort((a, b) => b[1].completion_percentage - a[1].completion_percentage);
        }

        for (const [phase, phaseData] of phases) {
          if (!options.phase || phase === options.phase) {
            const phasePercentage = Math.round(phaseData.completion_percentage || 0);

            if (options.visual || options.bars) {
              const phaseBar = ui.createProgressBar(phasePercentage, 15);
              console.log(`  ${chalk.cyan(phase.padEnd(12))} [${chalk[phaseBar.percentageColor](phaseBar.filled)}${chalk.gray(phaseBar.empty)}] ${chalk[phaseBar.percentageColor](phaseBar.percentage)} (${phaseData.completed_specs}/${phaseData.specs})`);
            } else {
              console.log(chalk.gray(`  ${phase}: ${phaseData.completed_specs}/${phaseData.specs} specs (${phasePercentage}%)`));
            }
          }
        }
      }

      // Spec-level progress breakdown
      if (options.detailed && progress.by_spec && Object.keys(progress.by_spec).length > 0) {
        console.log(chalk.blue('\nüìã Progress by Specification:'));
        const specEntries = Object.entries(progress.by_spec).filter(([_, specData]) =>
          specData.total_tasks > 0 || specData.completed_tasks > 0
        );

        // Sort specs if requested
        if (options.sort === 'completion') {
          specEntries.sort((a, b) => (b[1].completion_percentage || 0) - (a[1].completion_percentage || 0));
        } else if (options.sort === 'priority') {
          specEntries.sort((a, b) => {
            const specA = specs.find(s => s.id === a[0]);
            const specB = specs.find(s => s.id === b[0]);
            const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3 };
            return (priorityOrder[specA?.priority] || 4) - (priorityOrder[specB?.priority] || 4);
          });
        }

        for (const [specId, specData] of specEntries.slice(0, 10)) { // Show top 10
          const spec = specs.find(s => s.id === specId);
          const percentage = Math.round(specData.completion_percentage || 0);
          const priorityIcon = spec ? ui.getPriorityIcon(spec.priority) : '';

          if (options.visual || options.bars) {
            const specBar = ui.createProgressBar(percentage, 12);
            const title = spec ? ui.formatFeatureTitle(spec.title, 35) : specId;
            console.log(`  ${priorityIcon} ${chalk.yellow(specId.padEnd(10))} [${chalk[specBar.percentageColor](specBar.filled)}${chalk.gray(specBar.empty)}] ${chalk[specBar.percentageColor](specBar.percentage)} ${chalk.gray(title)}`);
          } else {
            console.log(`  ${priorityIcon} ${chalk.yellow(specId)}: ${specData.completed_tasks}/${specData.total_tasks} tasks (${percentage}%)`);
          }
        }
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Workflow progress failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowHandoffs(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const handoffStatus = await stateManager.getHandoffStatus();
    const specs = specParser.getSpecs();

    console.log(chalk.cyan('üîÑ Workflow Handoffs'));
    console.log(chalk.gray('='.repeat(70)));

    if (!options.history) {
      console.log(chalk.white(`üéØ Ready Handoffs: ${chalk.cyan(handoffStatus.ready_handoffs.length)}`));

      if (handoffStatus.ready_handoffs.length > 0) {
        console.log(chalk.blue('\nüì§ Ready for Handoff:'));

        for (const handoff of handoffStatus.ready_handoffs) {
          const spec = specs.find(s => s.id === handoff.spec_id);
          const priorityIcon = spec ? ui.getPriorityIcon(spec.priority) : '';
          const timeReady = ui.formatDate(handoff.ready_at);

          if (options.visual) {
            console.log(`üîÑ ${priorityIcon} ${chalk.yellow(handoff.spec_id)}: ${chalk.cyan(handoff.from_task)} ‚Üí ${chalk.green(handoff.to_task)}`);
            console.log(`   üë§ ${chalk.white(handoff.next_agent)} | ‚è∞ Ready since ${chalk.gray(timeReady)}`);
            console.log(`   üìù ${chalk.gray(handoff.handoff_reason || handoff.reason || 'No reason provided')}`);

            if (handoff.context_prepared) {
              console.log(`   ‚úÖ ${chalk.green('Context prepared for handoff')}`);
            } else {
              console.log(`   ‚ö†Ô∏è  ${chalk.yellow('Context preparation pending')}`);
            }
          } else {
            console.log(chalk.white(`‚Ä¢ ${handoff.spec_id}: ${handoff.from_task} ‚Üí ${handoff.to_task}`));
            console.log(chalk.gray(`  Next Agent: ${handoff.next_agent}`));
            console.log(chalk.gray(`  Ready Since: ${new Date(handoff.ready_at).toLocaleString()}`));
            console.log(chalk.gray(`  Reason: ${handoff.handoff_reason || handoff.reason}`));
          }
          console.log();
        }
      } else {
        console.log(chalk.gray('\n‚ö° No handoffs ready at this time'));
        console.log(chalk.gray('   All tasks are either in progress or waiting for dependencies'));
      }
    }

    // Timeline view for handoffs
    if (options.timeline && handoffStatus.ready_handoffs.length > 0) {
      console.log(chalk.blue('üìÖ Handoff Timeline:'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      const sortedHandoffs = [...handoffStatus.ready_handoffs].sort((a, b) =>
        new Date(a.ready_at) - new Date(b.ready_at)
      );

      for (const handoff of sortedHandoffs) {
        const timeReady = new Date(handoff.ready_at).toLocaleDateString('en-US', {
          month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
        });
        const spec = specs.find(s => s.id === handoff.spec_id);
        const priorityIcon = spec ? ui.getPriorityIcon(spec.priority) : '';

        console.log(`  ${chalk.gray(timeReady.padEnd(15))} ${priorityIcon} ${chalk.yellow(handoff.spec_id)} ${chalk.cyan(handoff.from_task)} ‚Üí ${chalk.green(handoff.to_task)} (${chalk.white(handoff.next_agent)})`);
      }
    }

    if (options.history && handoffStatus.handoff_history.length > 0) {
      console.log(chalk.blue('\nüìú Recent Handoff History:'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      for (const historyItem of handoffStatus.handoff_history) {
        const completedTime = ui.formatDate(historyItem.completed_at);

        if (options.visual) {
          console.log(`‚úÖ ${chalk.yellow(historyItem.spec_id)}: ${chalk.cyan(historyItem.from_task)} ‚Üí ${chalk.green(historyItem.to_task)}`);
          console.log(`   ‚è∞ Completed: ${chalk.gray(completedTime)}`);
        } else {
          console.log(chalk.gray(`‚Ä¢ ${historyItem.spec_id}: ${historyItem.from_task} ‚Üí ${historyItem.to_task}`));
          console.log(chalk.gray(`  Completed: ${new Date(historyItem.completed_at).toLocaleString()}`));
        }
      }
    }

    // Agent availability summary
    if (options.visual && handoffStatus.agent_availability && Object.keys(handoffStatus.agent_availability).length > 0) {
      console.log(chalk.green('\nüë• Agent Availability for Handoffs:'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      for (const [agent, availability] of Object.entries(handoffStatus.agent_availability)) {
        const taskCount = availability.current_tasks || 0;
        const totalHours = availability.total_hours || 0;
        const workloadLevel = taskCount === 0 ? 'Available' :
                             taskCount <= 2 ? 'Light Load' :
                             taskCount <= 4 ? 'Moderate Load' : 'Heavy Load';

        const workloadColor = taskCount === 0 ? 'green' :
                             taskCount <= 2 ? 'cyan' :
                             taskCount <= 4 ? 'yellow' : 'red';

        console.log(`  üë§ ${chalk.cyan(agent.padEnd(20))} ${chalk[workloadColor](workloadLevel)} (${taskCount} tasks, ${totalHours}h)`);
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Workflow handoffs failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowValidate(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();

    console.log(chalk.cyan('üîç Validating Workflow State'));
    console.log(chalk.gray('='.repeat(50)));

    const validation = await stateManager.validateState();

    console.log(chalk.white('Valid:'), validation.isValid ? chalk.green('‚úì') : chalk.red('‚úó'));
    console.log(chalk.white('Validation Time:'), chalk.cyan(`${validation.performance.total}ms`));

    if (validation.statistics) {
      console.log(chalk.blue('\nStatistics:'));
      console.log(chalk.gray(`  Total Assignments: ${validation.statistics.total_assignments}`));
      console.log(chalk.gray(`  Total Specs: ${validation.statistics.total_specs}`));
      console.log(chalk.gray(`  Ready Handoffs: ${validation.statistics.ready_handoffs}`));
    }

    if (validation.errors && validation.errors.length > 0) {
      console.log(chalk.red('\nErrors:'));
      validation.errors.forEach(error => {
        console.log(chalk.red(`  ‚Ä¢ ${error}`));
      });
    }

    if (validation.warnings && validation.warnings.length > 0) {
      console.log(chalk.yellow('\nWarnings:'));
      validation.warnings.forEach(warning => {
        console.log(chalk.yellow(`  ‚Ä¢ ${warning}`));
      });
    }

    if (validation.isValid) {
      console.log(chalk.green('\n‚úÖ Workflow state validation passed!'));
    } else {
      console.log(chalk.red('\n‚ùå Workflow state validation failed'));
      if (options.fix) {
        console.log(chalk.yellow('üîß Automatic fixing not yet implemented'));
      }
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Workflow validation failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowDashboard(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const progress = await stateManager.getProjectProgress();
    const assignments = await stateManager.getCurrentAssignments();
    const handoffStatus = await stateManager.getHandoffStatus();
    const specs = specParser.getSpecs();

    console.log(chalk.cyan('üìä ASD Workflow Dashboard'));
    console.log(chalk.gray('='.repeat(70)));

    // Overall project health at a glance
    const overallPercentage = Math.round(progress.overall.completion_percentage || 0);
    const overallBar = ui.createProgressBar(overallPercentage, options.compact ? 15 : 25);

    console.log(chalk.white('\nüéØ Project Health:'));
    console.log(`  [${chalk[overallBar.percentageColor](overallBar.filled)}${chalk.gray(overallBar.empty)}] ${chalk[overallBar.percentageColor](overallBar.percentage)} Complete`);
    console.log(chalk.gray(`  ${progress.overall.completed_tasks}/${progress.overall.total_tasks} tasks | ${progress.overall.completed_specs}/${progress.overall.total_specs} specs | ${assignments.total_active_assignments} active`));

    // Critical items requiring attention
    const criticalSpecs = specs.filter(s => s.priority === 'P0' && s.status === 'active').slice(0, 3);
    if (criticalSpecs.length > 0) {
      console.log(chalk.red('\nüî• Critical Items:'));
      for (const spec of criticalSpecs) {
        const specProgress = progress.by_spec[spec.id];
        const percentage = Math.round(specProgress?.completion_percentage || 0);
        const progressBar = ui.createProgressBar(percentage, 10);

        console.log(`  ${ui.getPriorityIcon(spec.priority)} ${chalk.yellow(spec.id)} [${chalk[progressBar.percentageColor](progressBar.filled)}${chalk.gray(progressBar.empty)}] ${chalk.white(ui.formatFeatureTitle(spec.title, 40))}`);
      }
    }

    // Active work summary
    if (assignments.total_active_assignments > 0) {
      console.log(chalk.blue('\nüîÑ Active Work:'));
      const activeByAgent = {};

      for (const assignment of assignments.current_assignments) {
        if (!activeByAgent[assignment.assigned_agent]) {
          activeByAgent[assignment.assigned_agent] = [];
        }
        activeByAgent[assignment.assigned_agent].push(assignment);
      }

      for (const [agent, agentAssignments] of Object.entries(activeByAgent)) {
        const taskCount = agentAssignments.length;
        const highPriorityTasks = agentAssignments.filter(a => a.priority === 'P0' || a.priority === 'P1').length;

        console.log(`  üë§ ${chalk.cyan(agent)} - ${chalk.white(taskCount)} tasks${highPriorityTasks > 0 ? ` (${chalk.red(highPriorityTasks + ' high priority')})` : ''}`);

        if (!options.compact) {
          for (const assignment of agentAssignments.slice(0, 2)) {
            const priorityIcon = ui.getPriorityIcon(assignment.priority);
            console.log(`     ${priorityIcon} ${chalk.gray(assignment.spec_id + ':' + assignment.task_id)}`);
          }
        }
      }
    }

    // Ready handoffs
    if (handoffStatus.ready_handoffs.length > 0) {
      console.log(chalk.yellow('\nüîÑ Ready Handoffs:'));
      for (const handoff of handoffStatus.ready_handoffs.slice(0, options.compact ? 2 : 5)) {
        const timeReady = ui.formatDate(handoff.ready_at);
        console.log(`  üì§ ${chalk.yellow(handoff.spec_id)}:${chalk.cyan(handoff.to_task)} ‚Üí ${chalk.white(handoff.next_agent)} (${chalk.gray('ready ' + timeReady)})`);
      }
    }

    // Phase progress summary
    if (!options.compact && progress.by_phase && Object.keys(progress.by_phase).length > 0) {
      console.log(chalk.blue('\nüìä Phase Progress:'));
      for (const [phase, phaseData] of Object.entries(progress.by_phase)) {
        const phasePercentage = Math.round(phaseData.completion_percentage || 0);
        const phaseBar = ui.createProgressBar(phasePercentage, 12);
        console.log(`  ${chalk.cyan(phase.padEnd(12))} [${chalk[phaseBar.percentageColor](phaseBar.filled)}${chalk.gray(phaseBar.empty)}] ${chalk[phaseBar.percentageColor](phaseBar.percentage)} (${phaseData.completed_specs}/${phaseData.specs})`);
      }
    }

    // Velocity metrics if requested
    if (options.velocity) {
      console.log(chalk.magenta('\nüìà Velocity Metrics:'));
      const completedToday = assignments.assignment_history.filter(h =>
        h.action === 'completed' &&
        new Date(h.completed_at) > new Date(Date.now() - 24 * 60 * 60 * 1000)
      ).length;

      const completedThisWeek = assignments.assignment_history.filter(h =>
        h.action === 'completed' &&
        new Date(h.completed_at) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
      ).length;

      console.log(`  üìÖ Today: ${chalk.white(completedToday)} tasks completed`);
      console.log(`  üìÖ This Week: ${chalk.white(completedThisWeek)} tasks completed`);
      console.log(`  üìÖ Average: ${chalk.white(Math.round(completedThisWeek / 7 * 10) / 10)} tasks/day`);
    }

    // Agent performance if requested
    if (options.agents && Object.keys(assignments.agent_workloads).length > 0) {
      console.log(chalk.green('\nüë• Agent Performance:'));
      for (const [agent, workload] of Object.entries(assignments.agent_workloads)) {
        const avgHoursPerTask = workload.current_tasks > 0 ? Math.round(workload.total_hours / workload.current_tasks * 10) / 10 : 0;
        console.log(`  üë§ ${chalk.cyan(agent)} - ${chalk.white(workload.current_tasks)} active tasks (${chalk.gray(avgHoursPerTask + 'h avg')})`);
      }
    }

    console.log(chalk.gray(`\nüìä Dashboard generated at ${new Date().toLocaleTimeString()}`));

  } catch (error) {
    console.error(chalk.red('‚ùå Workflow dashboard failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowMetrics(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const progress = await stateManager.getProjectProgress();
    const assignments = await stateManager.getCurrentAssignments();

    console.log(chalk.cyan('üìà Workflow Metrics & Analytics'));
    console.log(chalk.gray('='.repeat(70)));

    // Time period calculations
    const periodMs = {
      'day': 24 * 60 * 60 * 1000,
      'week': 7 * 24 * 60 * 60 * 1000,
      'month': 30 * 24 * 60 * 60 * 1000
    };

    const periodLength = periodMs[options.period] || periodMs.week;
    const periodStart = new Date(Date.now() - periodLength);

    // Completion metrics for the period
    const completedInPeriod = assignments.assignment_history.filter(h =>
      h.action === 'completed' && new Date(h.completed_at) > periodStart
    );

    const assignedInPeriod = assignments.assignment_history.filter(h =>
      h.action === 'assigned' && new Date(h.started_at) > periodStart
    );

    console.log(chalk.white(`\nüìä ${options.period.charAt(0).toUpperCase() + options.period.slice(1)} Metrics:`));
    console.log(chalk.white(`Tasks Completed: ${chalk.green(completedInPeriod.length)}`));
    console.log(chalk.white(`Tasks Started: ${chalk.blue(assignedInPeriod.length)}`));
    console.log(chalk.white(`Completion Rate: ${chalk.cyan(Math.round(completedInPeriod.length / Math.max(assignedInPeriod.length, 1) * 100) + '%')}`));

    // Agent productivity
    const agentMetrics = {};
    for (const task of completedInPeriod) {
      if (!agentMetrics[task.assigned_agent]) {
        agentMetrics[task.assigned_agent] = { completed: 0, totalHours: 0 };
      }
      agentMetrics[task.assigned_agent].completed++;
      agentMetrics[task.assigned_agent].totalHours += task.duration_hours || 0;
    }

    if (Object.keys(agentMetrics).length > 0) {
      console.log(chalk.blue('\nüë• Agent Performance:'));
      const sortedAgents = Object.entries(agentMetrics).sort((a, b) => b[1].completed - a[1].completed);

      for (const [agent, metrics] of sortedAgents) {
        const avgHours = metrics.completed > 0 ? Math.round(metrics.totalHours / metrics.completed * 10) / 10 : 0;
        console.log(`  üë§ ${chalk.cyan(agent.padEnd(20))} ${chalk.white(metrics.completed)} completed | ${chalk.gray(avgHours + 'h avg')}`);
      }
    }

    // Priority breakdown
    const priorityBreakdown = { P0: 0, P1: 0, P2: 0, P3: 0 };
    for (const task of completedInPeriod) {
      priorityBreakdown[task.priority] = (priorityBreakdown[task.priority] || 0) + 1;
    }

    console.log(chalk.blue('\nüî• Priority Breakdown:'));
    for (const [priority, count] of Object.entries(priorityBreakdown)) {
      if (count > 0) {
        const priorityIcon = ui.getPriorityIcon(priority);
        console.log(`  ${priorityIcon} ${priority}: ${chalk.white(count)} tasks`);
      }
    }

    // Velocity trend if requested
    if (options.velocity) {
      console.log(chalk.magenta('\nüìà Velocity Trend:'));
      const days = Math.ceil(periodLength / (24 * 60 * 60 * 1000));
      const dailyCompletions = Array(days).fill(0);

      for (const task of completedInPeriod) {
        const daysAgo = Math.floor((Date.now() - new Date(task.completed_at)) / (24 * 60 * 60 * 1000));
        if (daysAgo < days) {
          dailyCompletions[days - 1 - daysAgo]++;
        }
      }

      // Simple ASCII chart for last 7 days
      const maxDaily = Math.max(...dailyCompletions);
      if (maxDaily > 0) {
        for (let i = Math.max(0, days - 7); i < days; i++) {
          const barLength = Math.round((dailyCompletions[i] / maxDaily) * 10);
          const bar = '‚ñà'.repeat(barLength) + '‚ñë'.repeat(10 - barLength);
          const date = new Date(Date.now() - (days - 1 - i) * 24 * 60 * 60 * 1000);
          console.log(`  ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }).padEnd(6)} [${chalk.green(bar)}] ${dailyCompletions[i]}`);
        }
      }
    }

    // Export data if requested
    if (options.export) {
      const exportData = {
        period: options.period,
        generated_at: new Date().toISOString(),
        summary: {
          completed_tasks: completedInPeriod.length,
          started_tasks: assignedInPeriod.length,
          completion_rate: Math.round(completedInPeriod.length / Math.max(assignedInPeriod.length, 1) * 100)
        },
        agent_metrics: agentMetrics,
        priority_breakdown: priorityBreakdown,
        overall_progress: progress.overall
      };

      const fs = require('fs').promises;
      const filename = `asd-metrics-${options.period}-${new Date().toISOString().split('T')[0]}.${options.export}`;

      if (options.export === 'json') {
        await fs.writeFile(filename, JSON.stringify(exportData, null, 2));
      } else if (options.export === 'csv') {
        // Simple CSV export for completed tasks
        const csvLines = ['Date,Spec,Task,Agent,Priority,Duration'];
        for (const task of completedInPeriod) {
          const line = [
            new Date(task.completed_at).toISOString().split('T')[0],
            task.spec_id,
            task.task_id,
            task.assigned_agent,
            task.priority,
            task.duration_hours || 0
          ].join(',');
          csvLines.push(line);
        }
        await fs.writeFile(filename, csvLines.join('\n'));
      }

      console.log(chalk.green(`\nüìÅ Metrics exported to ${filename}`));
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Workflow metrics failed:'), error.message);
    process.exit(1);
  }
}

async function handleWorkflowAssignments(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();
    const ui = new UIComponents();

    const assignments = await stateManager.getCurrentAssignments();

    console.log(chalk.cyan('üìã Current Assignments'));
    console.log(chalk.gray('='.repeat(70)));

    if (assignments.current_assignments.length === 0) {
      console.log(chalk.yellow('‚ö†Ô∏è  No current assignments'));
      return;
    }

    // Filter assignments
    let filteredAssignments = [...assignments.current_assignments];

    if (options.agent) {
      filteredAssignments = filteredAssignments.filter(a => a.assigned_agent === options.agent);
    }

    if (options.priority) {
      const priorities = options.priority.split(',');
      filteredAssignments = filteredAssignments.filter(a => priorities.includes(a.priority));
    }

    if (options.status) {
      const statuses = options.status.split(',');
      filteredAssignments = filteredAssignments.filter(a => statuses.includes(a.status));
    }

    // Sort assignments
    const sortOptions = {
      'priority': (a, b) => {
        const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3 };
        return (priorityOrder[a.priority] || 4) - (priorityOrder[b.priority] || 4);
      },
      'started': (a, b) => new Date(a.started_at) - new Date(b.started_at),
      'agent': (a, b) => a.assigned_agent.localeCompare(b.assigned_agent),
      'spec': (a, b) => a.spec_id.localeCompare(b.spec_id)
    };

    if (sortOptions[options.sort]) {
      filteredAssignments.sort(sortOptions[options.sort]);
    }

    console.log(chalk.white(`\nüìä Found ${filteredAssignments.length} assignments:\n`));

    // Display assignments
    for (const assignment of filteredAssignments) {
      const priorityIcon = ui.getPriorityIcon(assignment.priority);
      const statusIcon = assignment.status === 'completed' ? '‚úÖ' :
                        assignment.status === 'in_progress' ? 'üîÑ' : '‚è≥';
      const duration = Math.round((Date.now() - new Date(assignment.started_at)) / (1000 * 60 * 60) * 10) / 10;

      console.log(`${statusIcon} ${priorityIcon} ${chalk.yellow(assignment.spec_id)}:${chalk.cyan(assignment.task_id)}`);
      console.log(`   üë§ ${chalk.white(assignment.assigned_agent)} | üìÖ ${chalk.gray(ui.formatDate(assignment.started_at))} | ‚è±Ô∏è  ${chalk.cyan(duration + 'h')}`);

      if (assignment.estimated_hours) {
        const progressHours = Math.round((duration / assignment.estimated_hours) * 100);
        const timeBar = ui.createProgressBar(Math.min(progressHours, 100), 10);
        console.log(`   ‚è±Ô∏è  Progress: [${chalk[timeBar.barColor](timeBar.filled)}${chalk.gray(timeBar.empty)}] ${duration}h/${assignment.estimated_hours}h`);
      }

      if (assignment.completion_notes && assignment.status === 'completed') {
        const notes = assignment.completion_notes.substring(0, 80) + '...';
        console.log(`   üìù ${chalk.gray(notes)}`);
      }

      console.log();
    }

    // Timeline view
    if (options.timeline) {
      console.log(chalk.blue('üìÖ Assignment Timeline:'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      const timelineSorted = [...filteredAssignments].sort((a, b) => new Date(a.started_at) - new Date(b.started_at));

      for (const assignment of timelineSorted) {
        const startTime = new Date(assignment.started_at);
        const timeLabel = startTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
        const priorityIcon = ui.getPriorityIcon(assignment.priority);

        console.log(`  ${chalk.gray(timeLabel.padEnd(15))} ${priorityIcon} ${chalk.yellow(assignment.spec_id)}:${chalk.cyan(assignment.task_id)} ‚Üí ${chalk.white(assignment.assigned_agent)}`);
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Workflow assignments failed:'), error.message);
    process.exit(1);
  }
}

// Handoff automation handler functions
async function handleHandoffTrigger(specId, taskId, toAgent, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const handoffEngine = new HandoffAutomationEngine(configManager);
    await handoffEngine.initialize();

    console.log(chalk.cyan('ü§ù Triggering Manual Handoff'));
    console.log(chalk.gray('='.repeat(60)));
    console.log(chalk.white(`From Task: ${chalk.yellow(specId)}:${chalk.cyan(taskId)}`));
    console.log(chalk.white(`To Agent: ${chalk.magenta(toAgent)}`));

    if (options.fromAgent) {
      console.log(chalk.white(`From Agent: ${chalk.magenta(options.fromAgent)}`));
    }

    if (options.reason) {
      console.log(chalk.white(`Reason: ${chalk.gray(options.reason)}`));
    }

    const result = await handoffEngine.triggerManualHandoff(specId, taskId, toAgent, {
      fromAgent: options.fromAgent,
      reason: options.reason,
      nextTask: options.nextTask
    });

    console.log();
    if (result.success && result.handoffNeeded) {
      console.log(chalk.green('‚úÖ Handoff executed successfully!'));

      if (result.nextTask) {
        console.log(chalk.white(`Next Task: ${chalk.yellow(result.nextTask)}`));
      }

      if (result.nextAgent) {
        console.log(chalk.white(`Next Agent: ${chalk.magenta(result.nextAgent)}`));
      }

      if (result.performance?.total) {
        console.log(chalk.gray(`Performance: ${result.performance.total}ms`));
      }

      if (result.context?.handoffContext) {
        console.log(chalk.blue('\nüìã Context Prepared:'));
        console.log(chalk.gray(`‚Ä¢ Agent Context: ${result.context.handoffContext.assignment.agentType}`));
        console.log(chalk.gray(`‚Ä¢ Task Context: ${result.context.handoffContext.assignment.taskId}`));
        console.log(chalk.gray(`‚Ä¢ Ready for Work: ${result.context.handoffContext.workflow.readyForWork ? 'Yes' : 'No'}`));
      }

    } else if (result.success && !result.handoffNeeded) {
      console.log(chalk.yellow('‚ÑπÔ∏è  No handoff needed'));
      console.log(chalk.gray(`Reason: ${result.reason}`));

    } else {
      console.log(chalk.red('‚ùå Handoff failed'));
      console.log(chalk.red(`Error: ${result.error}`));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Handoff trigger failed:'), error.message);
    process.exit(1);
  }
}

async function handleHandoffStatus(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const handoffEngine = new HandoffAutomationEngine(configManager);
    await handoffEngine.initialize();

    const status = await handoffEngine.getHandoffStatus();

    console.log(chalk.cyan('üîÑ Handoff Automation Status'));
    console.log(chalk.gray('='.repeat(70)));

    // Show system health if requested
    if (options.health) {
      console.log(chalk.blue('üè• System Health:'));
      const health = status.systemHealth;

      console.log(chalk.white(`Overall: ${health.overall ? chalk.green('Healthy') : chalk.red('Unhealthy')}`));
      console.log(chalk.white(`Workflow State Manager: ${health.workflowStateManager ? chalk.green('‚úì') : chalk.red('‚úó')}`));
      console.log(chalk.white(`Context Injector: ${health.contextInjector ? chalk.green('‚úì') : chalk.red('‚úó')}`));
      console.log(chalk.white(`Task Router API: ${health.taskRecommendationAPI ? chalk.green('‚úì') : chalk.red('‚úó')}`));
      console.log(chalk.white(`Handoff Engine: ${health.handoffEngine ? chalk.green('‚úì') : chalk.red('‚úó')}`));

      if (health.issues && health.issues.length > 0) {
        console.log(chalk.red('\n‚ö†Ô∏è  Issues:'));
        health.issues.forEach(issue => console.log(chalk.red(`  ‚Ä¢ ${issue}`)));
      }
      console.log();
    }

    // Show active handoffs
    if (!options.history && (options.active || status.active.length > 0)) {
      console.log(chalk.blue('‚è≥ Active Handoffs:'));

      if (status.active.length === 0) {
        console.log(chalk.gray('  No active handoffs'));
      } else {
        status.active.forEach(handoff => {
          console.log(`  üîÑ ${chalk.yellow(handoff.id)} (${chalk.cyan(handoff.status)})`);
          console.log(`     Started: ${chalk.gray(handoff.startedAt)}`);
          if (handoff.trigger) {
            console.log(`     Trigger: ${chalk.magenta(handoff.trigger.type)} - ${handoff.trigger.specId}:${handoff.trigger.taskId}`);
          }
        });
      }
      console.log();
    }

    // Show handoff history if requested
    if (options.history) {
      console.log(chalk.blue('üìú Recent Handoff History:'));

      if (status.recentHistory.length === 0) {
        console.log(chalk.gray('  No handoff history'));
      } else {
        status.recentHistory.forEach(handoff => {
          const statusIcon = handoff.status === 'completed' ? '‚úÖ' : handoff.status === 'failed' ? '‚ùå' : 'üîÑ';
          console.log(`  ${statusIcon} ${chalk.yellow(handoff.id)} (${chalk.cyan(handoff.status)})`);
          console.log(`     ${chalk.gray(handoff.startedAt)} ‚Üí ${chalk.gray(handoff.completedAt || 'ongoing')}`);

          if (handoff.performance?.total) {
            console.log(`     Performance: ${chalk.gray(handoff.performance.total + 'ms')}`);
          }

          if (handoff.error) {
            console.log(`     Error: ${chalk.red(handoff.error)}`);
          }
        });
      }
      console.log();
    }

    // Show performance metrics if requested
    if (options.performance) {
      console.log(chalk.blue('üìä Performance Metrics:'));
      const stats = status.statistics;

      console.log(chalk.white(`Total Handoffs: ${chalk.cyan(stats.totalHandoffs)}`));
      console.log(chalk.white(`Successful: ${chalk.green(stats.successfulHandoffs)}`));
      console.log(chalk.white(`Failed: ${chalk.red(stats.failedHandoffs)}`));
      console.log(chalk.white(`Success Rate: ${chalk.cyan(Math.round((stats.successfulHandoffs / Math.max(stats.totalHandoffs, 1)) * 100))}%`));
      console.log(chalk.white(`Average Time: ${chalk.cyan(stats.averageHandoffTime)}ms`));
      console.log(chalk.white(`Active Transitions: ${chalk.cyan(stats.activeTransitions)}`));
      console.log();
    }

    // Default summary view
    if (!options.active && !options.history && !options.health && !options.performance) {
      console.log(chalk.white('üìä Summary:'));
      console.log(chalk.white(`  Active Handoffs: ${chalk.cyan(status.active.length)}`));
      console.log(chalk.white(`  Total Completed: ${chalk.green(status.statistics.successfulHandoffs)}`));
      console.log(chalk.white(`  System Health: ${status.systemHealth.overall ? chalk.green('Healthy') : chalk.red('Unhealthy')}`));

      if (status.queue && status.queue.length > 0) {
        console.log(chalk.white(`  Queued Handoffs: ${chalk.yellow(status.queue.length)}`));
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Failed to get handoff status:'), error.message);
    process.exit(1);
  }
}

async function handleCompleteTaskWithHandoff(specId, taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const handoffEngine = new HandoffAutomationEngine(configManager);
    await handoffEngine.initialize();

    console.log(chalk.cyan('‚úÖ Completing Task with Handoff'));
    console.log(chalk.gray('='.repeat(60)));
    console.log(chalk.white(`Task: ${chalk.yellow(specId)}:${chalk.cyan(taskId)}`));

    if (options.notes) {
      console.log(chalk.white(`Notes: ${chalk.gray(options.notes)}`));
    }

    // Complete the task first using WorkflowStateManager
    const stateManager = new WorkflowStateManager(configManager, specParser);
    await stateManager.initialize();

    const completionResult = await stateManager.completeTask(specId, taskId, {
      notes: options.notes || 'Task completed via CLI'
    });

    if (!completionResult.success) {
      console.log(chalk.red('‚ùå Task completion failed'));
      console.log(chalk.red(`Error: ${completionResult.error}`));
      process.exit(1);
    }

    console.log(chalk.green('‚úÖ Task completed successfully'));

    // Trigger handoff if one was detected or if forced
    if (completionResult.handoff || options.handoff) {
      console.log(chalk.blue('\nüîÑ Triggering automatic handoff...'));

      const handoffResult = await handoffEngine.executeHandoff({
        type: 'task_completed',
        specId: specId,
        taskId: taskId,
        fromAgent: completionResult.completion?.assigned_agent,
        context: {
          completionNotes: options.notes,
          completedAt: completionResult.completion?.completed_at
        }
      });

      console.log();
      if (handoffResult.success && handoffResult.handoffNeeded) {
        console.log(chalk.green('ü§ù Handoff executed successfully!'));

        if (handoffResult.nextTask) {
          console.log(chalk.white(`Next Task: ${chalk.yellow(handoffResult.nextTask)}`));
        }

        if (handoffResult.nextAgent) {
          console.log(chalk.white(`Next Agent: ${chalk.magenta(handoffResult.nextAgent)}`));
        }

        if (handoffResult.performance?.total) {
          console.log(chalk.gray(`Handoff Time: ${handoffResult.performance.total}ms`));
        }

      } else if (handoffResult.success && !handoffResult.handoffNeeded) {
        console.log(chalk.yellow('‚ÑπÔ∏è  No handoff needed'));
        console.log(chalk.gray(`Reason: ${handoffResult.reason}`));

      } else {
        console.log(chalk.red('‚ùå Handoff failed'));
        console.log(chalk.red(`Error: ${handoffResult.error}`));
      }
    } else {
      console.log(chalk.yellow('‚ÑπÔ∏è  No handoff opportunity detected'));
    }

    // Show updated progress
    console.log(chalk.blue('\nüìä Updated Progress:'));
    const progress = await stateManager.getProjectProgress();
    console.log(chalk.white(`Overall: ${chalk.cyan(progress.overall.completion_percentage.toFixed(1))}% (${progress.overall.completed_tasks}/${progress.overall.total_tasks})`));

  } catch (error) {
    console.error(chalk.red('‚ùå Task completion with handoff failed:'), error.message);
    process.exit(1);
  }
}

// Report management handler functions

async function handleReportCreate(type, title, specId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const reportManager = new DocumentationTemplateManager(configManager);
    await reportManager.initialize();

    console.log(chalk.cyan('üìù Creating Report'));
    console.log(chalk.gray('='.repeat(40)));

    // Parse JSON options if provided
    let context = {};
    let metadata = {};

    if (options.context) {
      try {
        context = JSON.parse(options.context);
      } catch (error) {
        console.error(chalk.red('‚ùå Invalid JSON in --context option'));
        process.exit(1);
      }
    }

    if (options.metadata) {
      try {
        metadata = JSON.parse(options.metadata);
      } catch (error) {
        console.error(chalk.red('‚ùå Invalid JSON in --metadata option'));
        process.exit(1);
      }
    }

    const createOptions = {
      type,
      title,
      specId,
      taskId: options.taskId,
      agentType: options.agent,
      context,
      metadata
    };

    const result = await reportManager.createReport(createOptions);

    if (result.success) {
      console.log(chalk.green('‚úÖ Report created successfully!'));
      console.log(chalk.white('Report ID:'), chalk.yellow(result.reportId));
      console.log(chalk.white('File Path:'), chalk.cyan(result.reportPath));
      console.log(chalk.white('Type:'), chalk.magenta(result.metadata.type));
      console.log(chalk.white('Lifecycle:'), chalk.blue(result.metadata.lifecycle));

      if (result.metadata.retentionHours) {
        console.log(chalk.white('Retention:'), chalk.gray(`${result.metadata.retentionHours} hours`));
      }

      if (result.performance.total > 50) {
        console.log(chalk.yellow(`‚ö†Ô∏è  Creation took ${result.performance.total}ms`));
      }
    } else {
      console.error(chalk.red('‚ùå Report creation failed:'), result.error);
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Report create failed:'), error.message);
    process.exit(1);
  }
}

async function handleReportList(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const reportManager = new DocumentationTemplateManager(configManager);
    await reportManager.initialize();

    console.log(chalk.cyan('üìã Documentation Reports'));
    console.log(chalk.gray('='.repeat(50)));

    const filters = {
      type: options.type,
      specId: options.spec,
      taskId: options.task,
      agentType: options.agent,
      status: options.status,
      sortBy: options.sort,
      sortOrder: options.order,
      limit: parseInt(options.limit) || 20
    };

    const result = await reportManager.listReports(filters);

    if (result.success) {
      if (result.reports.length === 0) {
        console.log(chalk.yellow('üìÑ No reports found matching filters'));
        return;
      }

      console.log(chalk.white(`Found ${chalk.cyan(result.total)} reports (showing ${chalk.cyan(result.reports.length)})`));
      console.log();

      for (const report of result.reports) {
        const age = Math.round((Date.now() - new Date(report.createdAt)) / (1000 * 60 * 60));

        console.log(chalk.white(`‚Ä¢ ${chalk.yellow(report.id)}`));
        console.log(chalk.gray(`  Title: ${report.title}`));
        console.log(chalk.gray(`  Type: ${chalk.magenta(report.type)} | Agent: ${chalk.blue(report.agentType)}`));
        console.log(chalk.gray(`  Spec: ${chalk.cyan(report.specId)}${report.taskId ? ` | Task: ${chalk.green(report.taskId)}` : ''}`));
        console.log(chalk.gray(`  Created: ${age}h ago | Status: ${report.status === 'active' ? chalk.green(report.status) : chalk.yellow(report.status)}`));

        if (options.verbose) {
          console.log(chalk.gray(`  Path: ${report.path}`));
          if (report.lifecycle !== 'manual') {
            console.log(chalk.gray(`  Lifecycle: ${report.lifecycle} (${report.retentionHours}h retention)`));
          }
        }
        console.log();
      }

    } else {
      console.error(chalk.red('‚ùå Report listing failed:'), result.error);
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Report list failed:'), error.message);
    process.exit(1);
  }
}

async function handleReportShow(reportId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const reportManager = new DocumentationTemplateManager(configManager);
    await reportManager.initialize();

    const result = await reportManager.getReport(reportId, {
      includeContent: !options.metadataOnly
    });

    if (result.success) {
      const report = result.metadata;

      console.log(chalk.cyan(`üìÑ Report: ${report.title}`));
      console.log(chalk.gray('='.repeat(50)));

      // Show metadata
      console.log(chalk.white('ID:'), chalk.yellow(report.id));
      console.log(chalk.white('Type:'), chalk.magenta(report.type));
      console.log(chalk.white('Status:'), report.status === 'active' ? chalk.green(report.status) : chalk.yellow(report.status));
      console.log(chalk.white('Agent:'), chalk.blue(report.agentType));
      console.log(chalk.white('Spec:'), chalk.cyan(report.specId));

      if (report.taskId) {
        console.log(chalk.white('Task:'), chalk.green(report.taskId));
      }

      console.log(chalk.white('Created:'), chalk.gray(new Date(report.createdAt).toLocaleString()));

      if (report.lastModified) {
        console.log(chalk.white('Modified:'), chalk.gray(new Date(report.lastModified).toLocaleString()));
      }

      console.log(chalk.white('Lifecycle:'), chalk.blue(report.lifecycle));

      if (report.retentionHours) {
        console.log(chalk.white('Retention:'), chalk.gray(`${report.retentionHours} hours`));
      }

      console.log(chalk.white('Path:'), chalk.gray(report.path));

      // Show content if requested
      if (result.content && !options.metadataOnly) {
        console.log(chalk.white('\nContent:'));
        console.log(chalk.gray('='.repeat(30)));
        console.log(result.content);
      }

    } else {
      console.error(chalk.red('‚ùå Report not found:'), result.error);
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Report show failed:'), error.message);
    process.exit(1);
  }
}

async function handleReportUpdate(reportId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const reportManager = new DocumentationTemplateManager(configManager);
    await reportManager.initialize();

    if (options.edit) {
      // Open in editor
      const reportResult = await reportManager.getReport(reportId, { includeContent: false });
      if (!reportResult.success) {
        console.error(chalk.red('‚ùå Report not found:'), reportResult.error);
        process.exit(1);
      }

      const { spawn } = require('child_process');
      const editor = process.env.EDITOR || 'nano';

      const child = spawn(editor, [reportResult.metadata.path], {
        stdio: 'inherit'
      });

      child.on('exit', (code) => {
        if (code === 0) {
          console.log(chalk.green(`‚úÖ Report updated: ${reportId}`));
        } else {
          console.error(chalk.red('‚ùå Editor exited with error'));
          process.exit(1);
        }
      });
      return;
    }

    const updates = {};

    if (options.content) {
      updates.content = options.content;
    }

    if (options.metadata) {
      try {
        updates.metadata = JSON.parse(options.metadata);
      } catch (error) {
        console.error(chalk.red('‚ùå Invalid JSON in --metadata option'));
        process.exit(1);
      }
    }

    if (!updates.content && !updates.metadata) {
      console.error(chalk.red('‚ùå Must specify --content, --metadata, or --edit'));
      process.exit(1);
    }

    const result = await reportManager.updateReport(reportId, updates);

    if (result.success) {
      console.log(chalk.green('‚úÖ Report updated successfully!'));
      console.log(chalk.white('Report ID:'), chalk.yellow(result.reportId));

      if (result.performance.total > 50) {
        console.log(chalk.yellow(`‚ö†Ô∏è  Update took ${result.performance.total}ms`));
      }
    } else {
      console.error(chalk.red('‚ùå Report update failed:'), result.error);
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Report update failed:'), error.message);
    process.exit(1);
  }
}

async function handleReportCleanup(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const reportManager = new DocumentationTemplateManager(configManager);
    await reportManager.initialize();

    console.log(chalk.cyan('üßπ Report Cleanup'));
    console.log(chalk.gray('='.repeat(40)));

    const cleanupOptions = {
      respectRetentionTime: options.respectRetention,
      forceCleanup: options.force
    };

    if (options.completedTasks) {
      cleanupOptions.completedTaskIds = options.completedTasks.split(',').map(id => id.trim());
    }

    if (options.completedSpecs) {
      cleanupOptions.completedSpecIds = options.completedSpecs.split(',').map(id => id.trim());
    }

    if (options.dryRun) {
      console.log(chalk.blue('üîç Dry run mode - no changes will be made'));
      console.log();
    }

    const result = await reportManager.executeCleanup(cleanupOptions);

    if (result.success) {
      const cleanup = result.cleanup;

      console.log(chalk.white('Cleanup Results:'));
      console.log(chalk.green(`‚úÖ Cleaned: ${cleanup.totalCleaned} reports`));

      if (cleanup.totalErrors > 0) {
        console.log(chalk.red(`‚ùå Errors: ${cleanup.totalErrors} reports`));
      }

      if (cleanup.cleaned.length > 0) {
        console.log(chalk.white('\nCleaned Reports:'));
        for (const cleaned of cleanup.cleaned) {
          console.log(chalk.gray(`  ‚Ä¢ ${chalk.yellow(cleaned.reportId)} (${cleaned.type}) - ${cleaned.reason}`));
        }
      }

      if (cleanup.errors.length > 0) {
        console.log(chalk.red('\nCleanup Errors:'));
        for (const error of cleanup.errors) {
          console.log(chalk.red(`  ‚Ä¢ ${error.reportId}: ${error.error}`));
        }
      }

      if (cleanup.totalCleaned === 0 && cleanup.totalErrors === 0) {
        console.log(chalk.yellow('‚ÑπÔ∏è  No reports eligible for cleanup'));
      }

    } else {
      console.error(chalk.red('‚ùå Cleanup execution failed:'), result.error);
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Report cleanup failed:'), error.message);
    process.exit(1);
  }
}

async function handleReportTemplates(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const reportManager = new DocumentationTemplateManager(configManager);
    await reportManager.initialize();

    if (options.show) {
      // Show specific template
      console.log(chalk.cyan(`üìÑ Template: ${options.show}`));
      console.log(chalk.gray('='.repeat(50)));

      const templates = await reportManager.getAvailableTemplates();
      if (templates.success && templates.templates[options.show]) {
        const template = templates.templates[options.show];
        console.log(chalk.white('Name:'), chalk.yellow(template.name));
        console.log(chalk.white('Description:'), chalk.gray(template.description));
        console.log(chalk.white('Lifecycle:'), chalk.blue(template.lifecycle));
        console.log(chalk.white('Retention:'), template.retention_hours ? `${template.retention_hours}h` : chalk.gray('manual'));
        console.log(chalk.white('Status:'), template.templateExists ? chalk.green('available') : chalk.red('missing'));

        if (template.templateContent) {
          console.log(chalk.white('\nTemplate Content:'));
          console.log(chalk.gray('='.repeat(30)));
          console.log(template.templateContent);
        }
      } else {
        console.error(chalk.red(`‚ùå Template '${options.show}' not found`));
        process.exit(1);
      }
      return;
    }

    // List all templates
    console.log(chalk.cyan('üìã Available Report Templates'));
    console.log(chalk.gray('='.repeat(50)));

    const result = await reportManager.getAvailableTemplates();

    if (result.success) {
      for (const [type, template] of Object.entries(result.templates)) {
        const status = template.templateExists ? chalk.green('‚úì') : chalk.red('‚úó');

        console.log(`${status} ${chalk.white(type)}: ${chalk.yellow(template.name)}`);
        console.log(chalk.gray(`   ${template.description}`));
        console.log(chalk.gray(`   Lifecycle: ${template.lifecycle} | Retention: ${template.retention_hours ? template.retention_hours + 'h' : 'manual'}`));
        console.log();
      }

      if (options.validate) {
        console.log(chalk.blue('üîç Template Validation:'));
        let allValid = true;

        for (const [type, template] of Object.entries(result.templates)) {
          if (!template.templateExists) {
            console.log(chalk.red(`‚ùå Missing template: ${type}`));
            allValid = false;
          }
        }

        if (allValid) {
          console.log(chalk.green('‚úÖ All templates are available'));
        }
      }

    } else {
      console.error(chalk.red('‚ùå Template listing failed:'), result.error);
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Report templates failed:'), error.message);
    process.exit(1);
  }
}

async function handleReportStats(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const reportManager = new DocumentationTemplateManager(configManager);
    await reportManager.initialize();

    console.log(chalk.cyan('üìä Documentation System Statistics'));
    console.log(chalk.gray('='.repeat(50)));

    const result = await reportManager.getSystemStats();

    if (result.success) {
      const stats = result.stats;

      // Overall statistics
      console.log(chalk.white('Overall Statistics:'));
      console.log(chalk.gray(`  Total Reports: ${chalk.cyan(stats.totalReports)}`));
      console.log(chalk.gray(`  Active Reports: ${chalk.green(stats.activeReports)}`));
      console.log(chalk.gray(`  Upcoming Cleanups: ${chalk.yellow(stats.upcomingCleanups)}`));

      if (stats.averageRetentionHours > 0) {
        console.log(chalk.gray(`  Average Retention: ${chalk.blue(Math.round(stats.averageRetentionHours))}h`));
      }

      console.log();

      // By type breakdown
      if (options.byType && Object.keys(stats.reportsByType).length > 0) {
        console.log(chalk.white('Reports by Type:'));
        for (const [type, count] of Object.entries(stats.reportsByType)) {
          console.log(chalk.gray(`  ${chalk.magenta(type)}: ${count}`));
        }
        console.log();
      }

      // By agent breakdown
      if (options.byAgent && Object.keys(stats.reportsByAgent).length > 0) {
        console.log(chalk.white('Reports by Agent:'));
        for (const [agent, count] of Object.entries(stats.reportsByAgent)) {
          console.log(chalk.gray(`  ${chalk.blue(agent)}: ${count}`));
        }
        console.log();
      }

      // By spec breakdown
      if (options.detailed && Object.keys(stats.reportsBySpec).length > 0) {
        console.log(chalk.white('Reports by Specification:'));
        const specEntries = Object.entries(stats.reportsBySpec)
          .sort(([,a], [,b]) => b - a)
          .slice(0, 10); // Show top 10

        for (const [spec, count] of specEntries) {
          console.log(chalk.gray(`  ${chalk.cyan(spec)}: ${count}`));
        }
        console.log();
      }

      // Age information
      if (stats.oldestReport && stats.newestReport) {
        const oldestAge = Math.round((Date.now() - new Date(stats.oldestReport.createdAt)) / (1000 * 60 * 60 * 24));
        const newestAge = Math.round((Date.now() - new Date(stats.newestReport.createdAt)) / (1000 * 60 * 60));

        console.log(chalk.white('Age Range:'));
        console.log(chalk.gray(`  Oldest: ${oldestAge} days (${stats.oldestReport.type})`));
        console.log(chalk.gray(`  Newest: ${newestAge}h (${stats.newestReport.type})`));
        console.log();
      }

      // Cleanup preview
      if (options.cleanupPreview) {
        console.log(chalk.yellow('üßπ Upcoming Cleanup Candidates:'));
        if (stats.upcomingCleanups > 0) {
          console.log(chalk.gray(`  ${stats.upcomingCleanups} reports eligible for cleanup within 24 hours`));
          console.log(chalk.gray('  Run \'asd report cleanup --dry-run\' for details'));
        } else {
          console.log(chalk.gray('  No reports eligible for cleanup in the next 24 hours'));
        }
      }

      console.log(chalk.gray(`Generated at: ${result.generatedAt}`));

    } else {
      console.error(chalk.red('‚ùå Stats generation failed:'), result.error);
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Report stats failed:'), error.message);
    process.exit(1);
  }
}

// Feature management handler functions
async function handleSpecCreate(type, title, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    // Generate spec ID
    const typeUpper = type.toUpperCase();
    const specs = specParser.getSpecsByType(typeUpper);
    const nextNumber = Math.max(0, ...specs.map(s => {
      const match = s.id.match(/\d+$/);
      return match ? parseInt(match[0]) : 0;
    })) + 1;
    const specId = `${typeUpper}-${nextNumber.toString().padStart(3, '0')}`;

    // Create spec content from template
    const specContent = createSpecTemplate(specId, title, typeUpper, options);

    // Determine file path based on status
    const config = configManager.loadConfig();
    const status = 'backlog'; // Default new specs to backlog
    const fileName = `${specId.toLowerCase()}-${title.toLowerCase().replace(/[^a-z0-9]+/g, '-')}.md`;
    const filePath = path.join(config.dataPath, status, fileName);

    // Write spec file
    const fs = require('fs').promises;
    await fs.writeFile(filePath, specContent, 'utf-8');

    console.log(chalk.green(`‚úÖ Created ${typeUpper} specification: ${specId}`));
    console.log(chalk.gray(`   Title: ${title}`));
    console.log(chalk.gray(`   Priority: ${options.priority}`));
    console.log(chalk.gray(`   Phase: ${options.phase}`));
    console.log(chalk.gray(`   File: ${filePath}`));

    if (options.agent) {
      console.log(chalk.gray(`   Assigned to: ${options.agent}`));
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Failed to create specification:'), error.message);
    process.exit(1);
  }
}

async function handleSpecList(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    let specs = specParser.getSpecs();

    // Apply filters
    if (options.status) {
      specs = specs.filter(spec => spec.status === options.status);
    }
    if (options.priority) {
      const priorities = options.priority.split(',');
      specs = specs.filter(spec => priorities.includes(spec.priority));
    }
    if (options.phase) {
      specs = specs.filter(spec => spec.phase === options.phase);
    }
    if (options.type) {
      const types = options.type.split(',');
      specs = specs.filter(spec => types.includes(spec.type));
    }

    // Apply sorting
    specs = sortSpecs(specs, options.sort);

    // Apply limit
    const limit = parseInt(options.limit) || 20;
    specs = specs.slice(0, limit);

    // Output in requested format
    outputSpecs(specs, options.format);

  } catch (error) {
    console.error(chalk.red('‚ùå Failed to list specifications:'), error.message);
    process.exit(1);
  }
}

async function handleSpecShow(specId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const spec = specParser.getSpecById(specId);
    if (!spec) {
      console.error(chalk.red(`‚ùå Specification not found: ${specId}`));
      process.exit(1);
    }

    if (options.format === 'json') {
      console.log(JSON.stringify(spec, null, 2));
    } else if (options.format === 'summary') {
      outputSpecSummary(spec);
    } else {
      outputSpecDetails(spec, options);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Failed to show specification:'), error.message);
    process.exit(1);
  }
}

async function handleSpecUpdate(specId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const spec = specParser.getSpecById(specId);
    if (!spec) {
      console.error(chalk.red(`‚ùå Specification not found: ${specId}`));
      process.exit(1);
    }

    // Read current spec file
    const fs = require('fs').promises;
    const specPath = spec.filePath;
    const content = await fs.readFile(specPath, 'utf-8');

    let updatedContent = content;
    let hasUpdates = false;

    // Update frontmatter fields
    if (options.status) {
      updatedContent = updateFrontmatter(updatedContent, 'status', options.status);
      hasUpdates = true;
    }
    if (options.priority) {
      updatedContent = updateFrontmatter(updatedContent, 'priority', options.priority);
      hasUpdates = true;
    }
    if (options.phase) {
      updatedContent = updateFrontmatter(updatedContent, 'phase', options.phase);
      hasUpdates = true;
    }
    if (options.title) {
      updatedContent = updateFrontmatter(updatedContent, 'title', options.title);
      hasUpdates = true;
    }

    if (hasUpdates) {
      await fs.writeFile(specPath, updatedContent, 'utf-8');
      console.log(chalk.green(`‚úÖ Updated specification: ${specId}`));

      // Show what was updated
      if (options.status) console.log(chalk.gray(`   Status: ${options.status}`));
      if (options.priority) console.log(chalk.gray(`   Priority: ${options.priority}`));
      if (options.phase) console.log(chalk.gray(`   Phase: ${options.phase}`));
      if (options.title) console.log(chalk.gray(`   Title: ${options.title}`));
    } else {
      console.log(chalk.yellow('‚ö†Ô∏è  No updates specified'));
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Failed to update specification:'), error.message);
    process.exit(1);
  }
}

async function handleSpecMove(specId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const spec = specParser.getSpecById(specId);
    if (!spec) {
      console.error(chalk.red(`‚ùå Specification not found: ${specId}`));
      process.exit(1);
    }

    const fs = require('fs').promises;
    const config = configManager.loadConfig();

    let moved = false;

    // Move to different status (involves file system move)
    if (options.toStatus) {
      const oldPath = spec.filePath;
      const fileName = path.basename(oldPath);
      const newPath = path.join(config.dataPath, options.toStatus, fileName);

      await fs.rename(oldPath, newPath);

      // Update status in frontmatter
      const content = await fs.readFile(newPath, 'utf-8');
      const updatedContent = updateFrontmatter(content, 'status', options.toStatus);
      await fs.writeFile(newPath, updatedContent, 'utf-8');

      console.log(chalk.green(`‚úÖ Moved ${specId} to ${options.toStatus}`));
      console.log(chalk.gray(`   From: ${oldPath}`));
      console.log(chalk.gray(`   To: ${newPath}`));
      moved = true;
    }

    // Move to different phase (frontmatter only)
    if (options.toPhase) {
      const content = await fs.readFile(spec.filePath, 'utf-8');
      const updatedContent = updateFrontmatter(content, 'phase', options.toPhase);
      await fs.writeFile(spec.filePath, updatedContent, 'utf-8');

      console.log(chalk.green(`‚úÖ Moved ${specId} to phase ${options.toPhase}`));
      moved = true;
    }

    if (!moved) {
      console.log(chalk.yellow('‚ö†Ô∏è  No move operation specified (use --to-status or --to-phase)'));
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Failed to move specification:'), error.message);
    process.exit(1);
  }
}

// FEAT-018 TASK-003: Enhanced Task Management Command Handlers

async function handleTaskStart(taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextInjector = new ContextInjector(configManager);
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Parse task ID - support both SPEC-ID:TASK-ID and standalone TASK-ID
    let specId, parsedTaskId;
    if (taskId.includes(':')) {
      [specId, parsedTaskId] = taskId.split(':', 2);
    } else {
      parsedTaskId = taskId;
      specId = options.spec;
    }

    if (!specId) {
      console.error(chalk.red('‚ùå Specification ID required (use --spec or SPEC-ID:TASK-ID format)'));
      process.exit(1);
    }

    if (!options.agent) {
      console.error(chalk.red('‚ùå Must specify --agent <agent-type> to start task'));
      process.exit(1);
    }

    // Validate task exists
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const spec = specParser.getSpecById(specId);
    if (!spec) {
      console.error(chalk.red(`‚ùå Specification not found: ${specId}`));
      process.exit(1);
    }

    const task = spec.tasks?.find(t => t.id === parsedTaskId);
    if (!task) {
      console.error(chalk.red(`‚ùå Task not found: ${parsedTaskId} in ${specId}`));
      process.exit(1);
    }

    // Prepare context injection
    const contextLevels = options.injectContext.split(',').map(l => l.trim());

    if (options.dryRun) {
      console.log(chalk.blue('üîç Context Injection Preview (--dry-run)'));
      console.log(chalk.gray('‚îÄ'.repeat(50)));

      for (const level of contextLevels) {
        console.log(chalk.cyan(`üìã ${level.toUpperCase()} Context:`));

        try {
          const contextData = await contextInjector.injectContext(options.agent, {
            specId,
            taskId: parsedTaskId,
            contextType: level
          });

          if (contextData && contextData.context) {
            const contextLines = contextData.context.split('\n').slice(0, 5);
            contextLines.forEach(line => {
              console.log(chalk.gray(`   ${line}`));
            });
            if (contextData.context.split('\n').length > 5) {
              console.log(chalk.gray('   ... (truncated)'));
            }
          } else {
            console.log(chalk.gray('   No context available'));
          }
        } catch (error) {
          console.log(chalk.yellow(`   ‚ö†Ô∏è Context injection failed: ${error.message}`));
        }

        console.log();
      }

      console.log(chalk.blue('Would start task with this context. Use without --dry-run to proceed.'));
      return;
    }

    // Update task status to in_progress and assign agent
    const updates = {
      frontmatter: {
        assigned_agent: options.agent,
        assigned_at: new Date().toISOString(),
        started_at: new Date().toISOString(),
        status: 'in_progress'
      }
    };

    const taskSuccess = await contextManager.updateContext('task', parsedTaskId, updates);

    // Update dynamic state (assignments.json)
    const paths = contextManager.getContextPaths();
    const assignmentsPath = path.join(paths.state, 'assignments.json');

    const fs = require('fs').promises;
    let assignments = {};

    try {
      if (await contextManager.fileExists(assignmentsPath)) {
        const assignmentsContent = await fs.readFile(assignmentsPath, 'utf-8');
        assignments = JSON.parse(assignmentsContent);
      }
    } catch (error) {
      // Start fresh if file is corrupted
    }

    // Update assignments
    assignments[specId] = assignments[specId] || {};
    assignments[specId][parsedTaskId] = {
      agent: options.agent,
      assigned_at: new Date().toISOString(),
      started_at: new Date().toISOString(),
      priority: task.priority || 'P2',
      status: 'in_progress'
    };

    // Ensure state directory exists
    await fs.mkdir(paths.state, { recursive: true });
    await fs.writeFile(assignmentsPath, JSON.stringify(assignments, null, 2), 'utf-8');

    if (taskSuccess) {
      // Fire trigger for task start
      await triggerSystem.fireTrigger('start', {
        specId,
        taskId: parsedTaskId,
        agentType: options.agent,
        contextLevels,
        source: 'cli_command'
      });

      console.log(chalk.green(`‚úÖ Started task ${parsedTaskId}`));
      console.log(chalk.gray(`   Spec: ${specId}`));
      console.log(chalk.gray(`   Agent: ${options.agent}`));
      console.log(chalk.gray(`   Context levels: ${contextLevels.join(', ')}`));

      // Show injected context summary
      console.log(chalk.blue('\nüìã Context Injected:'));
      for (const level of contextLevels) {
        try {
          const contextData = await contextInjector.injectContext(options.agent, {
            specId,
            taskId: parsedTaskId,
            contextType: level
          });

          if (contextData && contextData.context) {
            const lines = contextData.context.split('\n').length;
            console.log(chalk.gray(`   ${level}: ${lines} lines of context`));
          }
        } catch (error) {
          console.log(chalk.yellow(`   ${level}: Context injection failed`));
        }
      }

    } else {
      console.error(chalk.red('‚ùå Failed to update task status'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Task start failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskAssignFlexible(taskId, options) {
  try {
    // Parse task ID - support both SPEC-ID:TASK-ID and standalone TASK-ID
    let specId, parsedTaskId;
    if (taskId.includes(':')) {
      [specId, parsedTaskId] = taskId.split(':', 2);
    } else {
      parsedTaskId = taskId;
      specId = options.spec;
    }

    if (!specId) {
      console.error(chalk.red('‚ùå Specification ID required (use --spec or SPEC-ID:TASK-ID format)'));
      process.exit(1);
    }

    // Delegate to existing handleTaskAssign function
    await handleTaskAssign(specId, parsedTaskId, {
      agent: options.agent,
      priority: options.priority,
      validate: options.validate && !options.force
    });

  } catch (error) {
    console.error(chalk.red('‚ùå Task assignment failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskCompleteEnhanced(taskId, options) {
  try {
    // Parse task ID - support both SPEC-ID:TASK-ID and standalone TASK-ID
    let specId, parsedTaskId;
    if (taskId.includes(':')) {
      [specId, parsedTaskId] = taskId.split(':', 2);
    } else {
      parsedTaskId = taskId;
      specId = options.spec;
    }

    if (!specId) {
      console.error(chalk.red('‚ùå Specification ID required (use --spec or SPEC-ID:TASK-ID format)'));
      process.exit(1);
    }

    if (options.type === 'subtask') {
      if (!options.subtask) {
        console.error(chalk.red('‚ùå Subtask ID required when type is "subtask" (use --subtask)'));
        process.exit(1);
      }

      // Handle subtask completion
      await handleSubtaskComplete(specId, parsedTaskId, options.subtask, options);
    } else {
      // Handle regular task completion - delegate to existing function
      await handleTaskComplete(specId, parsedTaskId, options);

      // Trigger automation if requested
      if (options.triggerAutomation) {
        console.log(chalk.blue('üîÑ Triggering handoff automation...'));
        await handleCompleteTaskWithHandoff(specId, parsedTaskId, options);
      }
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Task completion failed:'), error.message);
    process.exit(1);
  }
}

async function handleSubtaskComplete(specId, taskId, subtaskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Validate spec and task exist
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const spec = specParser.getSpecById(specId);
    if (!spec) {
      console.error(chalk.red(`‚ùå Specification not found: ${specId}`));
      process.exit(1);
    }

    const task = spec.tasks?.find(t => t.id === taskId);
    if (!task) {
      console.error(chalk.red(`‚ùå Task not found: ${taskId} in ${specId}`));
      process.exit(1);
    }

    const subtask = task.subtasks?.find(st => st.id === subtaskId);
    if (!subtask) {
      console.error(chalk.red(`‚ùå Subtask not found: ${subtaskId} in ${taskId}`));
      process.exit(1);
    }

    // Update subtask status in the spec file
    const fs = require('fs').promises;
    const content = await fs.readFile(spec.filePath, 'utf-8');

    // Simple regex replacement to update subtask status
    const subtaskRegex = new RegExp(
      `(- id: "${subtaskId}"[\\s\\S]*?status: ")ready|in_progress|blocked(")`
    );

    const updatedContent = content.replace(subtaskRegex, '$1complete$2');

    if (updatedContent !== content) {
      await fs.writeFile(spec.filePath, updatedContent, 'utf-8');

      // Fire trigger for subtask completion
      await triggerSystem.fireTrigger('complete_subtask', {
        specId,
        taskId,
        subtaskId,
        completionNotes: options.notes,
        source: 'cli_command'
      });

      console.log(chalk.green(`‚úÖ Marked subtask ${subtaskId} as complete`));
      console.log(chalk.gray(`   Task: ${specId}:${taskId}`));
      if (options.notes) {
        console.log(chalk.gray(`   Notes: ${options.notes}`));
      }

      // Check if all subtasks are complete
      const updatedSpec = await specParser.getSpecById(specId);
      const updatedTask = updatedSpec.tasks?.find(t => t.id === taskId);
      const allSubtasksComplete = updatedTask.subtasks?.every(st => st.status === 'complete');

      if (allSubtasksComplete) {
        console.log(chalk.blue('üéâ All subtasks complete! Consider completing the main task.'));
      }

    } else {
      console.error(chalk.red('‚ùå Failed to update subtask status in spec file'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Subtask completion failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskBlock(taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Parse task ID
    let specId, parsedTaskId;
    if (taskId.includes(':')) {
      [specId, parsedTaskId] = taskId.split(':', 2);
    } else {
      parsedTaskId = taskId;
      specId = options.spec;
    }

    if (!specId) {
      console.error(chalk.red('‚ùå Specification ID required (use --spec or SPEC-ID:TASK-ID format)'));
      process.exit(1);
    }

    // Validate task exists
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const spec = specParser.getSpecById(specId);
    if (!spec) {
      console.error(chalk.red(`‚ùå Specification not found: ${specId}`));
      process.exit(1);
    }

    const task = spec.tasks?.find(t => t.id === parsedTaskId);
    if (!task) {
      console.error(chalk.red(`‚ùå Task not found: ${parsedTaskId} in ${specId}`));
      process.exit(1);
    }

    // Update task with blocking information
    const updates = {
      frontmatter: {
        status: 'blocked',
        blocked_at: new Date().toISOString(),
        blocked_reason: options.reason
      }
    };

    if (options.until) {
      updates.frontmatter.blocked_until = options.until;
    }

    if (options.dependsOn) {
      const dependencies = options.dependsOn.split(',').map(dep => dep.trim());
      updates.frontmatter.depends_on = dependencies;
    }

    const taskSuccess = await contextManager.updateContext('task', parsedTaskId, updates);

    // Update dynamic state
    const paths = contextManager.getContextPaths();
    const blockedPath = path.join(paths.state, 'blocked-tasks.json');

    const fs = require('fs').promises;
    let blockedTasks = {};

    try {
      if (await contextManager.fileExists(blockedPath)) {
        const blockedContent = await fs.readFile(blockedPath, 'utf-8');
        blockedTasks = JSON.parse(blockedContent);
      }
    } catch (error) {
      // Start fresh if file is corrupted
    }

    // Update blocked tasks registry
    blockedTasks[specId] = blockedTasks[specId] || {};
    blockedTasks[specId][parsedTaskId] = {
      blocked_at: new Date().toISOString(),
      reason: options.reason,
      until: options.until || null,
      depends_on: options.dependsOn ? options.dependsOn.split(',').map(dep => dep.trim()) : []
    };

    // Ensure state directory exists
    await fs.mkdir(paths.state, { recursive: true });
    await fs.writeFile(blockedPath, JSON.stringify(blockedTasks, null, 2), 'utf-8');

    if (taskSuccess) {
      // Fire trigger for task blocking
      await triggerSystem.fireTrigger('block', {
        specId,
        taskId: parsedTaskId,
        reason: options.reason,
        until: options.until,
        dependsOn: options.dependsOn,
        source: 'cli_command'
      });

      console.log(chalk.red(`üö´ Blocked task ${parsedTaskId}`));
      console.log(chalk.gray(`   Spec: ${specId}`));
      console.log(chalk.gray(`   Reason: ${options.reason}`));
      if (options.until) {
        console.log(chalk.gray(`   Until: ${options.until}`));
      }
      if (options.dependsOn) {
        console.log(chalk.gray(`   Depends on: ${options.dependsOn}`));
      }
    } else {
      console.error(chalk.red('‚ùå Failed to block task'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Task blocking failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskUnblock(taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const triggerSystem = new ContextTriggerSystem(configManager);
    await triggerSystem.initialize();

    // Parse task ID
    let specId, parsedTaskId;
    if (taskId.includes(':')) {
      [specId, parsedTaskId] = taskId.split(':', 2);
    } else {
      parsedTaskId = taskId;
      specId = options.spec;
    }

    if (!specId) {
      console.error(chalk.red('‚ùå Specification ID required (use --spec or SPEC-ID:TASK-ID format)'));
      process.exit(1);
    }

    // Update task to remove blocking
    const updates = {
      frontmatter: {
        status: 'ready',
        blocked_at: null,
        blocked_reason: null,
        blocked_until: null,
        unblocked_at: new Date().toISOString()
      }
    };

    if (options.notes) {
      updates.frontmatter.unblock_notes = options.notes;
    }

    const taskSuccess = await contextManager.updateContext('task', parsedTaskId, updates);

    // Update blocked tasks registry
    const paths = contextManager.getContextPaths();
    const blockedPath = path.join(paths.state, 'blocked-tasks.json');

    const fs = require('fs').promises;
    let blockedTasks = {};

    try {
      if (await contextManager.fileExists(blockedPath)) {
        const blockedContent = await fs.readFile(blockedPath, 'utf-8');
        blockedTasks = JSON.parse(blockedContent);
      }
    } catch (error) {
      // Start fresh if file is corrupted
    }

    // Remove from blocked tasks registry
    if (blockedTasks[specId] && blockedTasks[specId][parsedTaskId]) {
      delete blockedTasks[specId][parsedTaskId];

      // Clean up empty spec entries
      if (Object.keys(blockedTasks[specId]).length === 0) {
        delete blockedTasks[specId];
      }

      await fs.writeFile(blockedPath, JSON.stringify(blockedTasks, null, 2), 'utf-8');
    }

    if (taskSuccess) {
      // Fire trigger for task unblocking
      await triggerSystem.fireTrigger('unblock', {
        specId,
        taskId: parsedTaskId,
        notes: options.notes,
        source: 'cli_command'
      });

      console.log(chalk.green(`‚úÖ Unblocked task ${parsedTaskId}`));
      console.log(chalk.gray(`   Spec: ${specId}`));
      if (options.notes) {
        console.log(chalk.gray(`   Notes: ${options.notes}`));
      }
    } else {
      console.error(chalk.red('‚ùå Failed to unblock task'));
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Task unblocking failed:'), error.message);
    process.exit(1);
  }
}

async function handleTaskDependencies(action, taskId, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);

    // Parse task ID
    let specId, parsedTaskId;
    if (taskId.includes(':')) {
      [specId, parsedTaskId] = taskId.split(':', 2);
    } else {
      parsedTaskId = taskId;
      specId = options.spec;
    }

    if (!specId) {
      console.error(chalk.red('‚ùå Specification ID required (use --spec or SPEC-ID:TASK-ID format)'));
      process.exit(1);
    }

    // Validate task exists
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    await specParser.loadSpecs();

    const spec = specParser.getSpecById(specId);
    if (!spec) {
      console.error(chalk.red(`‚ùå Specification not found: ${specId}`));
      process.exit(1);
    }

    const task = spec.tasks?.find(t => t.id === parsedTaskId);
    if (!task) {
      console.error(chalk.red(`‚ùå Task not found: ${parsedTaskId} in ${specId}`));
      process.exit(1);
    }

    switch (action.toLowerCase()) {
      case 'add':
        await handleAddTaskDependencies(specId, parsedTaskId, options, contextManager);
        break;
      case 'remove':
        await handleRemoveTaskDependencies(specId, parsedTaskId, options, contextManager);
        break;
      case 'list':
        await handleListTaskDependencies(specId, parsedTaskId, task);
        break;
      default:
        console.error(chalk.red(`‚ùå Unknown action: ${action}. Use: add, remove, list`));
        process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Task dependency management failed:'), error.message);
    process.exit(1);
  }
}

async function handleAddTaskDependencies(specId, taskId, options, contextManager) {
  const updates = { frontmatter: {} };
  let updated = false;

  if (options.dependsOn) {
    const dependencies = options.dependsOn.split(',').map(dep => dep.trim());
    updates.frontmatter.depends_on = dependencies;
    updated = true;

    console.log(chalk.blue(`üìé Adding dependencies for ${taskId}:`));
    dependencies.forEach(dep => {
      console.log(chalk.gray(`   ‚Üí depends on: ${dep}`));
    });
  }

  if (options.blocks) {
    const blockedTasks = options.blocks.split(',').map(task => task.trim());
    updates.frontmatter.blocks = blockedTasks;
    updated = true;

    console.log(chalk.blue(`üö´ Adding blocking relationships for ${taskId}:`));
    blockedTasks.forEach(blocked => {
      console.log(chalk.gray(`   ‚Üí blocks: ${blocked}`));
    });
  }

  if (updated) {
    const success = await contextManager.updateContext('task', taskId, updates);
    if (success) {
      console.log(chalk.green(`‚úÖ Updated dependencies for ${taskId}`));
    } else {
      console.error(chalk.red('‚ùå Failed to update task dependencies'));
      process.exit(1);
    }
  } else {
    console.log(chalk.yellow('‚ö†Ô∏è  No dependencies specified (use --depends-on or --blocks)'));
  }
}

async function handleRemoveTaskDependencies(specId, taskId, options, contextManager) {
  // For removal, we would need to read current dependencies and remove specific ones
  // This is a simplified implementation
  const updates = { frontmatter: {} };
  let updated = false;

  if (options.dependsOn) {
    updates.frontmatter.depends_on = [];
    updated = true;
    console.log(chalk.yellow(`üóëÔ∏è  Removed all dependencies for ${taskId}`));
  }

  if (options.blocks) {
    updates.frontmatter.blocks = [];
    updated = true;
    console.log(chalk.yellow(`üóëÔ∏è  Removed all blocking relationships for ${taskId}`));
  }

  if (updated) {
    const success = await contextManager.updateContext('task', taskId, updates);
    if (success) {
      console.log(chalk.green(`‚úÖ Updated dependencies for ${taskId}`));
    } else {
      console.error(chalk.red('‚ùå Failed to update task dependencies'));
      process.exit(1);
    }
  } else {
    console.log(chalk.yellow('‚ö†Ô∏è  No dependencies specified to remove (use --depends-on or --blocks)'));
  }
}

async function handleListTaskDependencies(specId, taskId, task) {
  console.log(chalk.blue(`üìã Dependencies for ${specId}:${taskId}`));
  console.log(chalk.gray('‚îÄ'.repeat(50)));

  if (task.depends_on && task.depends_on.length > 0) {
    console.log(chalk.cyan('üìé Depends on:'));
    task.depends_on.forEach(dep => {
      console.log(chalk.gray(`   ‚Üí ${dep}`));
    });
  } else {
    console.log(chalk.gray('üìé No dependencies'));
  }

  if (task.blocks && task.blocks.length > 0) {
    console.log(chalk.cyan('\nüö´ Blocks:'));
    task.blocks.forEach(blocked => {
      console.log(chalk.gray(`   ‚Üí ${blocked}`));
    });
  } else {
    console.log(chalk.gray('üö´ No blocking relationships'));
  }

  if (task.status === 'blocked' && task.blocked_reason) {
    console.log(chalk.red(`\nüö´ Currently blocked: ${task.blocked_reason}`));
  }
}

async function handleTasksListEnhanced(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const SpecParser = require('../lib/feature-parser');
    const specParser = new SpecParser(configManager);
    const workflowStateManager = new WorkflowStateManager(configManager);

    await specParser.loadSpecs();
    await workflowStateManager.initialize();

    // Get all specs and tasks
    const allSpecs = specParser.getSpecs();
    let allTasks = [];

    // Extract all tasks with spec context
    for (const spec of allSpecs) {
      if (spec.tasks) {
        for (const task of spec.tasks) {
          allTasks.push({
            ...task,
            specId: spec.id,
            specTitle: spec.title,
            specStatus: spec.status,
            specPhase: spec.phase,
            specPriority: spec.priority
          });
        }
      }
    }

    // Get current assignments for assignment status
    const assignments = await workflowStateManager.getCurrentAssignments();
    const assignmentMap = {};
    assignments.current_assignments.forEach(assignment => {
      const key = `${assignment.spec_id}:${assignment.task_id}`;
      assignmentMap[key] = assignment;
    });

    // Apply filters
    let filteredTasks = allTasks;

    // Filter by spec IDs
    if (options.spec) {
      const specIds = options.spec.split(',').map(id => id.trim());
      filteredTasks = filteredTasks.filter(task => specIds.includes(task.specId));
    }

    // Filter by agent type
    if (options.agent) {
      filteredTasks = filteredTasks.filter(task => {
        const assignment = assignmentMap[`${task.specId}:${task.id}`];
        return task.agent_type === options.agent ||
               (assignment && assignment.assigned_agent === options.agent);
      });
    }

    // Filter by priority
    if (options.priority) {
      const priorities = options.priority.split(',').map(p => p.trim());
      filteredTasks = filteredTasks.filter(task =>
        priorities.includes(task.priority) || priorities.includes(task.specPriority)
      );
    }

    // Filter by phase
    if (options.phase) {
      const phases = options.phase.split(',').map(p => p.trim());
      filteredTasks = filteredTasks.filter(task => phases.includes(task.specPhase));
    }

    // Filter by spec status
    if (options.specStatus) {
      const statuses = options.specStatus.split(',').map(s => s.trim());
      filteredTasks = filteredTasks.filter(task => statuses.includes(task.specStatus));
    }

    // Filter by task status
    if (options.status) {
      const statuses = options.status.split(',').map(s => s.trim());
      filteredTasks = filteredTasks.filter(task => statuses.includes(task.status));
    }

    // Filter blocked tasks
    if (!options.includeBlocked) {
      filteredTasks = filteredTasks.filter(task => task.status !== 'blocked');
    }

    // Filter by assignment status
    if (options.onlyAssigned) {
      filteredTasks = filteredTasks.filter(task => {
        const assignment = assignmentMap[`${task.specId}:${task.id}`];
        return assignment && assignment.assigned_agent;
      });
    } else if (options.onlyUnassigned) {
      filteredTasks = filteredTasks.filter(task => {
        const assignment = assignmentMap[`${task.specId}:${task.id}`];
        return !assignment || !assignment.assigned_agent;
      });
    }

    // Sort tasks
    const sortFunction = getSortFunction(options.sort);
    if (sortFunction) {
      filteredTasks.sort(sortFunction);
    }

    // Limit results
    const limit = parseInt(options.limit) || 20;
    if (filteredTasks.length > limit) {
      filteredTasks = filteredTasks.slice(0, limit);
    }

    // Output in requested format
    switch (options.format) {
      case 'json':
        await outputTasksJson(filteredTasks, assignmentMap, options);
        break;
      case 'csv':
        await outputTasksCsv(filteredTasks, assignmentMap, options);
        break;
      case 'summary':
        await outputTasksSummary(filteredTasks, assignmentMap, options);
        break;
      default:
        await outputTasksTable(filteredTasks, assignmentMap, options);
    }

    // Show summary stats
    if (filteredTasks.length > 0 && options.format !== 'json') {
      console.log(chalk.gray(`\nüìä Showing ${filteredTasks.length} tasks (limit: ${limit})`));

      const stats = {
        ready: filteredTasks.filter(t => t.status === 'ready').length,
        in_progress: filteredTasks.filter(t => t.status === 'in_progress').length,
        blocked: filteredTasks.filter(t => t.status === 'blocked').length,
        completed: filteredTasks.filter(t => t.status === 'complete').length
      };

      console.log(chalk.gray(
        `Status: ${stats.ready} ready, ${stats.in_progress} in progress, ${stats.blocked} blocked, ${stats.completed} completed`
      ));
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Enhanced task listing failed:'), error.message);
    process.exit(1);
  }
}

function getSortFunction(sortType) {
  const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3, null: 4, undefined: 4 };

  switch (sortType) {
    case 'priority':
      return (a, b) => {
        const aPriority = priorityOrder[a.priority] ?? priorityOrder[a.specPriority] ?? 4;
        const bPriority = priorityOrder[b.priority] ?? priorityOrder[b.specPriority] ?? 4;
        return aPriority - bPriority;
      };
    case 'created':
      return (a, b) => new Date(b.created || 0) - new Date(a.created || 0);
    case 'spec':
      return (a, b) => a.specId.localeCompare(b.specId);
    case 'agent':
      return (a, b) => (a.agent_type || '').localeCompare(b.agent_type || '');
    case 'status':
      return (a, b) => (a.status || '').localeCompare(b.status || '');
    default:
      return null;
  }
}

async function outputTasksTable(tasks, assignmentMap, options) {
  if (tasks.length === 0) {
    console.log(chalk.yellow('üìù No tasks found matching the filter criteria'));
    return;
  }

  console.log(chalk.cyan('üìã Task List'));
  console.log(chalk.gray('‚ïê'.repeat(100)));

  for (const task of tasks) {
    const assignment = assignmentMap[`${task.specId}:${task.id}`];
    const statusColor = getTaskStatusColor(task.status);
    const priorityIcon = getPriorityIcon(task.priority || task.specPriority);

    // Main task line
    console.log(
      `${statusColor} ${priorityIcon} ${chalk.yellow(task.specId)}:${chalk.cyan(task.id)} - ${chalk.white(task.title || 'Untitled Task')}`
    );

    // Details line
    const agent = assignment?.assigned_agent || task.agent_type || 'Unassigned';
    const phase = task.specPhase || 'No phase';
    const estimatedHours = task.estimated_hours || 'N/A';

    console.log(chalk.gray(`   üë§ ${agent} | üìç ${phase} | ‚è±Ô∏è  ${estimatedHours}h | üìä ${task.specStatus}`));

    // Show dependencies if requested
    if (options.showDependencies) {
      if (task.depends_on && task.depends_on.length > 0) {
        console.log(chalk.gray(`   üìé Depends on: ${task.depends_on.join(', ')}`));
      }
      if (task.blocks && task.blocks.length > 0) {
        console.log(chalk.gray(`   üö´ Blocks: ${task.blocks.join(', ')}`));
      }
      if (task.status === 'blocked' && task.blocked_reason) {
        console.log(chalk.red(`   üö´ Blocked: ${task.blocked_reason}`));
      }
    }

    // Show context requirements if requested
    if (options.showContext && task.context_requirements) {
      console.log(chalk.gray(`   üìã Context: ${task.context_requirements.join(', ')}`));
    }

    console.log();
  }
}

async function outputTasksJson(tasks, assignmentMap, options) {
  const jsonTasks = tasks.map(task => {
    const assignment = assignmentMap[`${task.specId}:${task.id}`];
    return {
      id: task.id,
      title: task.title,
      status: task.status,
      priority: task.priority || task.specPriority,
      agent_type: task.agent_type,
      assigned_agent: assignment?.assigned_agent,
      estimated_hours: task.estimated_hours,
      spec: {
        id: task.specId,
        title: task.specTitle,
        status: task.specStatus,
        phase: task.specPhase,
        priority: task.specPriority
      },
      dependencies: {
        depends_on: task.depends_on || [],
        blocks: task.blocks || [],
        blocked_reason: task.blocked_reason
      },
      context_requirements: task.context_requirements || [],
      assignment_info: assignment || null
    };
  });

  console.log(JSON.stringify({
    tasks: jsonTasks,
    meta: {
      total: tasks.length,
      filters_applied: Object.keys(options).filter(key => options[key] && !['format', 'limit'].includes(key)),
      timestamp: new Date().toISOString()
    }
  }, null, 2));
}

async function outputTasksCsv(tasks, assignmentMap, _options) {
  // CSV headers
  const headers = [
    'Task ID', 'Task Title', 'Status', 'Priority', 'Agent Type', 'Assigned Agent',
    'Estimated Hours', 'Spec ID', 'Spec Title', 'Spec Status', 'Spec Phase',
    'Dependencies', 'Blocks', 'Context Requirements'
  ];

  console.log(headers.join(','));

  for (const task of tasks) {
    const assignment = assignmentMap[`${task.specId}:${task.id}`];
    const row = [
      `"${task.id}"`,
      `"${task.title || ''}"`,
      `"${task.status || ''}"`,
      `"${task.priority || task.specPriority || ''}"`,
      `"${task.agent_type || ''}"`,
      `"${assignment?.assigned_agent || ''}"`,
      `"${task.estimated_hours || ''}"`,
      `"${task.specId}"`,
      `"${task.specTitle}"`,
      `"${task.specStatus}"`,
      `"${task.specPhase || ''}"`,
      `"${(task.depends_on || []).join(';')}"`,
      `"${(task.blocks || []).join(';')}"`,
      `"${(task.context_requirements || []).join(';')}"`
    ];

    console.log(row.join(','));
  }
}

async function outputTasksSummary(tasks, _assignmentMap, _options) {
  if (tasks.length === 0) {
    console.log(chalk.yellow('üìù No tasks found matching the filter criteria'));
    return;
  }

  console.log(chalk.cyan('üìä Task Summary'));
  console.log(chalk.gray('‚ïê'.repeat(50)));

  // Group by spec
  const tasksBySpec = {};
  tasks.forEach(task => {
    if (!tasksBySpec[task.specId]) {
      tasksBySpec[task.specId] = [];
    }
    tasksBySpec[task.specId].push(task);
  });

  for (const [specId, specTasks] of Object.entries(tasksBySpec)) {
    const spec = specTasks[0]; // Get spec info from first task
    console.log(chalk.yellow(`üìã ${specId}: ${spec.specTitle}`));
    console.log(chalk.gray(`   Status: ${spec.specStatus} | Phase: ${spec.specPhase || 'N/A'} | Priority: ${spec.specPriority}`));

    const statusCounts = {
      ready: specTasks.filter(t => t.status === 'ready').length,
      in_progress: specTasks.filter(t => t.status === 'in_progress').length,
      blocked: specTasks.filter(t => t.status === 'blocked').length,
      complete: specTasks.filter(t => t.status === 'complete').length
    };

    const total = specTasks.length;
    const completion = total > 0 ? Math.round((statusCounts.complete / total) * 100) : 0;

    console.log(chalk.gray(
      `   Tasks: ${total} total (${statusCounts.ready} ready, ${statusCounts.in_progress} active, ${statusCounts.blocked} blocked, ${statusCounts.complete} done) - ${completion}% complete`
    ));

    // Show next ready tasks
    const readyTasks = specTasks.filter(t => t.status === 'ready').slice(0, 3);
    if (readyTasks.length > 0) {
      console.log(chalk.blue('   üìå Ready tasks:'));
      readyTasks.forEach(task => {
        const priorityIcon = getPriorityIcon(task.priority || task.specPriority);
        console.log(chalk.gray(`     ${priorityIcon} ${task.id}: ${task.title || 'Untitled'} (${task.agent_type || 'No agent'})`));
      });
    }

    console.log();
  }
}

function getTaskStatusColor(status) {
  switch (status) {
    case 'ready': return chalk.green('‚óè');
    case 'in_progress': return chalk.blue('‚óè');
    case 'blocked': return chalk.red('‚óè');
    case 'complete': return chalk.green('‚úÖ');
    default: return chalk.gray('‚óã');
  }
}

function getPriorityIcon(priority) {
  switch (priority) {
    case 'P0': return chalk.red('üî•');
    case 'P1': return chalk.yellow('‚ö°');
    case 'P2': return chalk.blue('üìã');
    case 'P3': return chalk.gray('üìù');
    default: return chalk.gray('‚óã');
  }
}

// Helper functions for spec management
function createSpecTemplate(specId, title, type, options) {
  const timestamp = new Date().toISOString();

  return `---
id: "${specId}"
title: "${title}"
type: "${type}"
phase: "${options.phase}"
priority: "${options.priority}"
status: "backlog"
created: "${timestamp}"
estimated_hours: 0
tags: []
tasks: []
dependencies: []
acceptance_criteria: []
---

# ${title}

**Status**: Backlog | **Priority**: ${options.priority} | **Owner**: ${options.agent || 'Unassigned'}

## üéØ Quick Start _(30 seconds)_

**What**: [Brief description of what this ${type.toLowerCase()} delivers]

**Why**: [Business justification and impact]

**Impact**: [Expected outcome and value]

### üöÄ AGENT PICKUP GUIDE

**‚û°Ô∏è Next Available Task**: [What task is ready for pickup]  
**üìã Your Job**: [Clear instructions for the next agent]  
**üö¶ Dependencies**: [Any blockers or prerequisites]

### üö¶ Current State _(AGENTS: Update this when you complete YOUR task)_

- **Next Available Task**: None - awaiting initial task breakdown
- **Current Task Status**: Not started
- **Overall Progress**: 0 of 0 tasks complete
- **Blockers**: None
- **Last Updated**: ${new Date().toISOString().split('T')[0]} by System

---

## üìã Work Definition _(What needs to be built)_

### Problem Statement

[Describe the problem this ${type.toLowerCase()} solves]

### Solution Approach

[High-level approach to solving the problem]

### Success Criteria

- [ ] [Specific measurable outcome 1]
- [ ] [Specific measurable outcome 2]
- [ ] [Specific measurable outcome 3]

---

## üèóÔ∏è Implementation Plan

### Technical Approach

[Technical strategy and key decisions]

### Implementation Tasks _(Each task = one agent handoff)_

[Tasks will be added during planning phase]

---

## ‚úÖ Validation Requirements

### üìù Documentation Checklist _(REQUIRED before committing YOUR task)_

- [ ] **Your Task Status**: Mark your task ‚úÖ and update all subtasks to \`- [x]\`
- [ ] **Current State**: Update "Next Available Task" to show what task is ready next
- [ ] **Success Criteria**: Check off any criteria your task completed
- [ ] **Handoff**: Clear what the next agent should pick up

### üß™ Testing Checklist _(Follow this exact order)_

**BEFORE COMMITTING** _(Required validation sequence)_

- [ ] **Types**: Run \`pnpm typecheck\` - fix all TypeScript errors
- [ ] **Linting**: Run \`pnpm lint && pnpm format\` - fix all style issues
- [ ] **Tests**: Run relevant test suite

---

## üìä Progress Tracking _(AGENTS: Add entry when you complete YOUR task)_

### ‚úÖ Completed Tasks _(Add entry when you finish your task)_

- ‚úÖ **[YYYY-MM-DD]** - **TASK-XXX** completed - _Agent: [name]_ - Next: TASK-YYY ready

### üö® Task Blockers _(Preventing next task pickup)_

- None currently

### ‚û°Ô∏è Handoff Status _(What's ready for next agent)_

- **Ready When**: Initial planning complete
- **Waiting**: Task breakdown and assignment

---

**Priority**: ${options.priority} - ${getPriorityDescription(options.priority)}  
**Effort**: TBD hours  
**Impact**: [Expected impact description]
`;
}

function getPriorityDescription(priority) {
  switch (priority) {
    case 'P0': return 'Critical - blocks other work';
    case 'P1': return 'High - important for current milestone';
    case 'P2': return 'Medium - planned work';
    case 'P3': return 'Low - nice to have';
    default: return 'Standard priority';
  }
}

function sortSpecs(specs, sortField) {
  switch (sortField) {
    case 'priority':
      return specs.sort((a, b) => {
        const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3 };
        return (priorityOrder[a.priority] || 4) - (priorityOrder[b.priority] || 4);
      });
    case 'title':
      return specs.sort((a, b) => a.title.localeCompare(b.title));
    case 'status':
      return specs.sort((a, b) => a.status.localeCompare(b.status));
    case 'created':
      return specs.sort((a, b) => new Date(b.created || 0) - new Date(a.created || 0));
    default:
      return specs;
  }
}

function outputSpecs(specs, format) {
  switch (format) {
    case 'json':
      console.log(JSON.stringify(specs, null, 2));
      break;
    case 'csv':
      outputSpecsCSV(specs);
      break;
    case 'summary':
      outputSpecsSummary(specs);
      break;
    default:
      outputSpecsTable(specs);
  }
}

function outputSpecsTable(specs) {
  if (specs.length === 0) {
    console.log(chalk.yellow('No specifications found matching criteria'));
    return;
  }

  console.log(chalk.cyan('üìã Specifications'));
  console.log(chalk.gray('='.repeat(80)));

  // Table header
  const idWidth = 10;
  const titleWidth = 30;
  const statusWidth = 10;
  const priorityWidth = 8;
  const phaseWidth = 12;

  console.log([
    chalk.cyan('ID'.padEnd(idWidth)),
    chalk.cyan('Title'.padEnd(titleWidth)),
    chalk.cyan('Status'.padEnd(statusWidth)),
    chalk.cyan('Priority'.padEnd(priorityWidth)),
    chalk.cyan('Phase'.padEnd(phaseWidth))
  ].join(' ‚îÇ '));

  console.log('‚îÄ'.repeat(80));

  // Table rows
  specs.forEach(spec => {
    const id = (spec.id || '').padEnd(idWidth);
    const title = (spec.title || '').substring(0, titleWidth - 3).padEnd(titleWidth);
    const status = (spec.status || '').padEnd(statusWidth);
    const priority = getPriorityColor(spec.priority).padEnd(priorityWidth + 10); // Add space for ANSI codes
    const phase = (spec.phase || '').padEnd(phaseWidth);

    console.log([id, title, status, priority, phase].join(' ‚îÇ '));
  });

  console.log(chalk.gray(`\nTotal: ${specs.length} specifications`));
}

function outputSpecsCSV(specs) {
  console.log('ID,Title,Status,Priority,Phase,Type,Created,Estimated Hours');
  specs.forEach(spec => {
    const row = [
      spec.id || '',
      `"${(spec.title || '').replace(/"/g, '""')}"`,
      spec.status || '',
      spec.priority || '',
      spec.phase || '',
      spec.type || '',
      spec.created || '',
      spec.estimated_hours || 0
    ].join(',');
    console.log(row);
  });
}

function outputSpecsSummary(specs) {
  if (specs.length === 0) {
    console.log(chalk.yellow('No specifications found'));
    return;
  }

  console.log(chalk.cyan('üìä Specifications Summary'));
  console.log(chalk.gray('='.repeat(50)));

  // Group by status
  const byStatus = specs.reduce((acc, spec) => {
    acc[spec.status] = acc[spec.status] || [];
    acc[spec.status].push(spec);
    return acc;
  }, {});

  Object.entries(byStatus).forEach(([status, statusSpecs]) => {
    console.log(chalk.white(`\n${status.toUpperCase()}: ${statusSpecs.length}`));
    statusSpecs.forEach(spec => {
      const priority = getPriorityColor(spec.priority);
      console.log(`  ${priority} ${spec.id}: ${spec.title}`);
    });
  });

  console.log(chalk.gray(`\nTotal: ${specs.length} specifications`));
}

function outputSpecDetails(spec, options) {
  console.log(chalk.cyan(`üìã ${spec.id}: ${spec.title}`));
  console.log(chalk.gray('='.repeat(60)));

  console.log(chalk.white('Status:'), getStatusColor(spec.status));
  console.log(chalk.white('Priority:'), getPriorityColor(spec.priority));
  console.log(chalk.white('Phase:'), chalk.blue(spec.phase || 'N/A'));
  console.log(chalk.white('Type:'), chalk.magenta(spec.type || 'N/A'));

  if (spec.created) {
    const date = new Date(spec.created).toLocaleDateString();
    console.log(chalk.white('Created:'), chalk.gray(date));
  }

  if (spec.estimated_hours) {
    console.log(chalk.white('Estimated Hours:'), chalk.yellow(spec.estimated_hours));
  }

  if (spec.description) {
    console.log(chalk.white('\nDescription:'));
    console.log(chalk.gray(spec.description));
  }

  if (options.includeTasks && spec.tasks && spec.tasks.length > 0) {
    console.log(chalk.blue('\nüìã Tasks:'));
    spec.tasks.forEach((task, index) => {
      const status = task.status === 'complete' ? chalk.green('‚úÖ') : chalk.yellow('‚è≥');
      console.log(`  ${index + 1}. ${status} ${task.title || task.id}`);
    });
  }

  if (spec.filePath) {
    console.log(chalk.gray(`\nFile: ${spec.filePath}`));
  }
}

function outputSpecSummary(spec) {
  const priority = getPriorityColor(spec.priority);
  const status = getStatusColor(spec.status);
  console.log(`${priority} ${spec.id}: ${spec.title} [${status}]`);
}

function getPriorityColor(priority) {
  switch (priority) {
    case 'P0': return chalk.red('P0');
    case 'P1': return chalk.yellow('P1');
    case 'P2': return chalk.blue('P2');
    case 'P3': return chalk.gray('P3');
    default: return chalk.gray(priority || 'N/A');
  }
}

function getStatusColor(status) {
  switch (status) {
    case 'active': return chalk.green('active');
    case 'backlog': return chalk.yellow('backlog');
    case 'done': return chalk.blue('done');
    case 'blocked': return chalk.red('blocked');
    default: return chalk.gray(status || 'N/A');
  }
}

function updateFrontmatter(content, key, value) {
  const lines = content.split('\n');
  if (lines[0] !== '---') {
    return content; // No frontmatter
  }

  const endIndex = lines.findIndex((line, index) => index > 0 && line === '---');
  if (endIndex === -1) {
    return content; // Invalid frontmatter
  }

  // Update the key in frontmatter
  let found = false;
  for (let i = 1; i < endIndex; i++) {
    if (lines[i].startsWith(`${key}:`)) {
      lines[i] = `${key}: "${value}"`;
      found = true;
      break;
    }
  }

  // If key not found, add it
  if (!found) {
    lines.splice(endIndex, 0, `${key}: "${value}"`);
  }

  return lines.join('\n');
}

// Handler for research show command
async function handleResearchShow(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);

    let research = [];
    const recentDays = parseInt(options.recent) || 30;
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - recentDays);

    // Collect research from context files
    if (options.spec) {
      const specContext = await contextManager.getContext('spec', options.spec);
      if (specContext && specContext.research) {
        research.push(...specContext.research);
      }
    } else if (options.task) {
      const taskContext = await contextManager.getContext('task', options.task);
      if (taskContext && taskContext.research) {
        research.push(...taskContext.research);
      }
    } else {
      // Get all research findings
      const contextPaths = contextManager.getContextPaths();
      const fs = require('fs').promises;

      try {
        const specDirs = await fs.readdir(contextPaths.specs);
        for (const specDir of specDirs) {
          try {
            const specContext = await contextManager.getContext('spec', specDir);
            if (specContext && specContext.research) {
              research.push(...specContext.research.map(r => ({...r, spec: specDir})));
            }
          } catch (error) {
            // Skip specs that can't be read
          }
        }
      } catch (error) {
        console.warn(chalk.yellow('‚ö†Ô∏è  Could not read context files'));
      }
    }

    // Filter by recent date
    research = research.filter(r => {
      if (!r.created_at) return true;
      return new Date(r.created_at) >= cutoffDate;
    });

    // Sort by date (newest first)
    research.sort((a, b) => {
      const dateA = new Date(a.created_at || 0);
      const dateB = new Date(b.created_at || 0);
      return dateB - dateA;
    });

    if (research.length === 0) {
      console.log(chalk.yellow('No research findings found'));
      return;
    }

    // Output based on format
    switch (options.format) {
      case 'json':
        console.log(JSON.stringify(research, null, 2));
        break;
      case 'table':
        outputResearchTable(research);
        break;
      default:
        outputResearchSummary(research);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Research show failed:'), error.message);
    process.exit(1);
  }
}

// Handler for project export command
async function handleProjectExport(options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const SpecParser = require('../lib/feature-parser');
    const fs = require('fs').promises;
    const path = require('path');

    console.log(chalk.blue('üîç Collecting project data...'));

    const exportData = {
      metadata: {
        exported_at: new Date().toISOString(),
        format: options.format,
        asd_version: '0.1.0-alpha'
      },
      specs: [],
      context: {},
      state: {},
      research: []
    };

    // Collect all specifications
    const parser = new SpecParser({ rootDir: process.cwd() });
    await parser.initialize();
    const specs = await parser.getAllSpecs();

    if (!options.excludeDrafts) {
      exportData.specs = specs;
    } else {
      exportData.specs = specs.filter(s => s.status !== 'draft');
    }

    // Collect context files
    if (options.includeContext) {
      console.log(chalk.blue('üìã Collecting context files...'));

      // Export all spec contexts
      for (const spec of exportData.specs) {
        try {
          const specContext = await contextManager.getContext('spec', spec.id);
          if (specContext) {
            exportData.context[spec.id] = specContext;
          }
        } catch (error) {
          // Skip specs without context
        }
      }

      // Export project-level context
      try {
        const projectContext = await contextManager.getContext('project');
        if (projectContext) {
          exportData.context.project = projectContext;
        }
      } catch (error) {
        // No project context
      }
    }

    // Collect state files
    if (options.includeState) {
      console.log(chalk.blue('üìä Collecting state files...'));
      const contextPaths = contextManager.getContextPaths();
      const statePath = contextPaths.state;

      try {
        const stateFiles = await fs.readdir(statePath);
        for (const file of stateFiles) {
          if (file.endsWith('.json')) {
            try {
              const filePath = path.join(statePath, file);
              const content = await fs.readFile(filePath, 'utf-8');
              exportData.state[file.replace('.json', '')] = JSON.parse(content);
            } catch (error) {
              // Skip corrupted files
            }
          }
        }
      } catch (error) {
        // No state directory
      }
    }

    // Collect research findings
    if (options.includeResearch) {
      console.log(chalk.blue('üî¨ Collecting research findings...'));
      for (const [specId, context] of Object.entries(exportData.context)) {
        if (context.research) {
          exportData.research.push(...context.research.map(r => ({...r, spec: specId})));
        }
      }
    }

    // Output based on format
    const outputPath = options.output;

    switch (options.format) {
      case 'json':
        await fs.writeFile(`${outputPath}.json`, JSON.stringify(exportData, null, 2));
        console.log(chalk.green(`‚úÖ Project exported to ${outputPath}.json`));
        break;
      case 'tar':
      case 'zip':
        // For archive formats, create directory structure
        await fs.mkdir(outputPath, { recursive: true });
        await fs.writeFile(path.join(outputPath, 'metadata.json'), JSON.stringify(exportData.metadata, null, 2));
        await fs.writeFile(path.join(outputPath, 'specs.json'), JSON.stringify(exportData.specs, null, 2));
        await fs.writeFile(path.join(outputPath, 'context.json'), JSON.stringify(exportData.context, null, 2));
        await fs.writeFile(path.join(outputPath, 'state.json'), JSON.stringify(exportData.state, null, 2));
        await fs.writeFile(path.join(outputPath, 'research.json'), JSON.stringify(exportData.research, null, 2));
        console.log(chalk.green(`‚úÖ Project exported to ${outputPath}/`));
        break;
      default:
        await fs.writeFile(`${outputPath}.json`, JSON.stringify(exportData, null, 2));
        console.log(chalk.green(`‚úÖ Project exported to ${outputPath}.json`));
    }

    // Show export summary
    console.log(chalk.cyan('\nüìä Export Summary:'));
    console.log(chalk.white(`  Specifications: ${exportData.specs.length}`));
    console.log(chalk.white(`  Context Files: ${Object.keys(exportData.context).length}`));
    console.log(chalk.white(`  State Files: ${Object.keys(exportData.state).length}`));
    console.log(chalk.white(`  Research Items: ${exportData.research.length}`));

  } catch (error) {
    console.error(chalk.red('‚ùå Project export failed:'), error.message);
    process.exit(1);
  }
}

// Handler for project import command
async function handleProjectImport(file, options) {
  try {
    const configManager = new ConfigManager(process.cwd());
    const contextManager = new ContextManager(configManager);
    const fs = require('fs').promises;
    const path = require('path');

    console.log(chalk.blue('üîç Reading project import file...'));

    let importData;
    try {
      const content = await fs.readFile(file, 'utf-8');
      importData = JSON.parse(content);
    } catch (error) {
      throw new Error(`Cannot read import file: ${error.message}`);
    }

    // Validate import data
    if (options.validate) {
      console.log(chalk.blue('‚úÖ Validating import data...'));

      if (!importData.metadata || !importData.specs) {
        throw new Error('Invalid import file format - missing required sections');
      }

      console.log(chalk.green('‚úÖ Import data validation passed'));
    }

    if (options.dryRun) {
      console.log(chalk.cyan('üîç Dry Run - Would import:'));
      console.log(chalk.white(`  Specifications: ${importData.specs?.length || 0}`));
      console.log(chalk.white(`  Context Files: ${Object.keys(importData.context || {}).length}`));
      console.log(chalk.white(`  State Files: ${Object.keys(importData.state || {}).length}`));
      console.log(chalk.white(`  Research Items: ${importData.research?.length || 0}`));
      console.log(chalk.gray('\nNo changes made (dry run mode)'));
      return;
    }

    console.log(chalk.blue('üì• Importing project data...'));

    // Import context files
    if (importData.context) {
      console.log(chalk.blue('üìã Importing context files...'));
      for (const [contextId, contextData] of Object.entries(importData.context)) {
        try {
          if (contextId === 'project') {
            await contextManager.updateContext('project', null, { content: contextData });
          } else {
            await contextManager.updateContext('spec', contextId, { content: contextData });
          }
        } catch (error) {
          console.warn(chalk.yellow(`‚ö†Ô∏è  Could not import context for ${contextId}: ${error.message}`));
        }
      }
    }

    // Import state files
    if (importData.state) {
      console.log(chalk.blue('üìä Importing state files...'));
      const contextPaths = contextManager.getContextPaths();
      await fs.mkdir(contextPaths.state, { recursive: true });

      for (const [stateFile, stateData] of Object.entries(importData.state)) {
        try {
          const filePath = path.join(contextPaths.state, `${stateFile}.json`);
          await fs.writeFile(filePath, JSON.stringify(stateData, null, 2));
        } catch (error) {
          console.warn(chalk.yellow(`‚ö†Ô∏è  Could not import state file ${stateFile}: ${error.message}`));
        }
      }
    }

    console.log(chalk.green('‚úÖ Project import completed successfully'));

    // Show import summary
    console.log(chalk.cyan('\nüìä Import Summary:'));
    console.log(chalk.white(`  Specifications: ${importData.specs?.length || 0}`));
    console.log(chalk.white(`  Context Files: ${Object.keys(importData.context || {}).length}`));
    console.log(chalk.white(`  State Files: ${Object.keys(importData.state || {}).length}`));
    console.log(chalk.white(`  Research Items: ${importData.research?.length || 0}`));

  } catch (error) {
    console.error(chalk.red('‚ùå Project import failed:'), error.message);
    process.exit(1);
  }
}

// Output formatters for research
function outputResearchTable(research) {
  console.log(chalk.cyan('üî¨ Research Findings'));
  console.log(chalk.gray('='.repeat(80)));

  research.forEach((item, index) => {
    const date = item.created_at ? new Date(item.created_at).toLocaleDateString() : 'Unknown';
    const spec = item.spec ? chalk.yellow(`[${item.spec}]`) : '';

    console.log(`${index + 1}. ${spec} ${chalk.white(item.finding || item.content || 'No content')}`);
    if (item.source) {
      console.log(`   ${chalk.gray('Source:')} ${chalk.blue(item.source)}`);
    }
    console.log(`   ${chalk.gray('Date:')} ${chalk.gray(date)}`);
    console.log();
  });
}

function outputResearchSummary(research) {
  console.log(chalk.cyan(`üî¨ Research Summary (${research.length} findings)`));
  console.log(chalk.gray('='.repeat(50)));

  const grouped = research.reduce((acc, item) => {
    const spec = item.spec || 'general';
    acc[spec] = acc[spec] || [];
    acc[spec].push(item);
    return acc;
  }, {});

  Object.entries(grouped).forEach(([spec, items]) => {
    console.log(chalk.yellow(`\n${spec.toUpperCase()}: ${items.length} findings`));
    items.slice(0, 3).forEach(item => {
      const finding = item.finding || item.content || 'No content';
      const truncated = finding.length > 60 ? finding.substring(0, 60) + '...' : finding;
      console.log(`  ‚Ä¢ ${chalk.white(truncated)}`);
    });

    if (items.length > 3) {
      console.log(`  ${chalk.gray(`... and ${items.length - 3} more`)}`);
    }
  });
}

// Multi-format data support commands (FEAT-020)
const formatCommand = program
  .command('format')
  .description('Multi-format data operations (JSON, YAML, Markdown)');

formatCommand
  .command('convert <input> <output>')
  .description('Convert between specification formats')
  .option('--from <format>', 'Source format (auto-detect if not specified)')
  .option('--to <format>', 'Target format (auto-detect from extension if not specified)')
  .option('--validate', 'Validate conversion with roundtrip test')
  .option('--backup', 'Create backup of output file if it exists')
  .action(async (input, output, options) => {
    await handleFormatConversion(input, output, options);
  });

const validateCommand = program
  .command('validate')
  .description('Validate specification files against schema');

validateCommand
  .command('spec <file>')
  .description('Validate a specification file')
  .option('--schema <name>', 'Schema to validate against (default: auto-detect)')
  .option('--format <format>', 'Expected format (default: auto-detect)')
  .option('--auto-fix', 'Apply automatic fixes to common issues')
  .action(async (filePath, options) => {
    await handleSpecValidation(filePath, options);
  });

// Multi-format command handlers
async function handleFormatConversion(input, output, options) {
  try {
    const { DataAdapterFactory } = require('../lib/data-adapters');
    const factory = new DataAdapterFactory();

    console.log(chalk.cyan('üîÑ Format Conversion'));
    console.log(chalk.gray('='.repeat(40)));

    const result = await factory.convertFile(input, output, {
      sourceFormat: options.from,
      targetFormat: options.to,
      validate: options.validate,
      backup: options.backup
    });

    if (result.success) {
      console.log(chalk.green('‚úÖ Conversion successful'));
      console.log(`Source: ${chalk.yellow(result.sourcePath)} (${result.sourceFormat})`);
      console.log(`Target: ${chalk.yellow(result.targetPath)} (${result.targetFormat})`);
      
      if (result.validation && !result.validation.isValid) {
        console.log(chalk.yellow('\n‚ö†Ô∏è  Validation warnings:'));
        result.validation.errors.forEach(error => {
          console.log(`  ‚Ä¢ ${error.message}`);
        });
      }
    } else {
      console.error(chalk.red('‚ùå Conversion failed:'), result.error);
      process.exit(1);
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Format conversion failed:'), error.message);
    process.exit(1);
  }
}

async function handleSpecValidation(filePath, options) {
  try {
    const { DataAdapterFactory } = require('../lib/data-adapters');
    const factory = new DataAdapterFactory();

    console.log(chalk.cyan('‚úÖ Specification Validation'));
    console.log(chalk.gray('='.repeat(40)));

    const fs = require('fs').promises;
    const content = await fs.readFile(filePath, 'utf-8');
    const format = options.format || await factory.formatDetector.detectFormat(filePath, content);

    const result = await factory.validateContent(content, format, {
      schema: options.schema || 'auto',
      autoFix: options.autoFix
    });

    console.log(`File: ${chalk.yellow(filePath)} (${format})`);
    
    if (result.isValid) {
      console.log(`Status: ${chalk.green('‚úÖ Valid')}`);
    } else {
      console.log(`Status: ${chalk.red('‚ùå Invalid')}`);
      
      if (result.errors.length > 0) {
        console.log('\nErrors:');
        result.errors.forEach(error => {
          console.log(`  ‚Ä¢ ${chalk.red(error.field)}: ${error.message}`);
        });
      }
    }

    if (result.warnings && result.warnings.length > 0) {
      console.log('\nWarnings:');
      result.warnings.forEach(warning => {
        console.log(`  ‚Ä¢ ${chalk.yellow(warning.field || 'general')}: ${warning.message}`);
      });
    }

  } catch (error) {
    console.error(chalk.red('‚ùå Validation failed:'), error.message);
    process.exit(1);
  }
}

// Handle CLI parsing
program.parse();

// If no command was specified and no arguments, show help
if (!process.argv.slice(2).length) {
  const options = program.opts();
  startASD(options);
}